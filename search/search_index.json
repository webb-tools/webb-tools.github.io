{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Webb \u00b6 We are building privacy tools for the multi-chain world. There are quite a few repositories that work together to bring our Webb ecosystem to life: Webb Dapp \u00b6 Repo The Webb Dapp is the portal into the Webb. It is the frontend which allows end users to move their assets and retain their privacy. Relayer \u00b6 Repo It is non-trivial to get access to funds in two separate addresses without linking these two addresses. The relayer helps to facilitate privacy from an on-chain transaction perspective. Users send transactions for withdrawing from the ecosystem to the relayer, and the relayer executes these transactions. Webb.rs \u00b6 Repo Implementations of core Webb aspects in rust. Core pieces include data structures like merkle trees, hasher implementations like the pederson hash, EVM interaction with ethers.rs. Tornado Core \u00b6 Repo Forked from Tornado cash - core logic for EVM smart contract mixers. Javascript implementations of circuit and key generation. Scripts for interacting with these smart contracts. Protocol Solidity \u00b6 Repo Implementation of the Webb with private bridges inspired by chainsafe and generalized merkle trees that can accept a variety of hash functions. Anon \u00b6 Repo A substrate node which contains the merkle and mixer pallets. These pallets are built using ed25519 and bulletproofs precompiles. Arkworks Gadgets \u00b6 Repo Gadgets and constraints written using the arkworks libraries for Webb. Darkwebb \u00b6 Repo A substrate node using rust crates to build a parachain implementation of Webb. The darkwebb is a rearchitecting of the anon node to optimize for runtime blob size.","title":"Home"},{"location":"#welcome-to-webb","text":"We are building privacy tools for the multi-chain world. There are quite a few repositories that work together to bring our Webb ecosystem to life:","title":"Welcome to Webb"},{"location":"#webb-dapp","text":"Repo The Webb Dapp is the portal into the Webb. It is the frontend which allows end users to move their assets and retain their privacy.","title":"Webb Dapp"},{"location":"#relayer","text":"Repo It is non-trivial to get access to funds in two separate addresses without linking these two addresses. The relayer helps to facilitate privacy from an on-chain transaction perspective. Users send transactions for withdrawing from the ecosystem to the relayer, and the relayer executes these transactions.","title":"Relayer"},{"location":"#webbrs","text":"Repo Implementations of core Webb aspects in rust. Core pieces include data structures like merkle trees, hasher implementations like the pederson hash, EVM interaction with ethers.rs.","title":"Webb.rs"},{"location":"#tornado-core","text":"Repo Forked from Tornado cash - core logic for EVM smart contract mixers. Javascript implementations of circuit and key generation. Scripts for interacting with these smart contracts.","title":"Tornado Core"},{"location":"#protocol-solidity","text":"Repo Implementation of the Webb with private bridges inspired by chainsafe and generalized merkle trees that can accept a variety of hash functions.","title":"Protocol Solidity"},{"location":"#anon","text":"Repo A substrate node which contains the merkle and mixer pallets. These pallets are built using ed25519 and bulletproofs precompiles.","title":"Anon"},{"location":"#arkworks-gadgets","text":"Repo Gadgets and constraints written using the arkworks libraries for Webb.","title":"Arkworks Gadgets"},{"location":"#darkwebb","text":"Repo A substrate node using rust crates to build a parachain implementation of Webb. The darkwebb is a rearchitecting of the anon node to optimize for runtime blob size.","title":"Darkwebb"},{"location":"mixer-protocols/tornado/deployments/","text":"Mixer Deployments \u00b6 If you'd like to interact with the mixers programmatically, we have live deployments at the contracts below. Rinkeby \u00b6 Name Source Address .1 ETH Mixer NativeAnchor.sol 0x626FEc5Ffa7Bf1EE8CEd7daBdE545630473E3ABb 1 ETH Mixer NativeAnchor.sol 0x979cBd4917e81447983ef87591B9E1ab21727a61 Hasher Hasher.json 0xE6C5D1c6cc3c6772694d75f61E949daB100a4489 Verifier Verifier.sol 0x95A5CcfCa50F7Dcf410CE397Bb7Becf1b42Ae601 Harmony Testnet Shard 1 \u00b6 Harmony shares Webb's vision of an interoperable future, and we are happy to have Harmony as one of our first supported chains. Name Source Address 100 ONE mixer NativeAnchor.sol 0x7cd1F52e5EEdf753e99D945276a725CE533AaD1a 1000 ONE mixer NativeAnchor.sol 0xD7f9BB9957100310aD397D2bA31771D939BD4731 10000 ONE mixer NativeAnchor.sol 0xeE2eB8F142e48e5D1bDD34e0924Ed3B4aa0d4222 100000 ONE mixer NativeAnchor.sol 0x7cd173094eF78FFAeDee4e14576A73a79aA716ac Hasher Hasher.json 0x96B8Bff1fE9a9c0656b84d7bd1013faD2435Edc0 Verifier Verifier.sol 0xca2c45fe334fBb9d9356AaB291842b964DB9B0E3 Beresheet EVM \u00b6 Edgeware is the first supported EVM in the substrate ecosystem. This ecosystem was born out of interoperable ideals. Name Source Address 100 tEDG mixer NativeAnchor.sol 0xc0d863EE313636F067dCF89e6ea904AD5f8DEC65 1000 tEDG mixer NativeAnchor.sol 0xc7c6152214d0Db4e161Fa67fB62811Be7326834A Hasher Hasher.json 0x96B8Bff1fE9a9c0656b84d7bd1013faD2435Edc0 Verifier Verifier.sol 0xca2c45fe334fBb9d9356AaB291842b964DB9B0E3","title":"Deployments"},{"location":"mixer-protocols/tornado/deployments/#mixer-deployments","text":"If you'd like to interact with the mixers programmatically, we have live deployments at the contracts below.","title":"Mixer Deployments"},{"location":"mixer-protocols/tornado/deployments/#rinkeby","text":"Name Source Address .1 ETH Mixer NativeAnchor.sol 0x626FEc5Ffa7Bf1EE8CEd7daBdE545630473E3ABb 1 ETH Mixer NativeAnchor.sol 0x979cBd4917e81447983ef87591B9E1ab21727a61 Hasher Hasher.json 0xE6C5D1c6cc3c6772694d75f61E949daB100a4489 Verifier Verifier.sol 0x95A5CcfCa50F7Dcf410CE397Bb7Becf1b42Ae601","title":"Rinkeby"},{"location":"mixer-protocols/tornado/deployments/#harmony-testnet-shard-1","text":"Harmony shares Webb's vision of an interoperable future, and we are happy to have Harmony as one of our first supported chains. Name Source Address 100 ONE mixer NativeAnchor.sol 0x7cd1F52e5EEdf753e99D945276a725CE533AaD1a 1000 ONE mixer NativeAnchor.sol 0xD7f9BB9957100310aD397D2bA31771D939BD4731 10000 ONE mixer NativeAnchor.sol 0xeE2eB8F142e48e5D1bDD34e0924Ed3B4aa0d4222 100000 ONE mixer NativeAnchor.sol 0x7cd173094eF78FFAeDee4e14576A73a79aA716ac Hasher Hasher.json 0x96B8Bff1fE9a9c0656b84d7bd1013faD2435Edc0 Verifier Verifier.sol 0xca2c45fe334fBb9d9356AaB291842b964DB9B0E3","title":"Harmony Testnet Shard 1"},{"location":"mixer-protocols/tornado/deployments/#beresheet-evm","text":"Edgeware is the first supported EVM in the substrate ecosystem. This ecosystem was born out of interoperable ideals. Name Source Address 100 tEDG mixer NativeAnchor.sol 0xc0d863EE313636F067dCF89e6ea904AD5f8DEC65 1000 tEDG mixer NativeAnchor.sol 0xc7c6152214d0Db4e161Fa67fB62811Be7326834A Hasher Hasher.json 0x96B8Bff1fE9a9c0656b84d7bd1013faD2435Edc0 Verifier Verifier.sol 0xca2c45fe334fBb9d9356AaB291842b964DB9B0E3","title":"Beresheet EVM"},{"location":"mixer-protocols/tornado/overview/","text":"Tornado Core \u00b6 The tornado core library defines a set of Solidity smart contracts for mixers. These contracts are used in the dapp for EVM interactions.","title":"Overview"},{"location":"mixer-protocols/tornado/overview/#tornado-core","text":"The tornado core library defines a set of Solidity smart contracts for mixers. These contracts are used in the dapp for EVM interactions.","title":"Tornado Core"},{"location":"mixer-protocols/tornado/contracts/Anchor/","text":"Anchor.sol \u00b6 Description \u00b6 An abstract contract that requires child classes to implement appropriate verification and processes for deposits and withdrawals. Variables \u00b6 verifier \u00b6 Type: public immutable IVerifier denomination \u00b6 Type: public immutable uint32 nullifierHashes \u00b6 Type: public mapping(bytes32 => bool) commitments \u00b6 Type: public mapping(bytes32 => bool) Constructor \u00b6 Details Signature constructor(IVerifier _verifier, IHasher _hasher, uint256 _denomination, uint256 _treeHeight) MerkleTreeWithHistory(_merkleTreeHeight, _hasher) External Functions \u00b6 Calls to deposits require a commitment, which is a hash of some secret values. Deposit \u00b6 Details Signature deposit(bytes32 _commitment) Requires require(..., \"commitment has been submitted\") Emits Deposit Withdraw \u00b6 Details Signature withdraw(address _recipient, address _relayer, uint256 _fee, uint256 _refund) Requires require(_fee <= denomination) require(..., \"The not has already been spent\") require(..., \"Cannot find your merkle root\") require(..., \"Invalid withdraw proof\") Emits Withdraw View Functions \u00b6 isSpent \u00b6 Details Signature isSpent(bytes32 _nullifierHash) public view returns (bool) isSpentArray \u00b6 Details Signature isSpentArray(bytes32[] calldata _nullifierHashes) external view returns (bool[] memory spent) Events \u00b6 Deposit \u00b6 Signature : Deposit(bytes32 indexed commitment, uint32 leafIndex, uint256 timestamp) Withdraw \u00b6 Signature : Withdrawal(address to, bytes32 nullifierHash, address indexed relayer, uint256 fee)","title":"Anchor"},{"location":"mixer-protocols/tornado/contracts/Anchor/#anchorsol","text":"","title":"Anchor.sol"},{"location":"mixer-protocols/tornado/contracts/Anchor/#description","text":"An abstract contract that requires child classes to implement appropriate verification and processes for deposits and withdrawals.","title":"Description"},{"location":"mixer-protocols/tornado/contracts/Anchor/#variables","text":"","title":"Variables"},{"location":"mixer-protocols/tornado/contracts/Anchor/#verifier","text":"Type: public immutable IVerifier","title":"verifier"},{"location":"mixer-protocols/tornado/contracts/Anchor/#denomination","text":"Type: public immutable uint32","title":"denomination"},{"location":"mixer-protocols/tornado/contracts/Anchor/#nullifierhashes","text":"Type: public mapping(bytes32 => bool)","title":"nullifierHashes"},{"location":"mixer-protocols/tornado/contracts/Anchor/#commitments","text":"Type: public mapping(bytes32 => bool)","title":"commitments"},{"location":"mixer-protocols/tornado/contracts/Anchor/#constructor","text":"Details Signature constructor(IVerifier _verifier, IHasher _hasher, uint256 _denomination, uint256 _treeHeight) MerkleTreeWithHistory(_merkleTreeHeight, _hasher)","title":"Constructor"},{"location":"mixer-protocols/tornado/contracts/Anchor/#external-functions","text":"Calls to deposits require a commitment, which is a hash of some secret values.","title":"External Functions"},{"location":"mixer-protocols/tornado/contracts/Anchor/#deposit","text":"Details Signature deposit(bytes32 _commitment) Requires require(..., \"commitment has been submitted\") Emits Deposit","title":"Deposit"},{"location":"mixer-protocols/tornado/contracts/Anchor/#withdraw","text":"Details Signature withdraw(address _recipient, address _relayer, uint256 _fee, uint256 _refund) Requires require(_fee <= denomination) require(..., \"The not has already been spent\") require(..., \"Cannot find your merkle root\") require(..., \"Invalid withdraw proof\") Emits Withdraw","title":"Withdraw"},{"location":"mixer-protocols/tornado/contracts/Anchor/#view-functions","text":"","title":"View Functions"},{"location":"mixer-protocols/tornado/contracts/Anchor/#isspent","text":"Details Signature isSpent(bytes32 _nullifierHash) public view returns (bool)","title":"isSpent"},{"location":"mixer-protocols/tornado/contracts/Anchor/#isspentarray","text":"Details Signature isSpentArray(bytes32[] calldata _nullifierHashes) external view returns (bool[] memory spent)","title":"isSpentArray"},{"location":"mixer-protocols/tornado/contracts/Anchor/#events","text":"","title":"Events"},{"location":"mixer-protocols/tornado/contracts/Anchor/#deposit_1","text":"Signature : Deposit(bytes32 indexed commitment, uint32 leafIndex, uint256 timestamp)","title":"Deposit"},{"location":"mixer-protocols/tornado/contracts/Anchor/#withdraw_1","text":"Signature : Withdrawal(address to, bytes32 nullifierHash, address indexed relayer, uint256 fee)","title":"Withdraw"},{"location":"mixer-protocols/tornado/contracts/IHasher/","text":"IHasher \u00b6 Description \u00b6 The hasher for contracts in tornado core uses MiMC. It is generated from circom's mimcsponge_gencontract.js MiMCSponge \u00b6 Details Signature MiMCSponge(uint256 in_xL, uint256 in_xR) external pure returns (uint256 xL, uint256 xR)","title":"IHasher"},{"location":"mixer-protocols/tornado/contracts/IHasher/#ihasher","text":"","title":"IHasher"},{"location":"mixer-protocols/tornado/contracts/IHasher/#description","text":"The hasher for contracts in tornado core uses MiMC. It is generated from circom's mimcsponge_gencontract.js","title":"Description"},{"location":"mixer-protocols/tornado/contracts/IHasher/#mimcsponge","text":"Details Signature MiMCSponge(uint256 in_xL, uint256 in_xR) external pure returns (uint256 xL, uint256 xR)","title":"MiMCSponge"},{"location":"mixer-protocols/tornado/contracts/IVerifier/","text":"IVerifier \u00b6 Description \u00b6 The verifier exposes the verifyProof view function and is generated from the verifying key for the corresponding SNARK. verifyProof \u00b6 Details Signature verifyProof(bytes memory _proof, uint256[6] memory _input) external returns (bool)","title":"IVerifier"},{"location":"mixer-protocols/tornado/contracts/IVerifier/#iverifier","text":"","title":"IVerifier"},{"location":"mixer-protocols/tornado/contracts/IVerifier/#description","text":"The verifier exposes the verifyProof view function and is generated from the verifying key for the corresponding SNARK.","title":"Description"},{"location":"mixer-protocols/tornado/contracts/IVerifier/#verifyproof","text":"Details Signature verifyProof(bytes memory _proof, uint256[6] memory _input) external returns (bool)","title":"verifyProof"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/","text":"MerkleTreeWithHistory.sol \u00b6 Description \u00b6 The MerkleTreeWithHistory is the data structure which holds the commitments of deposits - which are hashes of secret values picked by the user. When a user wishes to withdraw from the mixer, the user needs to submit a proof which shows the knowledge of these secret values. This proof needs this merkle tree to calculate the path from the leaves (commitments) to the root. Variables \u00b6 hasher \u00b6 Type: public immutable IHasher levels \u00b6 Type: public immutable uint32 filledSubtrees \u00b6 Type: public mapping(uint256 => bytes32) roots \u00b6 Type: public mapping(uint256 => bytes32) ROOT_HISTORY_SIZE \u00b6 Type: public constant uint32 currentRootIndex \u00b6 Type: public uint32 nextIndex \u00b6 Type: public uint32 Constructor \u00b6 Details Signature constructor(uint32 _levels, IHasher _hasher) Requires require(_levels > 0) require(_levels < 32) External Functions \u00b6 hashLeftRight \u00b6 Details Signature function hashLeftRight(IHasher _hasher, bytes32 _left, bytes32 _right) public pure returns (bytes32) Requires require(..., \"_left should be inside the field\") require(..., \"_right should be instide the field\") View Functions \u00b6 isKnownRoot \u00b6 Details Signature isKnownRoot(bytes32 _root) public view returns (bool) getLastRoot \u00b6 Details Signature getLastRoot() public view returns (bytes32) zeros \u00b6 Details Signature zeros(uint256 i) public pure returns (bytes32) Internal Functions \u00b6 _insert \u00b6 Details Signature _insert(bytes32 _leaf) internal returns (uint32 index) Requires require(..., \"merkle tree is full\")","title":"MerkleTreeWithHistory"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#merkletreewithhistorysol","text":"","title":"MerkleTreeWithHistory.sol"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#description","text":"The MerkleTreeWithHistory is the data structure which holds the commitments of deposits - which are hashes of secret values picked by the user. When a user wishes to withdraw from the mixer, the user needs to submit a proof which shows the knowledge of these secret values. This proof needs this merkle tree to calculate the path from the leaves (commitments) to the root.","title":"Description"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#variables","text":"","title":"Variables"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#hasher","text":"Type: public immutable IHasher","title":"hasher"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#levels","text":"Type: public immutable uint32","title":"levels"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#filledsubtrees","text":"Type: public mapping(uint256 => bytes32)","title":"filledSubtrees"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#roots","text":"Type: public mapping(uint256 => bytes32)","title":"roots"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#root_history_size","text":"Type: public constant uint32","title":"ROOT_HISTORY_SIZE"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#currentrootindex","text":"Type: public uint32","title":"currentRootIndex"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#nextindex","text":"Type: public uint32","title":"nextIndex"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#constructor","text":"Details Signature constructor(uint32 _levels, IHasher _hasher) Requires require(_levels > 0) require(_levels < 32)","title":"Constructor"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#external-functions","text":"","title":"External Functions"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#hashleftright","text":"Details Signature function hashLeftRight(IHasher _hasher, bytes32 _left, bytes32 _right) public pure returns (bytes32) Requires require(..., \"_left should be inside the field\") require(..., \"_right should be instide the field\")","title":"hashLeftRight"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#view-functions","text":"","title":"View Functions"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#isknownroot","text":"Details Signature isKnownRoot(bytes32 _root) public view returns (bool)","title":"isKnownRoot"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#getlastroot","text":"Details Signature getLastRoot() public view returns (bytes32)","title":"getLastRoot"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#zeros","text":"Details Signature zeros(uint256 i) public pure returns (bytes32)","title":"zeros"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#internal-functions","text":"","title":"Internal Functions"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#_insert","text":"Details Signature _insert(bytes32 _leaf) internal returns (uint32 index) Requires require(..., \"merkle tree is full\")","title":"_insert"},{"location":"mixer-protocols/tornado/contracts/NativeAnchor/","text":"NativeAnchor.sol \u00b6 Description \u00b6 A concrete instance of a mixer which deals with the native currency of the chain. Constructor \u00b6 Details Signature constructor(IVerifier _verifier, IHasher _hasher, uint256 _denomination, uint256 _merkleTreeHeight) Anchor(_verifier, _hasher, _denomination, _merkleTreeHeight) {} Internal Functions \u00b6 _processWithdraw \u00b6 Details Signature _processWithdraw(address _recipient, address _relayer, uint256 _fee, uint256 _refund) internal override Requires require(msg.value == 0) require(_refund == 0) require(..., \"payment to _recipient did not go through\") require(..., \"payment to _relayer did not go through\") _processDeposit \u00b6 Details Signature _processDeposit() internal override Requires require(msg.value == denomination)","title":"NativeAnchor"},{"location":"mixer-protocols/tornado/contracts/NativeAnchor/#nativeanchorsol","text":"","title":"NativeAnchor.sol"},{"location":"mixer-protocols/tornado/contracts/NativeAnchor/#description","text":"A concrete instance of a mixer which deals with the native currency of the chain.","title":"Description"},{"location":"mixer-protocols/tornado/contracts/NativeAnchor/#constructor","text":"Details Signature constructor(IVerifier _verifier, IHasher _hasher, uint256 _denomination, uint256 _merkleTreeHeight) Anchor(_verifier, _hasher, _denomination, _merkleTreeHeight) {}","title":"Constructor"},{"location":"mixer-protocols/tornado/contracts/NativeAnchor/#internal-functions","text":"","title":"Internal Functions"},{"location":"mixer-protocols/tornado/contracts/NativeAnchor/#_processwithdraw","text":"Details Signature _processWithdraw(address _recipient, address _relayer, uint256 _fee, uint256 _refund) internal override Requires require(msg.value == 0) require(_refund == 0) require(..., \"payment to _recipient did not go through\") require(..., \"payment to _relayer did not go through\")","title":"_processWithdraw"},{"location":"mixer-protocols/tornado/contracts/NativeAnchor/#_processdeposit","text":"Details Signature _processDeposit() internal override Requires require(msg.value == denomination)","title":"_processDeposit"},{"location":"relayer/http-endpoints/","text":"Exposed endpoints the client can query to obtain data about their exposed data, the relayer, or mixer deployments. API v1 \u00b6 IP \u00b6 Relayers can let the client know of their IP address. This is informative to the client, as their privacy is potentially compromised by this information. /api/v1/ip Response Format { \"ip\": <string> } Response Explanation The IP address from which the request was sent to the relayer. Info \u00b6 A client should make a call to the relayer to find which chains it supports, as well as the fees and relayer address to include in the proof generation. /api/v1/info Response Format { evm: { [networkName]: { \"withdrawFeePercentage\": <number>, \"account\": <string>, \"enableLeavesWatcher\": <boolean>, }, ... } } Response Explanation withdrawFeePercentage : The minimum amount of percentage that the relayer requires to send a transaction on the client's behalf. account : The reward account of the relayer, which will collect the fee. enableLeavesWatcher : A boolean flag indicating if the relayer is able to provide a client with the leaves that make up the merkle tree of a particular mixer. EVM Mixer Leaves \u00b6 A client can query the relayer for the leaves (commitments) of a mixer deployment. This information is necessary for building the merkle tree on the client side, in order to build the proof of secrets for a particular commitment. The client can query the blockchain directly, but getting the information from a relayer will be much quicker. /api/v1/leaves/:contractAddress Response Format { \"leaves\": [ <hex-string>, <hex-string>, ... ] } Response explanation The leaves will be properly indexed in the array.","title":"Http Endpoints"},{"location":"relayer/http-endpoints/#api-v1","text":"","title":"API v1"},{"location":"relayer/http-endpoints/#ip","text":"Relayers can let the client know of their IP address. This is informative to the client, as their privacy is potentially compromised by this information. /api/v1/ip Response Format { \"ip\": <string> } Response Explanation The IP address from which the request was sent to the relayer.","title":"IP"},{"location":"relayer/http-endpoints/#info","text":"A client should make a call to the relayer to find which chains it supports, as well as the fees and relayer address to include in the proof generation. /api/v1/info Response Format { evm: { [networkName]: { \"withdrawFeePercentage\": <number>, \"account\": <string>, \"enableLeavesWatcher\": <boolean>, }, ... } } Response Explanation withdrawFeePercentage : The minimum amount of percentage that the relayer requires to send a transaction on the client's behalf. account : The reward account of the relayer, which will collect the fee. enableLeavesWatcher : A boolean flag indicating if the relayer is able to provide a client with the leaves that make up the merkle tree of a particular mixer.","title":"Info"},{"location":"relayer/http-endpoints/#evm-mixer-leaves","text":"A client can query the relayer for the leaves (commitments) of a mixer deployment. This information is necessary for building the merkle tree on the client side, in order to build the proof of secrets for a particular commitment. The client can query the blockchain directly, but getting the information from a relayer will be much quicker. /api/v1/leaves/:contractAddress Response Format { \"leaves\": [ <hex-string>, <hex-string>, ... ] } Response explanation The leaves will be properly indexed in the array.","title":"EVM Mixer Leaves"},{"location":"relayer/overview/","text":"The Relayer offers the end-user privacy and receives fees from the users for providing this service. Relayers can be configured to listen to only the networks that they are interested in. Download the code and start supporting the network!","title":"Overview"},{"location":"relayer/websockets/","text":"The relayer is setup to receive WebSockets connections at the endpoint /ws . Clients can issue requests to the relayer by sending appropriately formatted data. Websockets Requests \u00b6 Send Transaction to EVM Network \u00b6 The most fundamental aspect of a relayer, is to send transactions on behalf of clients. relayWithdraw Data Formatting { evm: { [networkName]: { relayWithdraw: { contract: <string> proof: <string> root: <string> nullifierHash: <string> recipient: <string> relayer: <string> fee: <string> refund: <string> } } } } Field Explanations contract : The contract address to withdraw from proof : The client-side generated proof from secret values. The proof should be generated with appropriate relayer and fee values from the info query. root : The historical merkle root for which the proof was constructed. nullifierHash : The hash of one of the secret values, nullifier, for which the mixer can mark a commitment as spent. recipient : The address for which the funds (denomination - fee) will be sent. relayer : The address for which the fee will be sent. fee : The amount to provide to the relayer. refund : Should be '0' for native tokens, and equivalent to the denomination for ERC20 mixers.","title":"WebSockets"},{"location":"relayer/websockets/#websockets-requests","text":"","title":"Websockets Requests"},{"location":"relayer/websockets/#send-transaction-to-evm-network","text":"The most fundamental aspect of a relayer, is to send transactions on behalf of clients. relayWithdraw Data Formatting { evm: { [networkName]: { relayWithdraw: { contract: <string> proof: <string> root: <string> nullifierHash: <string> recipient: <string> relayer: <string> fee: <string> refund: <string> } } } } Field Explanations contract : The contract address to withdraw from proof : The client-side generated proof from secret values. The proof should be generated with appropriate relayer and fee values from the info query. root : The historical merkle root for which the proof was constructed. nullifierHash : The hash of one of the secret values, nullifier, for which the mixer can mark a commitment as spent. recipient : The address for which the funds (denomination - fee) will be sent. relayer : The address for which the fee will be sent. fee : The amount to provide to the relayer. refund : Should be '0' for native tokens, and equivalent to the denomination for ERC20 mixers.","title":"Send Transaction to EVM Network"}]}