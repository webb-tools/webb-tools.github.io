{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Webb \u00b6 Webb is an ecosystem of privacy protocols and products for a multi-chain world. In this site, you can find information about the protocols we are actively building out such as darkwebb , the open-source repos we maintain, and other privacy related research and ideas we aim to integrate into our community. Darkwebb Darkwebb Technical Roadmap For ways to contribute, join the discussion, or see active discussion of ideas and updates of this project, check out our Webb community forum that also features links to our Telegram, Discord, and more. Webb Community Forum Webb Tools Github Webb Community Telegram Webb Community Discord Philosophy & Ethos \u00b6 We believe that privacy is a fundamental human right and that this needs to extend into the blockchain space sooner rather than later. On blockchain platforms today, we continually expose our data when we participate in the myriad of protocols that exist in the multi-chain world. We move assets across chains to buy NFTs, pay our contributors and employees in cryptocurrency, invest w/ cryptocurrency, and generate large amounts of data that can be mined by anyone with an internet connection. Our mission is to change this by contributing to the growing amount of privacy tools that exist on blockchains today. We are motivated by cross-chain user behavior and want to tackle cross-chain privacy first. You can find more info about our cross-chain protocols in the Bridge Protocol section of the docs site. Where is privacy missing today \u00b6 Privacy is lacking in a variety of places in our current blockchain ecosystem. We don't have: 1. Privacy-preserving asset transfer across chains. 2. Privacy-preserving RPC infrastructure for users of protocols. 3. Privacy-preserving custody and exchanges w/ meaningful liquidity. The first item is what we are tackling with the darkwebb bridge protocol. It is an interoperable, zero-knowledge proof based cross-chain system for privately moving assets between blockchains. It is a Privacy-as-a-Service protocol that unifies assets under consistent, interoperable representations to scale privacy sets as large as possible. We are working on a fixed-sized deposit based system and plan to build out a fully shielded, interoperable protocol in the future. The second item is what we will tackle next first on top of the darkwebb bridge protocol. We aim to make privacy infrastructure easily deployable and easily usable by end products. When users of zero-knowledge-based, privacy protocols generate their zero-knowledge proofs, they need to possess private inputs. Oftentimes, retrieving the necessary private inputs requires querying public infrastructure, which exposes the user's privacy. The solution in theory is simple and harder in practice; we need to build private information retrieval systems for these datasets. As the darkwebb system launches and grows, we will begin integrating private information retrieval into our infrastructure. The third item is an active research area for our project. With a private bridge protocol, it becomes possible to build novel multi-party protocols on top. We are actively investigating building privacy-preserving decentralised exchanges over the darkwebb bridge. These protocols can leverage advances in multi-party computation to provide both novel custody solutions of shielded assets as well as dark-pool functionality over our darkwebb architecture. Contributing \u00b6 If any of the ideas laid out here are interesting, don't hesitate to reach out on our community channels or post interesting ideas/articles on our community forum. All constructive types of contributions are welcome!","title":"Home"},{"location":"#welcome-to-webb","text":"Webb is an ecosystem of privacy protocols and products for a multi-chain world. In this site, you can find information about the protocols we are actively building out such as darkwebb , the open-source repos we maintain, and other privacy related research and ideas we aim to integrate into our community. Darkwebb Darkwebb Technical Roadmap For ways to contribute, join the discussion, or see active discussion of ideas and updates of this project, check out our Webb community forum that also features links to our Telegram, Discord, and more. Webb Community Forum Webb Tools Github Webb Community Telegram Webb Community Discord","title":"Welcome to Webb"},{"location":"#philosophy-ethos","text":"We believe that privacy is a fundamental human right and that this needs to extend into the blockchain space sooner rather than later. On blockchain platforms today, we continually expose our data when we participate in the myriad of protocols that exist in the multi-chain world. We move assets across chains to buy NFTs, pay our contributors and employees in cryptocurrency, invest w/ cryptocurrency, and generate large amounts of data that can be mined by anyone with an internet connection. Our mission is to change this by contributing to the growing amount of privacy tools that exist on blockchains today. We are motivated by cross-chain user behavior and want to tackle cross-chain privacy first. You can find more info about our cross-chain protocols in the Bridge Protocol section of the docs site.","title":"Philosophy &amp; Ethos"},{"location":"#where-is-privacy-missing-today","text":"Privacy is lacking in a variety of places in our current blockchain ecosystem. We don't have: 1. Privacy-preserving asset transfer across chains. 2. Privacy-preserving RPC infrastructure for users of protocols. 3. Privacy-preserving custody and exchanges w/ meaningful liquidity. The first item is what we are tackling with the darkwebb bridge protocol. It is an interoperable, zero-knowledge proof based cross-chain system for privately moving assets between blockchains. It is a Privacy-as-a-Service protocol that unifies assets under consistent, interoperable representations to scale privacy sets as large as possible. We are working on a fixed-sized deposit based system and plan to build out a fully shielded, interoperable protocol in the future. The second item is what we will tackle next first on top of the darkwebb bridge protocol. We aim to make privacy infrastructure easily deployable and easily usable by end products. When users of zero-knowledge-based, privacy protocols generate their zero-knowledge proofs, they need to possess private inputs. Oftentimes, retrieving the necessary private inputs requires querying public infrastructure, which exposes the user's privacy. The solution in theory is simple and harder in practice; we need to build private information retrieval systems for these datasets. As the darkwebb system launches and grows, we will begin integrating private information retrieval into our infrastructure. The third item is an active research area for our project. With a private bridge protocol, it becomes possible to build novel multi-party protocols on top. We are actively investigating building privacy-preserving decentralised exchanges over the darkwebb bridge. These protocols can leverage advances in multi-party computation to provide both novel custody solutions of shielded assets as well as dark-pool functionality over our darkwebb architecture.","title":"Where is privacy missing today"},{"location":"#contributing","text":"If any of the ideas laid out here are interesting, don't hesitate to reach out on our community channels or post interesting ideas/articles on our community forum. All constructive types of contributions are welcome!","title":"Contributing"},{"location":"bridge-protocols/darkwebb/architecture/","text":"The darkwebb protocol architecture is modelled off the ChainBridge and Tornado Cash architectures. We merge and augment both protocols and increase the relayer responsibilities to design our private bridge protocol. The modifications can be summarized as: Augmenting Tornado's into Anchor's which additionally track an edge list to other Anchors. Anchors are private transaction systems that function both as Tornados but also as cross-chain bridges. Anchors use a zero-knowledge one-of-many merkle tree membership proof instead of one for a single merkle tree. Anchors can mint/burn the underlying token being deposited and withdrawn. Augmenting ChainBridge's Bridge into a private bridge protocol. We create a new AnchorHandler which modifiers the edge list of Anchors needing updates. We augment the Bridge relayers w/ a multi-party threshold signing scheme, so that one or many threshold networks can govern the bridge. Example diagram of the architecture and governance of cross chain private bridging of WEBB tokens on EVM chains: Definitions \u00b6 commitment \u00b6 A commitment is generated upon a users deposit into an anchor and later used in a ZK proof for withdrawal. The commitment is the PoseidonHash(DestinationChainID + nullifier + secret) . DestinationChainID is a user input indicating the chain they will withdraw on. neighborRoots \u00b6 Every LinkableAnchor stores its neighborRoots , a mapping containing the merkle roots of the anchors it is connected to. Each anchor stores a history of 30 roots, so users can verify against a historical root while new deposits occur. resourceID \u00b6 resourceID 's provide a chain agnostic identifier to connect tokens with the handlers and anchors that interact with that token. A resourceID for a given token and denomination is defined as the hash of that token name concatenated with its denomination. The resourceID for a token used in public bridging that is not tied to a denomination will simply be the hash of its token name. Main System Components \u00b6 Anchor \u00b6 Anchor s are augmented Tornado Cash Tornados that possess graph-like data structures and functionality; that is, they can be connected and have edges. Users interact with Anchors through a deposit/withdraw API. To deposit into a Webb Anchor, a user generates a hashed commitment and submits this to the Anchor's merkle tree for insertion. The commitment contains the chainID of the chain they wish to withdraw on as well as some secret data. Bridge \u00b6 The Bridge contract allows for both fixed denomination, private bridging and standard, public bridging of assets. The private bridging functionality uses an AnchorHandler to track the state of connected chains while the standard bridging uses an ERC20Handler . The Bridge's state is is maintained by a set of relayers through voting. These relayers vote to update the latest merkle roots of connected anchors in the case of private bridging, and to distribute bridged assets in the case of public bridging. AnchorHandler \u00b6 Every Bridge contract has a corresponding AnchorHandler to add or update the neighborRoots of the anchors on that chain after relayers pass and execute a proposals containing connected anchors' root updates. The Handler updates a specific anchor based on a mapping of a resourceID to a LinkableAnchor contract address which is set by the Bridge admin. ERC20Handler \u00b6 Every Bridge contract has a corresponding ERC20Handler to keep track of deposits on a connected bridge. This allows the user to bridge tokens publicly and a fixed denomination as seen in standard bridges. See Chainbridge's Documentation for more detail on this standard bridge architecture.","title":"Architecture"},{"location":"bridge-protocols/darkwebb/architecture/#definitions","text":"","title":"Definitions"},{"location":"bridge-protocols/darkwebb/architecture/#commitment","text":"A commitment is generated upon a users deposit into an anchor and later used in a ZK proof for withdrawal. The commitment is the PoseidonHash(DestinationChainID + nullifier + secret) . DestinationChainID is a user input indicating the chain they will withdraw on.","title":"commitment"},{"location":"bridge-protocols/darkwebb/architecture/#neighborroots","text":"Every LinkableAnchor stores its neighborRoots , a mapping containing the merkle roots of the anchors it is connected to. Each anchor stores a history of 30 roots, so users can verify against a historical root while new deposits occur.","title":"neighborRoots"},{"location":"bridge-protocols/darkwebb/architecture/#resourceid","text":"resourceID 's provide a chain agnostic identifier to connect tokens with the handlers and anchors that interact with that token. A resourceID for a given token and denomination is defined as the hash of that token name concatenated with its denomination. The resourceID for a token used in public bridging that is not tied to a denomination will simply be the hash of its token name.","title":"resourceID"},{"location":"bridge-protocols/darkwebb/architecture/#main-system-components","text":"","title":"Main System Components"},{"location":"bridge-protocols/darkwebb/architecture/#anchor","text":"Anchor s are augmented Tornado Cash Tornados that possess graph-like data structures and functionality; that is, they can be connected and have edges. Users interact with Anchors through a deposit/withdraw API. To deposit into a Webb Anchor, a user generates a hashed commitment and submits this to the Anchor's merkle tree for insertion. The commitment contains the chainID of the chain they wish to withdraw on as well as some secret data.","title":"Anchor"},{"location":"bridge-protocols/darkwebb/architecture/#bridge","text":"The Bridge contract allows for both fixed denomination, private bridging and standard, public bridging of assets. The private bridging functionality uses an AnchorHandler to track the state of connected chains while the standard bridging uses an ERC20Handler . The Bridge's state is is maintained by a set of relayers through voting. These relayers vote to update the latest merkle roots of connected anchors in the case of private bridging, and to distribute bridged assets in the case of public bridging.","title":"Bridge"},{"location":"bridge-protocols/darkwebb/architecture/#anchorhandler","text":"Every Bridge contract has a corresponding AnchorHandler to add or update the neighborRoots of the anchors on that chain after relayers pass and execute a proposals containing connected anchors' root updates. The Handler updates a specific anchor based on a mapping of a resourceID to a LinkableAnchor contract address which is set by the Bridge admin.","title":"AnchorHandler"},{"location":"bridge-protocols/darkwebb/architecture/#erc20handler","text":"Every Bridge contract has a corresponding ERC20Handler to keep track of deposits on a connected bridge. This allows the user to bridge tokens publicly and a fixed denomination as seen in standard bridges. See Chainbridge's Documentation for more detail on this standard bridge architecture.","title":"ERC20Handler"},{"location":"bridge-protocols/darkwebb/deployments/","text":"Anchor Deployments \u00b6 At the moment there are no live deployments of the anchors.","title":"Deployments"},{"location":"bridge-protocols/darkwebb/deployments/#anchor-deployments","text":"At the moment there are no live deployments of the anchors.","title":"Anchor Deployments"},{"location":"bridge-protocols/darkwebb/governance/","text":"Governance \u00b6 Governance on darkwebb is key to maintaining and increasing the functionality of the protocol for WEBB tokenholders, protocol users, and relayers. Possible governance actions and their corresponding locations are as follows. WEBB Token Governance \u00b6 The WEBB token is used to govern various parts of the darkwebb deployments. The WEBB token has its own set of bridges for various sizes of deposits that enables holders to move their tokens between supported chains. Anytime a new chain is added to the Webb Network, a corresponding bridge and WEBB token will instantiated for future governance usage. WEBB Governance Proposal Types \u00b6 WEBB tokens will be used to vote on proposals including but not limited to: deploying new anchor contracts, connecting anchors to handlers, connecting handlers to bridges, and whitelisting wrappable assets (see Wrapper Governance Functionality for details). The first three parts of the previous list are all essential to the deployment of new anchors and invoke WEBB token holders to govern these processes using WEBB on the deployed anchor's native chain. The whitelisting of wrappable assets will also take place on the chain where the token wrapper has been deployed. Anchor Deployment on a New Chain Using Governor Bravo \u00b6 In advance, the Webb community will deploy the WEBB token, Gov Bravo, Bridge, Handlers, and AnchorFactory on chains desireable for later anchor deployment. The Bridge will be connected to the ERC20Handler to enable public, standard bridging of WEBB. WEBB holders bridge their existing WEBB to the new chain. WEBB holders vote and execute a proposal to connect the Bridge and Handler calling the Bridge's setResourceID() . WEBB holders vote and execute a proposal to deploy a new anchor using the AnchorFactory. WEBB holders vote and execute a proposal to set the Handler of the newly deployed anchor. The anchor now enables private, cross-chain bridging.","title":"Governance"},{"location":"bridge-protocols/darkwebb/governance/#governance","text":"Governance on darkwebb is key to maintaining and increasing the functionality of the protocol for WEBB tokenholders, protocol users, and relayers. Possible governance actions and their corresponding locations are as follows.","title":"Governance"},{"location":"bridge-protocols/darkwebb/governance/#webb-token-governance","text":"The WEBB token is used to govern various parts of the darkwebb deployments. The WEBB token has its own set of bridges for various sizes of deposits that enables holders to move their tokens between supported chains. Anytime a new chain is added to the Webb Network, a corresponding bridge and WEBB token will instantiated for future governance usage.","title":"WEBB Token Governance"},{"location":"bridge-protocols/darkwebb/governance/#webb-governance-proposal-types","text":"WEBB tokens will be used to vote on proposals including but not limited to: deploying new anchor contracts, connecting anchors to handlers, connecting handlers to bridges, and whitelisting wrappable assets (see Wrapper Governance Functionality for details). The first three parts of the previous list are all essential to the deployment of new anchors and invoke WEBB token holders to govern these processes using WEBB on the deployed anchor's native chain. The whitelisting of wrappable assets will also take place on the chain where the token wrapper has been deployed.","title":"WEBB Governance Proposal Types"},{"location":"bridge-protocols/darkwebb/governance/#anchor-deployment-on-a-new-chain-using-governor-bravo","text":"In advance, the Webb community will deploy the WEBB token, Gov Bravo, Bridge, Handlers, and AnchorFactory on chains desireable for later anchor deployment. The Bridge will be connected to the ERC20Handler to enable public, standard bridging of WEBB. WEBB holders bridge their existing WEBB to the new chain. WEBB holders vote and execute a proposal to connect the Bridge and Handler calling the Bridge's setResourceID() . WEBB holders vote and execute a proposal to deploy a new anchor using the AnchorFactory. WEBB holders vote and execute a proposal to set the Handler of the newly deployed anchor. The anchor now enables private, cross-chain bridging.","title":"Anchor Deployment on a New Chain Using Governor Bravo"},{"location":"bridge-protocols/darkwebb/overview/","text":"darkwebb Protocol \u00b6 The darkwebb protocol is a private bridge protocol building on top of the chainbridge and Tornado cash protocols. It combines these architectures to create an interoperable privacy set to enable cross-chain private transactions with scalable privacy. More tokens on a particular darkwebb bridge and more chains connected on a particular darkwebb bridge only serve to increase the amount of privacy provided by that particular bridge. Bridge Functionality - Roadmap \u00b6 A privacy bridge provides a novel primitive for constructing private applications on top. While we consider a private bridge protocol for asset transfers below, we can also consider generalizations of this to build interoperable and private applications. The buildout of non-financial components of the protocol are not roadmapped but may be worked on in the future, at hackathons, and more. We aim to build out a private bridge protocol for asset transfers in stages, starting with the most primitive use case of transferring and targetting extensions that compose nicely with existing DeFi primitives such as yield aggregators and lending solutions. Version 1 - Shared privacy bridge functionality \u00b6 The first functionality of the protocol is cross-chain, private bridging of Webb wrapped assets. The goal here is to simply provide a protocol for wrapping a base, origin asset into a Webb wrapped asset that can be transferred privately across chains. Version 1.X - Governance functionality \u00b6 The second functionality of the protocol is to integrate governance functionality to allow Webb tokenholders to govern the set of whitelisted origin assets that can be wrapped into a particular bridge's Webb wrapped asset. This is motivated primarily by the ability to scale privacy sets across tokens by aggregating and unifying similar liquidity under a common representation, e.g. the particular Webb wrapped asset. Version 2 - Stable Swap bridges \u00b6 With basic functionality and governance in tact, we can create a cross-chain stable swapping pool. We aim to go live with this architecture after the previous versions are built out. Version 3 - Yield Delegation \u00b6 With an expressive infrastructure in tact, we can continue to expand the scope of what's possible with these interoperable, privacy sets. This bridge protocol allows users to earn yield while contributing to a compatible yield-bearing privacy set. The goal here is to lend out the underlying liquidity to DeFi protocols on each side of the bridge, taking on more risk and also earning more yield in the form of other DeFi assets. Relayer Functionality - Roadmap \u00b6 Bridges are networked applications that span multiple blockchains and must be aware of events and/or state occurring across this network. The endponts of these bridges (e.g. the smart contracts / core protocol logic) are denoted Anchors in our system. These Anchors are required by definition to know about various parts of the state of other anchors, particularly the ones they're connected to across a particular bridge. The backbone of any bridge is made up of the relayers -- otherwise denomted validators, relayers, authorities, nodes, etc. -- that maintain the liveliness of the bridge protocol. Relayers, as their name entails, relay information for a connected set of Anchors on a bridge. This information is then used to update the state of each Anchor and allow applications to reference, both privately and potentially not, properties of data stored across the other connected Anchors. We aim to build a relayer infrastructure that gradually improves in its performance, efficiency, and overall security. We do this in stages by first building the necessary infrastructure to listen to events across a connected set of Anchors and react properly across a Bridge to preserve the liveness of the protocol. Version 1 - Multi-sig governance functionality \u00b6 The first iteration of the bridge relayer is responsible for event listening and transaction execution. - Event listening across a set of connected anchors to learn of new deposits on a Bridge. - Proposal creation and vote submission over the Bridge's governance process. - Data replication and an API for inspecting Anchor state off-chain. Version 2 - Multi-party Threshold governance functionality \u00b6 We then plan to integrate a DKG into a Substrate node for future governance purposes. - Direct integration into a (currently) Substrate chain or potentially other blockchain node (Cosmos-SDK) - Bootstraps off existing validator set and participates in consensus. - Execution of a distributed key generation protocol to generate a threshold key. Version 3 - Auxiliary staking and punishment functionality \u00b6 We will integrate the DKG directly into the Bridge governance system, allowing the bridge to be governed by a threshold key (or many). - Integrate staking mechanism over finality authorities for registering local key matter. - Integrate punishment mechanism over improper behavior in the DKG. - Develop an on-chain pallet to govern the threshold and generate threshold signatures of Bridge.sol governance transactions.","title":"Overview"},{"location":"bridge-protocols/darkwebb/overview/#darkwebb-protocol","text":"The darkwebb protocol is a private bridge protocol building on top of the chainbridge and Tornado cash protocols. It combines these architectures to create an interoperable privacy set to enable cross-chain private transactions with scalable privacy. More tokens on a particular darkwebb bridge and more chains connected on a particular darkwebb bridge only serve to increase the amount of privacy provided by that particular bridge.","title":"darkwebb Protocol"},{"location":"bridge-protocols/darkwebb/overview/#bridge-functionality-roadmap","text":"A privacy bridge provides a novel primitive for constructing private applications on top. While we consider a private bridge protocol for asset transfers below, we can also consider generalizations of this to build interoperable and private applications. The buildout of non-financial components of the protocol are not roadmapped but may be worked on in the future, at hackathons, and more. We aim to build out a private bridge protocol for asset transfers in stages, starting with the most primitive use case of transferring and targetting extensions that compose nicely with existing DeFi primitives such as yield aggregators and lending solutions.","title":"Bridge Functionality - Roadmap"},{"location":"bridge-protocols/darkwebb/overview/#version-1-shared-privacy-bridge-functionality","text":"The first functionality of the protocol is cross-chain, private bridging of Webb wrapped assets. The goal here is to simply provide a protocol for wrapping a base, origin asset into a Webb wrapped asset that can be transferred privately across chains.","title":"Version 1 - Shared privacy bridge functionality"},{"location":"bridge-protocols/darkwebb/overview/#version-1x-governance-functionality","text":"The second functionality of the protocol is to integrate governance functionality to allow Webb tokenholders to govern the set of whitelisted origin assets that can be wrapped into a particular bridge's Webb wrapped asset. This is motivated primarily by the ability to scale privacy sets across tokens by aggregating and unifying similar liquidity under a common representation, e.g. the particular Webb wrapped asset.","title":"Version 1.X - Governance functionality"},{"location":"bridge-protocols/darkwebb/overview/#version-2-stable-swap-bridges","text":"With basic functionality and governance in tact, we can create a cross-chain stable swapping pool. We aim to go live with this architecture after the previous versions are built out.","title":"Version 2 - Stable Swap bridges"},{"location":"bridge-protocols/darkwebb/overview/#version-3-yield-delegation","text":"With an expressive infrastructure in tact, we can continue to expand the scope of what's possible with these interoperable, privacy sets. This bridge protocol allows users to earn yield while contributing to a compatible yield-bearing privacy set. The goal here is to lend out the underlying liquidity to DeFi protocols on each side of the bridge, taking on more risk and also earning more yield in the form of other DeFi assets.","title":"Version 3 - Yield Delegation"},{"location":"bridge-protocols/darkwebb/overview/#relayer-functionality-roadmap","text":"Bridges are networked applications that span multiple blockchains and must be aware of events and/or state occurring across this network. The endponts of these bridges (e.g. the smart contracts / core protocol logic) are denoted Anchors in our system. These Anchors are required by definition to know about various parts of the state of other anchors, particularly the ones they're connected to across a particular bridge. The backbone of any bridge is made up of the relayers -- otherwise denomted validators, relayers, authorities, nodes, etc. -- that maintain the liveliness of the bridge protocol. Relayers, as their name entails, relay information for a connected set of Anchors on a bridge. This information is then used to update the state of each Anchor and allow applications to reference, both privately and potentially not, properties of data stored across the other connected Anchors. We aim to build a relayer infrastructure that gradually improves in its performance, efficiency, and overall security. We do this in stages by first building the necessary infrastructure to listen to events across a connected set of Anchors and react properly across a Bridge to preserve the liveness of the protocol.","title":"Relayer Functionality - Roadmap"},{"location":"bridge-protocols/darkwebb/overview/#version-1-multi-sig-governance-functionality","text":"The first iteration of the bridge relayer is responsible for event listening and transaction execution. - Event listening across a set of connected anchors to learn of new deposits on a Bridge. - Proposal creation and vote submission over the Bridge's governance process. - Data replication and an API for inspecting Anchor state off-chain.","title":"Version 1 - Multi-sig governance functionality"},{"location":"bridge-protocols/darkwebb/overview/#version-2-multi-party-threshold-governance-functionality","text":"We then plan to integrate a DKG into a Substrate node for future governance purposes. - Direct integration into a (currently) Substrate chain or potentially other blockchain node (Cosmos-SDK) - Bootstraps off existing validator set and participates in consensus. - Execution of a distributed key generation protocol to generate a threshold key.","title":"Version 2 - Multi-party Threshold governance functionality"},{"location":"bridge-protocols/darkwebb/overview/#version-3-auxiliary-staking-and-punishment-functionality","text":"We will integrate the DKG directly into the Bridge governance system, allowing the bridge to be governed by a threshold key (or many). - Integrate staking mechanism over finality authorities for registering local key matter. - Integrate punishment mechanism over improper behavior in the DKG. - Develop an on-chain pallet to govern the threshold and generate threshold signatures of Bridge.sol governance transactions.","title":"Version 3 - Auxiliary staking and punishment functionality"},{"location":"bridge-protocols/darkwebb/technical-roadmap/","text":"Technical Roadmap \u00b6 Overview \u00b6 The (currently named darkwebb ) protocol is the first protocol built by Webb Technologies. It is a non-custodial private bridge protocol that uses smart contracts to bootstrap a zero-knowledge bridge. It is designed to work in all possible smart contracting environments. The current working repos for this protocol are targeting the EVM & Rust based chains such as Substrate. https://github.com/webb-tools/darkwebb-solidity https://github.com/webb-tools/darkwebb-substrate Goals \u00b6 The goals for the protocol are to grow into a trustless, private bridge overlying existing cross-chain communication protocols such as Polkadot's XCMP, Cosmos's IBC, or Celo's Optics. We will use the following checklist to track network deployments. [ ] Ethereum - as a smart contract [ ] Polkadot - as a smart contract or parachain [ ] Kusama - as a smart contract or parachain [ ] Harmony - as a smart contract or comsos-sdk chain [ ] Edgeware - as a smart contract or pallet [ ] Cosmos - as a smart contract or cosmos-sdk chain [ ] Celo - as a smart contract [ ] Polygon - as a smart contract [ ] Solana - as a smart contract Protocol Implementations \u00b6 We will use the following checklist to track protocol implementations [ ] Solidity [ ] Rust [ ] Golang [ ] Leo [ ] Cairo [ ] Ink! Objectives - Q3 2021 \u00b6 A test EVM bridge deployment can be made between Ethereum, Edgeware, and Harmony's test networks. Networks with instability will be exchanged or removed from the bridge if needed. In order to do so we need: [ ] darkwebb-solidity v1 protocol [ ] relayer v2 w/ darkwebb protocol support [ ] darkwebb-substrate v1 protocol [ ] Upon completion of first two milestones, deploy a small capped bridge at $10,000 approximate value on each side. darkwebb-solidity v1 \u00b6 Necessary items before deploying the bridge [ ] Add governable wrapping limit, denote by LimitedGovernedTokenWrapper . [ ] Integration tests on a single chain [ ] Deploy 2 bridges, 2 comp tokens, 2 anchors, 2 governor bravos on the same chain [ ] Case 1: Repeat steps 2-5 for each bridge: Deploy GovernedTokenWrapper1, GovernedTokenWrapper2 Deploy a mock Token Add Token . address to GovernedTokenWrapper1 . tokens Deploy LinkableERC20Anchor with GovernedTokenWrapper1 as the ERC20. Deposit Create a note that commits to withdraw on the bridge that was not deposited into. Deposit x tokens into one bridge, record the note . Deposit T more random notes into both sides of the bridge. Withdraw Generate the zero-knowledge proof for withdrawal Collect roots of each anchor Collect merkle membership proof for anchor deposited into Generate witness . Submit witness to the anchor on the \"other side of the bridge\". Submit tx w/ proof to the destination bridge. Mint tokens if no available liquidity is in the locked_pool . Verify balance updates in each respective token. Unwrap Deploy a mock UnwrappingToken . Add UnwrappingToken . address to GovernedTokenWrapper2 . tokens relayer v1 \u00b6 Relayer v2 is geared towards including chainbridge governance functionality. This means functionality for voting, closing, and executing proposals to update edges on the bridge. We want to test this with a sufficient relayer network and proposal passing threshold. [ ] Deploy relayer v1 to test networks: Rinkeby, Harmony Shard 1, Edgeware Beresheet. Chainbridge governance: [ ] Listen to events on both bridges. On receive event, pass to state machine and return a transaction / call State machine should update inner state and remove transactions that get executed by other relayers. If transaction, add to a queue. If call, execute. Pull from queue using a random number generator with a TBD distribution. If transaction. execute. [ ] Define strategy builder class for building voting strategies. Use a state machine and local storage Strategies for honest and greedy execution. Transaction Relayer [ ] Integration tests on all chains participating on the bridge [ ] Deployment as described above in darkwebb-solidity v1 . [ ] Case 1: Relayer actions are executed in intervals of k seconds Expose an api: /api/v2/relay for clients to relay TXes through. On received TX, Verify & validate it natively. Store in a queue . Every k seconds, pull a batch of TXes from the queue . Submit them to the chain. darkwebb-substrate v1 \u00b6 The Substrate implementation of the protocol should follow from darkwebb-solidity . [ ] Integrate chainbridge-substrate to the repo. [ ] Develop Anchor pallet. Bridge gadget using circom-compatible Poseidon . Graph functionality with access-control for Bridge/Handler pallet. Ability to add edge if called by governor/bridge Ability to update edge if called by governor/bridge [ ] Integration of chainbridge-substrate w/ Anchor pallet tests [ ] Define two Anchor pallets and two chainbridge-substrate bridges. Ensure this can be done with the architecture (e.g. using instances) [ ] Full integration tests with relayer v3 . Objectives - Q4 2021 \u00b6 A test Substrate \u2190 \u2192 EVM bridge deployment can be made between Ethereum, Edgeware (Frontier), and Substrate networks like Kusama, Polkadot. For this to be possible, we need to extend relayer functionality to support Substrate's chainbridge governance and serve as an oracle over the merkle roots of our protocol's merkle trees. [ ] relayer v2-3 w/ chainbridge-substrate governance & bridge tx relayer for Substrate [ ] darkwebb-substrate v2 protocol [ ] dkg-gadget v1 protocol relayer v2 - v3 \u00b6 Once darkwebb-substrate v1 is built we can begin building the integration into the relayer v2 . This means integrating chainbridge-substrate governance and transaction relaying system for bridge transactions on Substrate networks into the service. darkwebb-substrate v1.X \u00b6 We want to position the Substrate side of the network to provide various privacy services that augment the functionality of the bridge and complete useful revenue generating tasks. These tasks can range in the future from various distributed custody, social key recovery, and private information retrieval services. [ ] Integrate relayer v2 into the darkwebb-substrate service.rs . [ ] Develop Relayer Election pallet [ ] Proof of Authority system at genesis [ ] Proof of stake elected system at first upgrade [ ] Relayers register w/ necessary metadata Reward address IP / IPFS multihash / P2P node address / validator keys [ ] Develop DKG pallet. [ ] Store necessary metadata in pallet storage. darkwebb-substrate/dkg-gadget v1 \u00b6 A DKG for Webb can become a critical piece of our scalability and network value. We initially are motivated by using a DKG protocol to generate a threshold keypair that can be used to govern the anchor deployments. [ ] Design gossip protocol for running the DKG. [ ] Integrate DKG as separate p2p worker running alongside consensus mechanism. [ ] Add support for multiple DKGs if reasonable (depending on ability to generalise). [ ] Add functionality for: [ ] Signing ETH transactions for chainbridge-solidity governance. [ ] Signing Substrate transactions for chainbridge-substrate governance. Objectives - Q1 2022 \u00b6 Launching of parachains & live (capped) deployments for various tokens in the ecosystem: [ ] Deployments: [ ] Stablecoin sets: USDC / DAI [ ] BTC sets: WBTC / TBTC / InterBTC [ ] zk-gadgets - PLONK gadgets, updating setup, and dynamically configurable bridge. [ ] darkwebb v2 protocol implementation in Solidity and Substrate/Rust. deployments \u00b6 Deployments to various networks should occur with a limited initial liquidity. Initial liquidity providers will govern the limit thereafter. zk-gadgets \u00b6 PLONK for the circom circuits. Other updatable setups for arkworks circuits (whether Marlin works or PLONK needs to be built). darkwebb-solidity / darkwebb-substrate v2 \u00b6 V2 comes with an upgrade to our zero-knowledge infrastructure by integrating PLONK as the targetted prover/verifier. We mainly want to work with updatable setups to build an updatable and dynamic bridge. Additionally, we want to research and plan for a way to tackle a variable deposit, interoperable shielded pool, which will likely depend on Halo2 or similarly recursive proving schemes.","title":"Technical Roadmap"},{"location":"bridge-protocols/darkwebb/technical-roadmap/#technical-roadmap","text":"","title":"Technical Roadmap"},{"location":"bridge-protocols/darkwebb/technical-roadmap/#overview","text":"The (currently named darkwebb ) protocol is the first protocol built by Webb Technologies. It is a non-custodial private bridge protocol that uses smart contracts to bootstrap a zero-knowledge bridge. It is designed to work in all possible smart contracting environments. The current working repos for this protocol are targeting the EVM & Rust based chains such as Substrate. https://github.com/webb-tools/darkwebb-solidity https://github.com/webb-tools/darkwebb-substrate","title":"Overview"},{"location":"bridge-protocols/darkwebb/technical-roadmap/#goals","text":"The goals for the protocol are to grow into a trustless, private bridge overlying existing cross-chain communication protocols such as Polkadot's XCMP, Cosmos's IBC, or Celo's Optics. We will use the following checklist to track network deployments. [ ] Ethereum - as a smart contract [ ] Polkadot - as a smart contract or parachain [ ] Kusama - as a smart contract or parachain [ ] Harmony - as a smart contract or comsos-sdk chain [ ] Edgeware - as a smart contract or pallet [ ] Cosmos - as a smart contract or cosmos-sdk chain [ ] Celo - as a smart contract [ ] Polygon - as a smart contract [ ] Solana - as a smart contract","title":"Goals"},{"location":"bridge-protocols/darkwebb/technical-roadmap/#protocol-implementations","text":"We will use the following checklist to track protocol implementations [ ] Solidity [ ] Rust [ ] Golang [ ] Leo [ ] Cairo [ ] Ink!","title":"Protocol Implementations"},{"location":"bridge-protocols/darkwebb/technical-roadmap/#objectives-q3-2021","text":"A test EVM bridge deployment can be made between Ethereum, Edgeware, and Harmony's test networks. Networks with instability will be exchanged or removed from the bridge if needed. In order to do so we need: [ ] darkwebb-solidity v1 protocol [ ] relayer v2 w/ darkwebb protocol support [ ] darkwebb-substrate v1 protocol [ ] Upon completion of first two milestones, deploy a small capped bridge at $10,000 approximate value on each side.","title":"Objectives - Q3 2021"},{"location":"bridge-protocols/darkwebb/technical-roadmap/#darkwebb-solidity-v1","text":"Necessary items before deploying the bridge [ ] Add governable wrapping limit, denote by LimitedGovernedTokenWrapper . [ ] Integration tests on a single chain [ ] Deploy 2 bridges, 2 comp tokens, 2 anchors, 2 governor bravos on the same chain [ ] Case 1: Repeat steps 2-5 for each bridge: Deploy GovernedTokenWrapper1, GovernedTokenWrapper2 Deploy a mock Token Add Token . address to GovernedTokenWrapper1 . tokens Deploy LinkableERC20Anchor with GovernedTokenWrapper1 as the ERC20. Deposit Create a note that commits to withdraw on the bridge that was not deposited into. Deposit x tokens into one bridge, record the note . Deposit T more random notes into both sides of the bridge. Withdraw Generate the zero-knowledge proof for withdrawal Collect roots of each anchor Collect merkle membership proof for anchor deposited into Generate witness . Submit witness to the anchor on the \"other side of the bridge\". Submit tx w/ proof to the destination bridge. Mint tokens if no available liquidity is in the locked_pool . Verify balance updates in each respective token. Unwrap Deploy a mock UnwrappingToken . Add UnwrappingToken . address to GovernedTokenWrapper2 . tokens","title":"darkwebb-solidity v1"},{"location":"bridge-protocols/darkwebb/technical-roadmap/#relayer-v1","text":"Relayer v2 is geared towards including chainbridge governance functionality. This means functionality for voting, closing, and executing proposals to update edges on the bridge. We want to test this with a sufficient relayer network and proposal passing threshold. [ ] Deploy relayer v1 to test networks: Rinkeby, Harmony Shard 1, Edgeware Beresheet. Chainbridge governance: [ ] Listen to events on both bridges. On receive event, pass to state machine and return a transaction / call State machine should update inner state and remove transactions that get executed by other relayers. If transaction, add to a queue. If call, execute. Pull from queue using a random number generator with a TBD distribution. If transaction. execute. [ ] Define strategy builder class for building voting strategies. Use a state machine and local storage Strategies for honest and greedy execution. Transaction Relayer [ ] Integration tests on all chains participating on the bridge [ ] Deployment as described above in darkwebb-solidity v1 . [ ] Case 1: Relayer actions are executed in intervals of k seconds Expose an api: /api/v2/relay for clients to relay TXes through. On received TX, Verify & validate it natively. Store in a queue . Every k seconds, pull a batch of TXes from the queue . Submit them to the chain.","title":"relayer v1"},{"location":"bridge-protocols/darkwebb/technical-roadmap/#darkwebb-substrate-v1","text":"The Substrate implementation of the protocol should follow from darkwebb-solidity . [ ] Integrate chainbridge-substrate to the repo. [ ] Develop Anchor pallet. Bridge gadget using circom-compatible Poseidon . Graph functionality with access-control for Bridge/Handler pallet. Ability to add edge if called by governor/bridge Ability to update edge if called by governor/bridge [ ] Integration of chainbridge-substrate w/ Anchor pallet tests [ ] Define two Anchor pallets and two chainbridge-substrate bridges. Ensure this can be done with the architecture (e.g. using instances) [ ] Full integration tests with relayer v3 .","title":"darkwebb-substrate v1"},{"location":"bridge-protocols/darkwebb/technical-roadmap/#objectives-q4-2021","text":"A test Substrate \u2190 \u2192 EVM bridge deployment can be made between Ethereum, Edgeware (Frontier), and Substrate networks like Kusama, Polkadot. For this to be possible, we need to extend relayer functionality to support Substrate's chainbridge governance and serve as an oracle over the merkle roots of our protocol's merkle trees. [ ] relayer v2-3 w/ chainbridge-substrate governance & bridge tx relayer for Substrate [ ] darkwebb-substrate v2 protocol [ ] dkg-gadget v1 protocol","title":"Objectives - Q4 2021"},{"location":"bridge-protocols/darkwebb/technical-roadmap/#relayer-v2-v3","text":"Once darkwebb-substrate v1 is built we can begin building the integration into the relayer v2 . This means integrating chainbridge-substrate governance and transaction relaying system for bridge transactions on Substrate networks into the service.","title":"relayer v2 - v3"},{"location":"bridge-protocols/darkwebb/technical-roadmap/#darkwebb-substrate-v1x","text":"We want to position the Substrate side of the network to provide various privacy services that augment the functionality of the bridge and complete useful revenue generating tasks. These tasks can range in the future from various distributed custody, social key recovery, and private information retrieval services. [ ] Integrate relayer v2 into the darkwebb-substrate service.rs . [ ] Develop Relayer Election pallet [ ] Proof of Authority system at genesis [ ] Proof of stake elected system at first upgrade [ ] Relayers register w/ necessary metadata Reward address IP / IPFS multihash / P2P node address / validator keys [ ] Develop DKG pallet. [ ] Store necessary metadata in pallet storage.","title":"darkwebb-substrate v1.X"},{"location":"bridge-protocols/darkwebb/technical-roadmap/#darkwebb-substratedkg-gadget-v1","text":"A DKG for Webb can become a critical piece of our scalability and network value. We initially are motivated by using a DKG protocol to generate a threshold keypair that can be used to govern the anchor deployments. [ ] Design gossip protocol for running the DKG. [ ] Integrate DKG as separate p2p worker running alongside consensus mechanism. [ ] Add support for multiple DKGs if reasonable (depending on ability to generalise). [ ] Add functionality for: [ ] Signing ETH transactions for chainbridge-solidity governance. [ ] Signing Substrate transactions for chainbridge-substrate governance.","title":"darkwebb-substrate/dkg-gadget v1"},{"location":"bridge-protocols/darkwebb/technical-roadmap/#objectives-q1-2022","text":"Launching of parachains & live (capped) deployments for various tokens in the ecosystem: [ ] Deployments: [ ] Stablecoin sets: USDC / DAI [ ] BTC sets: WBTC / TBTC / InterBTC [ ] zk-gadgets - PLONK gadgets, updating setup, and dynamically configurable bridge. [ ] darkwebb v2 protocol implementation in Solidity and Substrate/Rust.","title":"Objectives - Q1 2022"},{"location":"bridge-protocols/darkwebb/technical-roadmap/#deployments","text":"Deployments to various networks should occur with a limited initial liquidity. Initial liquidity providers will govern the limit thereafter.","title":"deployments"},{"location":"bridge-protocols/darkwebb/technical-roadmap/#zk-gadgets","text":"PLONK for the circom circuits. Other updatable setups for arkworks circuits (whether Marlin works or PLONK needs to be built).","title":"zk-gadgets"},{"location":"bridge-protocols/darkwebb/technical-roadmap/#darkwebb-solidity-darkwebb-substrate-v2","text":"V2 comes with an upgrade to our zero-knowledge infrastructure by integrating PLONK as the targetted prover/verifier. We mainly want to work with updatable setups to build an updatable and dynamic bridge. Additionally, we want to research and plan for a way to tackle a variable deposit, interoperable shielded pool, which will likely depend on Halo2 or similarly recursive proving schemes.","title":"darkwebb-solidity / darkwebb-substrate v2"},{"location":"bridge-protocols/darkwebb/contracts/Anchor2/","text":"Anchor2.sol \u00b6 Implementation Description \u00b6 A contract that implements the appropriate remaining functions for processing deposits and withdrawals for an AnchorBase2.sol . This contract inherits all the methods of the base LinkableAnchor2.sol and AnchorBase2.sol contracts. Variables \u00b6 token \u00b6 Type: public immutable token Constructor \u00b6 Details Signature constructor( IVerifier _verifier, IPoseidonT3 _hasher, uint256 _denomination, uint32 _merkleTreeHeight, uint32 _chainID, ITokenWrapper _token, address _bridge, address _admin, address _handler ) LinkableAnchor2(_verifier, _hasher, _denomination, _merkleTreeHeight, _chainID, _bridge, _admin, _handler) Internal Functions \u00b6 Calls to deposits require a commitment, which is a hash of some secret values. _processDeposit \u00b6 Details Signature _processDeposit() Requires require(msg.value == 0, \"ETH value is supposed to be 0 for ERC20 instance\") _processWithdraw \u00b6 Details Signature _processWithdraw( address payable _recipient, address payable _relayer, uint256 _fee, uint256 _refund ) Requires require(msg.value == _refund, \"Incorrect refund amount received by the contract\")","title":"Anchor2"},{"location":"bridge-protocols/darkwebb/contracts/Anchor2/#anchor2sol","text":"Implementation","title":"Anchor2.sol"},{"location":"bridge-protocols/darkwebb/contracts/Anchor2/#description","text":"A contract that implements the appropriate remaining functions for processing deposits and withdrawals for an AnchorBase2.sol . This contract inherits all the methods of the base LinkableAnchor2.sol and AnchorBase2.sol contracts.","title":"Description"},{"location":"bridge-protocols/darkwebb/contracts/Anchor2/#variables","text":"","title":"Variables"},{"location":"bridge-protocols/darkwebb/contracts/Anchor2/#token","text":"Type: public immutable token","title":"token"},{"location":"bridge-protocols/darkwebb/contracts/Anchor2/#constructor","text":"Details Signature constructor( IVerifier _verifier, IPoseidonT3 _hasher, uint256 _denomination, uint32 _merkleTreeHeight, uint32 _chainID, ITokenWrapper _token, address _bridge, address _admin, address _handler ) LinkableAnchor2(_verifier, _hasher, _denomination, _merkleTreeHeight, _chainID, _bridge, _admin, _handler)","title":"Constructor"},{"location":"bridge-protocols/darkwebb/contracts/Anchor2/#internal-functions","text":"Calls to deposits require a commitment, which is a hash of some secret values.","title":"Internal Functions"},{"location":"bridge-protocols/darkwebb/contracts/Anchor2/#_processdeposit","text":"Details Signature _processDeposit() Requires require(msg.value == 0, \"ETH value is supposed to be 0 for ERC20 instance\")","title":"_processDeposit"},{"location":"bridge-protocols/darkwebb/contracts/Anchor2/#_processwithdraw","text":"Details Signature _processWithdraw( address payable _recipient, address payable _relayer, uint256 _fee, uint256 _refund ) Requires require(msg.value == _refund, \"Incorrect refund amount received by the contract\")","title":"_processWithdraw"},{"location":"bridge-protocols/darkwebb/contracts/AnchorBase2/","text":"AnchorBase2.sol \u00b6 Implementation Description \u00b6 An abstract contract that requires child classes to implement appropriate verification and processes for deposits and withdrawals. Variables \u00b6 bridge \u00b6 Type: public address admin \u00b6 Type: public address handler \u00b6 Type: public address verifier \u00b6 Type: public immutable IVerifier denomination \u00b6 Type: public immutable uint256 chainID \u00b6 Type: public immutable uint256 nullifierHashes \u00b6 Type: public mapping(bytes32 => bool) commitments \u00b6 Type: public mapping(bytes32 => bool) Edge \u00b6 Type: struct Edge { uint256 chainID; bytes32 root; uint256 height; } edgeIndex \u00b6 Type: mapping(uint256 => uint256) edgeExistsForChain \u00b6 Type: public mapping(uint256 => bool) edgeList \u00b6 Type: public Edge[] neighborRoots \u00b6 Type: public mapping(uint256 => mapping(uint32 => bytes32)) currentNeighborRootIndex \u00b6 Type: public mapping(uint256 => uint32) Constructor \u00b6 Details Signature constructor( IVerifier _verifier, IHasher _hasher, uint256 _denomination, uint32 _merkleTreeHeight, uint256 _chainID ) MerkleTreePoseidon(_merkleTreeHeight, _hasher) External Functions \u00b6 Calls to deposits require a commitment, which is a hash of some secret values. deposit \u00b6 Details Signature deposit(bytes32 _commitment) Requires require(..., \"commitment has been submitted\") Emits Deposit withdraw \u00b6 Details Signature withdraw( bytes calldata _proof, bytes calldata _roots, bytes32 _nullifierHash, address payable _recipient, address payable _relayer, uint256 _fee, uint256 _refund ) Requires require(_fee <= denomination) require(..., \"The note has already been spent\") require(..., \"Cannot find your merkle root\") require(..., \"Incorrect root array length\") require(..., \"Neighbor root not found\") require(..., \"Invalid withdraw proof\") Emits Withdraw View Functions \u00b6 isSpent \u00b6 Details Signature isSpent(bytes32 _nullifierHash) public view returns (bool) isSpentArray \u00b6 Details Signature isSpentArray(bytes32[] calldata _nullifierHashes) external view returns (bool[] memory spent) getLatestNeighborRoots \u00b6 Details Signature getLatestNeighborRoots() public view returns (bytes32[1] memory roots) isKnownNeighborRoot \u00b6 Details Signature isKnownNeighborRoot(uint256 neighborChainID, bytes32 _root) public view returns (bool) Events \u00b6 Deposit \u00b6 Signature : Deposit(bytes32 indexed commitment, uint32 leafIndex, uint256 timestamp) Withdraw \u00b6 Signature : Withdrawal(address to, bytes32 nullifierHash, address indexed relayer, uint256 fee) EdgeAddition \u00b6 Signature : EdgeAddition(uint256 chainID, uint256 height, bytes32 merkleRoot) EdgeUpdate \u00b6 Signature : EdgeUpdate(uint256 chainID, uint256 height, bytes32 merkleRoot) RootHistoryRecorded \u00b6 Signature : RootHistoryRecorded(uint timestamp, bytes32[1] roots) RootHistoryUpdate \u00b6 Signature : RootHistoryUpdate(uint timestamp, bytes32[1] roots)","title":"AnchorBase2"},{"location":"bridge-protocols/darkwebb/contracts/AnchorBase2/#anchorbase2sol","text":"Implementation","title":"AnchorBase2.sol"},{"location":"bridge-protocols/darkwebb/contracts/AnchorBase2/#description","text":"An abstract contract that requires child classes to implement appropriate verification and processes for deposits and withdrawals.","title":"Description"},{"location":"bridge-protocols/darkwebb/contracts/AnchorBase2/#variables","text":"","title":"Variables"},{"location":"bridge-protocols/darkwebb/contracts/AnchorBase2/#bridge","text":"Type: public address","title":"bridge"},{"location":"bridge-protocols/darkwebb/contracts/AnchorBase2/#admin","text":"Type: public address","title":"admin"},{"location":"bridge-protocols/darkwebb/contracts/AnchorBase2/#handler","text":"Type: public address","title":"handler"},{"location":"bridge-protocols/darkwebb/contracts/AnchorBase2/#verifier","text":"Type: public immutable IVerifier","title":"verifier"},{"location":"bridge-protocols/darkwebb/contracts/AnchorBase2/#denomination","text":"Type: public immutable uint256","title":"denomination"},{"location":"bridge-protocols/darkwebb/contracts/AnchorBase2/#chainid","text":"Type: public immutable uint256","title":"chainID"},{"location":"bridge-protocols/darkwebb/contracts/AnchorBase2/#nullifierhashes","text":"Type: public mapping(bytes32 => bool)","title":"nullifierHashes"},{"location":"bridge-protocols/darkwebb/contracts/AnchorBase2/#commitments","text":"Type: public mapping(bytes32 => bool)","title":"commitments"},{"location":"bridge-protocols/darkwebb/contracts/AnchorBase2/#edge","text":"Type: struct Edge { uint256 chainID; bytes32 root; uint256 height; }","title":"Edge"},{"location":"bridge-protocols/darkwebb/contracts/AnchorBase2/#edgeindex","text":"Type: mapping(uint256 => uint256)","title":"edgeIndex"},{"location":"bridge-protocols/darkwebb/contracts/AnchorBase2/#edgeexistsforchain","text":"Type: public mapping(uint256 => bool)","title":"edgeExistsForChain"},{"location":"bridge-protocols/darkwebb/contracts/AnchorBase2/#edgelist","text":"Type: public Edge[]","title":"edgeList"},{"location":"bridge-protocols/darkwebb/contracts/AnchorBase2/#neighborroots","text":"Type: public mapping(uint256 => mapping(uint32 => bytes32))","title":"neighborRoots"},{"location":"bridge-protocols/darkwebb/contracts/AnchorBase2/#currentneighborrootindex","text":"Type: public mapping(uint256 => uint32)","title":"currentNeighborRootIndex"},{"location":"bridge-protocols/darkwebb/contracts/AnchorBase2/#constructor","text":"Details Signature constructor( IVerifier _verifier, IHasher _hasher, uint256 _denomination, uint32 _merkleTreeHeight, uint256 _chainID ) MerkleTreePoseidon(_merkleTreeHeight, _hasher)","title":"Constructor"},{"location":"bridge-protocols/darkwebb/contracts/AnchorBase2/#external-functions","text":"Calls to deposits require a commitment, which is a hash of some secret values.","title":"External Functions"},{"location":"bridge-protocols/darkwebb/contracts/AnchorBase2/#deposit","text":"Details Signature deposit(bytes32 _commitment) Requires require(..., \"commitment has been submitted\") Emits Deposit","title":"deposit"},{"location":"bridge-protocols/darkwebb/contracts/AnchorBase2/#withdraw","text":"Details Signature withdraw( bytes calldata _proof, bytes calldata _roots, bytes32 _nullifierHash, address payable _recipient, address payable _relayer, uint256 _fee, uint256 _refund ) Requires require(_fee <= denomination) require(..., \"The note has already been spent\") require(..., \"Cannot find your merkle root\") require(..., \"Incorrect root array length\") require(..., \"Neighbor root not found\") require(..., \"Invalid withdraw proof\") Emits Withdraw","title":"withdraw"},{"location":"bridge-protocols/darkwebb/contracts/AnchorBase2/#view-functions","text":"","title":"View Functions"},{"location":"bridge-protocols/darkwebb/contracts/AnchorBase2/#isspent","text":"Details Signature isSpent(bytes32 _nullifierHash) public view returns (bool)","title":"isSpent"},{"location":"bridge-protocols/darkwebb/contracts/AnchorBase2/#isspentarray","text":"Details Signature isSpentArray(bytes32[] calldata _nullifierHashes) external view returns (bool[] memory spent)","title":"isSpentArray"},{"location":"bridge-protocols/darkwebb/contracts/AnchorBase2/#getlatestneighborroots","text":"Details Signature getLatestNeighborRoots() public view returns (bytes32[1] memory roots)","title":"getLatestNeighborRoots"},{"location":"bridge-protocols/darkwebb/contracts/AnchorBase2/#isknownneighborroot","text":"Details Signature isKnownNeighborRoot(uint256 neighborChainID, bytes32 _root) public view returns (bool)","title":"isKnownNeighborRoot"},{"location":"bridge-protocols/darkwebb/contracts/AnchorBase2/#events","text":"","title":"Events"},{"location":"bridge-protocols/darkwebb/contracts/AnchorBase2/#deposit_1","text":"Signature : Deposit(bytes32 indexed commitment, uint32 leafIndex, uint256 timestamp)","title":"Deposit"},{"location":"bridge-protocols/darkwebb/contracts/AnchorBase2/#withdraw_1","text":"Signature : Withdrawal(address to, bytes32 nullifierHash, address indexed relayer, uint256 fee)","title":"Withdraw"},{"location":"bridge-protocols/darkwebb/contracts/AnchorBase2/#edgeaddition","text":"Signature : EdgeAddition(uint256 chainID, uint256 height, bytes32 merkleRoot)","title":"EdgeAddition"},{"location":"bridge-protocols/darkwebb/contracts/AnchorBase2/#edgeupdate","text":"Signature : EdgeUpdate(uint256 chainID, uint256 height, bytes32 merkleRoot)","title":"EdgeUpdate"},{"location":"bridge-protocols/darkwebb/contracts/AnchorBase2/#roothistoryrecorded","text":"Signature : RootHistoryRecorded(uint timestamp, bytes32[1] roots)","title":"RootHistoryRecorded"},{"location":"bridge-protocols/darkwebb/contracts/AnchorBase2/#roothistoryupdate","text":"Signature : RootHistoryUpdate(uint timestamp, bytes32[1] roots)","title":"RootHistoryUpdate"},{"location":"bridge-protocols/darkwebb/contracts/LinkableAnchor2/","text":"LinkableAnchor2.sol \u00b6 Implementation Description \u00b6 An abstract contract that implements the linking functionality for bridging anchors across chains. This contract inherits all the methods of the base AnchorBase2.sol contract. Constructor \u00b6 Details Signature constructor( IVerifier _verifier, IHasher _hasher, uint256 _denomination, uint32 _merkleTreeHeight, uint256 _chainID, address _bridge, address _admin, address _handler ) AnchorBase2(_verifier, _hasher, _denomination, _merkleTreeHeight, _chainID) External Functions \u00b6 Calls to deposits require a commitment, which is a hash of some secret values. setHandler \u00b6 Details Signature setHandler(address _handler) Requires require(..., \"sender is not the bridge\") setBridge \u00b6 Details Signature setBridge(address _bridge) Requires require(..., \"sender is not the admin\") addEdge \u00b6 Details Signature addEdge( uint256 sourceChainID, bytes32 root, uint256 height ) Requires require(..., \"sender is not the handler\") require(..., \"This Anchor is at capacity\") Emits EdgeAddition, RootHistoryUpdate updateEdge \u00b6 Details Signature updateEdge( uint256 sourceChainID, bytes32 root, uint256 height ) Requires require(..., \"sender is not the handler\") require(..., \"Chain must be integrated from the bridge before updates\") require(..., \"New height must be greater\") Emits EdgeUpdate, RootHistoryUpdate","title":"LinkableAnchor2"},{"location":"bridge-protocols/darkwebb/contracts/LinkableAnchor2/#linkableanchor2sol","text":"Implementation","title":"LinkableAnchor2.sol"},{"location":"bridge-protocols/darkwebb/contracts/LinkableAnchor2/#description","text":"An abstract contract that implements the linking functionality for bridging anchors across chains. This contract inherits all the methods of the base AnchorBase2.sol contract.","title":"Description"},{"location":"bridge-protocols/darkwebb/contracts/LinkableAnchor2/#constructor","text":"Details Signature constructor( IVerifier _verifier, IHasher _hasher, uint256 _denomination, uint32 _merkleTreeHeight, uint256 _chainID, address _bridge, address _admin, address _handler ) AnchorBase2(_verifier, _hasher, _denomination, _merkleTreeHeight, _chainID)","title":"Constructor"},{"location":"bridge-protocols/darkwebb/contracts/LinkableAnchor2/#external-functions","text":"Calls to deposits require a commitment, which is a hash of some secret values.","title":"External Functions"},{"location":"bridge-protocols/darkwebb/contracts/LinkableAnchor2/#sethandler","text":"Details Signature setHandler(address _handler) Requires require(..., \"sender is not the bridge\")","title":"setHandler"},{"location":"bridge-protocols/darkwebb/contracts/LinkableAnchor2/#setbridge","text":"Details Signature setBridge(address _bridge) Requires require(..., \"sender is not the admin\")","title":"setBridge"},{"location":"bridge-protocols/darkwebb/contracts/LinkableAnchor2/#addedge","text":"Details Signature addEdge( uint256 sourceChainID, bytes32 root, uint256 height ) Requires require(..., \"sender is not the handler\") require(..., \"This Anchor is at capacity\") Emits EdgeAddition, RootHistoryUpdate","title":"addEdge"},{"location":"bridge-protocols/darkwebb/contracts/LinkableAnchor2/#updateedge","text":"Details Signature updateEdge( uint256 sourceChainID, bytes32 root, uint256 height ) Requires require(..., \"sender is not the handler\") require(..., \"Chain must be integrated from the bridge before updates\") require(..., \"New height must be greater\") Emits EdgeUpdate, RootHistoryUpdate","title":"updateEdge"},{"location":"bridge-protocols/darkwebb/contracts/MerkleTreePoseidon/","text":"MerkleTreePoseidon.sol \u00b6 Implementation Description \u00b6 The MerkleTreePoseidon is an deployment ready implementation of a MerkleTreeWithHistoryPoseidon.sol and inherits all its methods. It populates the zero hashes and implements the hash function for contracts that inherit it.","title":"MerkleTreePoseidon.sol"},{"location":"bridge-protocols/darkwebb/contracts/MerkleTreePoseidon/#merkletreeposeidonsol","text":"Implementation","title":"MerkleTreePoseidon.sol"},{"location":"bridge-protocols/darkwebb/contracts/MerkleTreePoseidon/#description","text":"The MerkleTreePoseidon is an deployment ready implementation of a MerkleTreeWithHistoryPoseidon.sol and inherits all its methods. It populates the zero hashes and implements the hash function for contracts that inherit it.","title":"Description"},{"location":"bridge-protocols/darkwebb/contracts/MerkleTreeWithHistoryPoseidon/","text":"MerkleTreeWithHistoryPoseidon.sol \u00b6 Implementation Description \u00b6 The MerkleTreeWithHistoryPoseidon is abstract contract and data structure which holds the commitments of deposits - which are hashes of secret values picked by the user. When a user wishes to withdraw from the mixer, the user needs to submit a proof which shows the knowledge of these secret values. Variables \u00b6 hasher \u00b6 Type: public immutable IPoseidonT3 levels \u00b6 Type: public immutable uint32 filledSubtrees \u00b6 Type: public mapping(uint256 => bytes32) roots \u00b6 Type: public mapping(uint256 => bytes32) ROOT_HISTORY_SIZE \u00b6 Type: public constant uint32 currentRootIndex \u00b6 Type: public uint32 nextIndex \u00b6 Type: public uint32 Constructor \u00b6 Details Signature constructor(uint32 _levels, IPoseidonT3 _hasher) Requires require(_levels > 0) require(_levels < 32) External Functions \u00b6 hashLeftRight \u00b6 Details Signature function hashLeftRight(IPoseidonT3 _hasher, bytes32 _left, bytes32 _right) public pure returns (bytes32) Requires require(..., \"_left should be inside the field\") require(..., \"_right should be instide the field\") View Functions \u00b6 isKnownRoot \u00b6 Details Signature isKnownRoot(bytes32 _root) public view returns (bool) getLastRoot \u00b6 Details Signature getLastRoot() public view returns (bytes32) zeros \u00b6 Details Signature zeros(uint256 i) public pure returns (bytes32) Internal Functions \u00b6 _insert \u00b6 Details Signature _insert(bytes32 _leaf) internal returns (uint32 index) Requires require(..., \"merkle tree is full\")","title":"MerkleTreeWithHistoryPoseidon"},{"location":"bridge-protocols/darkwebb/contracts/MerkleTreeWithHistoryPoseidon/#merkletreewithhistoryposeidonsol","text":"Implementation","title":"MerkleTreeWithHistoryPoseidon.sol"},{"location":"bridge-protocols/darkwebb/contracts/MerkleTreeWithHistoryPoseidon/#description","text":"The MerkleTreeWithHistoryPoseidon is abstract contract and data structure which holds the commitments of deposits - which are hashes of secret values picked by the user. When a user wishes to withdraw from the mixer, the user needs to submit a proof which shows the knowledge of these secret values.","title":"Description"},{"location":"bridge-protocols/darkwebb/contracts/MerkleTreeWithHistoryPoseidon/#variables","text":"","title":"Variables"},{"location":"bridge-protocols/darkwebb/contracts/MerkleTreeWithHistoryPoseidon/#hasher","text":"Type: public immutable IPoseidonT3","title":"hasher"},{"location":"bridge-protocols/darkwebb/contracts/MerkleTreeWithHistoryPoseidon/#levels","text":"Type: public immutable uint32","title":"levels"},{"location":"bridge-protocols/darkwebb/contracts/MerkleTreeWithHistoryPoseidon/#filledsubtrees","text":"Type: public mapping(uint256 => bytes32)","title":"filledSubtrees"},{"location":"bridge-protocols/darkwebb/contracts/MerkleTreeWithHistoryPoseidon/#roots","text":"Type: public mapping(uint256 => bytes32)","title":"roots"},{"location":"bridge-protocols/darkwebb/contracts/MerkleTreeWithHistoryPoseidon/#root_history_size","text":"Type: public constant uint32","title":"ROOT_HISTORY_SIZE"},{"location":"bridge-protocols/darkwebb/contracts/MerkleTreeWithHistoryPoseidon/#currentrootindex","text":"Type: public uint32","title":"currentRootIndex"},{"location":"bridge-protocols/darkwebb/contracts/MerkleTreeWithHistoryPoseidon/#nextindex","text":"Type: public uint32","title":"nextIndex"},{"location":"bridge-protocols/darkwebb/contracts/MerkleTreeWithHistoryPoseidon/#constructor","text":"Details Signature constructor(uint32 _levels, IPoseidonT3 _hasher) Requires require(_levels > 0) require(_levels < 32)","title":"Constructor"},{"location":"bridge-protocols/darkwebb/contracts/MerkleTreeWithHistoryPoseidon/#external-functions","text":"","title":"External Functions"},{"location":"bridge-protocols/darkwebb/contracts/MerkleTreeWithHistoryPoseidon/#hashleftright","text":"Details Signature function hashLeftRight(IPoseidonT3 _hasher, bytes32 _left, bytes32 _right) public pure returns (bytes32) Requires require(..., \"_left should be inside the field\") require(..., \"_right should be instide the field\")","title":"hashLeftRight"},{"location":"bridge-protocols/darkwebb/contracts/MerkleTreeWithHistoryPoseidon/#view-functions","text":"","title":"View Functions"},{"location":"bridge-protocols/darkwebb/contracts/MerkleTreeWithHistoryPoseidon/#isknownroot","text":"Details Signature isKnownRoot(bytes32 _root) public view returns (bool)","title":"isKnownRoot"},{"location":"bridge-protocols/darkwebb/contracts/MerkleTreeWithHistoryPoseidon/#getlastroot","text":"Details Signature getLastRoot() public view returns (bytes32)","title":"getLastRoot"},{"location":"bridge-protocols/darkwebb/contracts/MerkleTreeWithHistoryPoseidon/#zeros","text":"Details Signature zeros(uint256 i) public pure returns (bytes32)","title":"zeros"},{"location":"bridge-protocols/darkwebb/contracts/MerkleTreeWithHistoryPoseidon/#internal-functions","text":"","title":"Internal Functions"},{"location":"bridge-protocols/darkwebb/contracts/MerkleTreeWithHistoryPoseidon/#_insert","text":"Details Signature _insert(bytes32 _leaf) internal returns (uint32 index) Requires require(..., \"merkle tree is full\")","title":"_insert"},{"location":"bridge-protocols/darkwebb/contracts/WEBBAnchor2/","text":"WEBBAnchor2.sol \u00b6 Implementation Description \u00b6 A contract that implements the appropriate remaining functions for processing deposits and withdrawals for an AnchorBase2.sol . This contract inherits all the methods of the base LinkableAnchor2.sol and AnchorBase2.sol contracts. Variables \u00b6 token \u00b6 Type: public immutable token Constructor \u00b6 Details Signature constructor( IVerifier _verifier, IPoseidonT3 _hasher, uint256 _denomination, uint32 _merkleTreeHeight, uint32 _chainID, IMintableCompToken _token, address _bridge, address _admin, address _handler ) LinkableAnchor2(_verifier, _hasher, _denomination, _merkleTreeHeight, _chainID, _bridge, _admin, _handler) Internal Functions \u00b6 Calls to deposits require a commitment, which is a hash of some secret values. _processDeposit \u00b6 Details Signature _processDeposit() Requires require(msg.value == 0, \"ETH value is supposed to be 0 for ERC20 instance\") _processWithdraw \u00b6 Details Signature _processWithdraw( address payable _recipient, address payable _relayer, uint256 _fee, uint256 _refund ) Requires require(msg.value == _refund, \"Incorrect refund amount received by the contract\")","title":"WEBBAnchor2"},{"location":"bridge-protocols/darkwebb/contracts/WEBBAnchor2/#webbanchor2sol","text":"Implementation","title":"WEBBAnchor2.sol"},{"location":"bridge-protocols/darkwebb/contracts/WEBBAnchor2/#description","text":"A contract that implements the appropriate remaining functions for processing deposits and withdrawals for an AnchorBase2.sol . This contract inherits all the methods of the base LinkableAnchor2.sol and AnchorBase2.sol contracts.","title":"Description"},{"location":"bridge-protocols/darkwebb/contracts/WEBBAnchor2/#variables","text":"","title":"Variables"},{"location":"bridge-protocols/darkwebb/contracts/WEBBAnchor2/#token","text":"Type: public immutable token","title":"token"},{"location":"bridge-protocols/darkwebb/contracts/WEBBAnchor2/#constructor","text":"Details Signature constructor( IVerifier _verifier, IPoseidonT3 _hasher, uint256 _denomination, uint32 _merkleTreeHeight, uint32 _chainID, IMintableCompToken _token, address _bridge, address _admin, address _handler ) LinkableAnchor2(_verifier, _hasher, _denomination, _merkleTreeHeight, _chainID, _bridge, _admin, _handler)","title":"Constructor"},{"location":"bridge-protocols/darkwebb/contracts/WEBBAnchor2/#internal-functions","text":"Calls to deposits require a commitment, which is a hash of some secret values.","title":"Internal Functions"},{"location":"bridge-protocols/darkwebb/contracts/WEBBAnchor2/#_processdeposit","text":"Details Signature _processDeposit() Requires require(msg.value == 0, \"ETH value is supposed to be 0 for ERC20 instance\")","title":"_processDeposit"},{"location":"bridge-protocols/darkwebb/contracts/WEBBAnchor2/#_processwithdraw","text":"Details Signature _processWithdraw( address payable _recipient, address payable _relayer, uint256 _fee, uint256 _refund ) Requires require(msg.value == _refund, \"Incorrect refund amount received by the contract\")","title":"_processWithdraw"},{"location":"bridge-protocols/darkwebb/contracts/overview/","text":"Solidity implementation of darkwebb \u00b6 Here you can find information about the Solidity implementation of the darkwebb protocol.","title":"Overview"},{"location":"bridge-protocols/darkwebb/contracts/overview/#solidity-implementation-of-darkwebb","text":"Here you can find information about the Solidity implementation of the darkwebb protocol.","title":"Solidity implementation of darkwebb"},{"location":"bridge-protocols/darkwebb/pallets/overview/","text":"Substrate implementation of the darkwebb protocol \u00b6 Here you can information about the pallets used in the Substrate version of darkwebb.","title":"Pallets"},{"location":"bridge-protocols/darkwebb/pallets/overview/#substrate-implementation-of-the-darkwebb-protocol","text":"Here you can information about the pallets used in the Substrate version of darkwebb.","title":"Substrate implementation of the darkwebb protocol"},{"location":"mixer-protocols/tornado/deployments/","text":"Mixer Deployments \u00b6 If you'd like to interact with the mixers programmatically, we have live deployments at the contracts below. Rinkeby \u00b6 Name Source Address .1 ETH Mixer NativeAnchor.sol 0x626FEc5Ffa7Bf1EE8CEd7daBdE545630473E3ABb 1 ETH Mixer NativeAnchor.sol 0x979cBd4917e81447983ef87591B9E1ab21727a61 Hasher Hasher.json 0xE6C5D1c6cc3c6772694d75f61E949daB100a4489 Verifier Verifier.sol 0x95A5CcfCa50F7Dcf410CE397Bb7Becf1b42Ae601 Harmony Testnet Shard 1 \u00b6 Harmony shares Webb's vision of an interoperable future, and we are happy to have Harmony as one of our first supported chains. Name Source Address 100 ONE mixer NativeAnchor.sol 0x7cd1F52e5EEdf753e99D945276a725CE533AaD1a 1000 ONE mixer NativeAnchor.sol 0xD7f9BB9957100310aD397D2bA31771D939BD4731 10000 ONE mixer NativeAnchor.sol 0xeE2eB8F142e48e5D1bDD34e0924Ed3B4aa0d4222 100000 ONE mixer NativeAnchor.sol 0x7cd173094eF78FFAeDee4e14576A73a79aA716ac Hasher Hasher.json 0x96B8Bff1fE9a9c0656b84d7bd1013faD2435Edc0 Verifier Verifier.sol 0xca2c45fe334fBb9d9356AaB291842b964DB9B0E3 Beresheet EVM \u00b6 Edgeware is the first supported EVM in the substrate ecosystem. This ecosystem was born out of interoperable ideals. Name Source Address 100 tEDG mixer NativeAnchor.sol 0xc0d863EE313636F067dCF89e6ea904AD5f8DEC65 1000 tEDG mixer NativeAnchor.sol 0xc7c6152214d0Db4e161Fa67fB62811Be7326834A Hasher Hasher.json 0x96B8Bff1fE9a9c0656b84d7bd1013faD2435Edc0 Verifier Verifier.sol 0xca2c45fe334fBb9d9356AaB291842b964DB9B0E3","title":"Deployments"},{"location":"mixer-protocols/tornado/deployments/#mixer-deployments","text":"If you'd like to interact with the mixers programmatically, we have live deployments at the contracts below.","title":"Mixer Deployments"},{"location":"mixer-protocols/tornado/deployments/#rinkeby","text":"Name Source Address .1 ETH Mixer NativeAnchor.sol 0x626FEc5Ffa7Bf1EE8CEd7daBdE545630473E3ABb 1 ETH Mixer NativeAnchor.sol 0x979cBd4917e81447983ef87591B9E1ab21727a61 Hasher Hasher.json 0xE6C5D1c6cc3c6772694d75f61E949daB100a4489 Verifier Verifier.sol 0x95A5CcfCa50F7Dcf410CE397Bb7Becf1b42Ae601","title":"Rinkeby"},{"location":"mixer-protocols/tornado/deployments/#harmony-testnet-shard-1","text":"Harmony shares Webb's vision of an interoperable future, and we are happy to have Harmony as one of our first supported chains. Name Source Address 100 ONE mixer NativeAnchor.sol 0x7cd1F52e5EEdf753e99D945276a725CE533AaD1a 1000 ONE mixer NativeAnchor.sol 0xD7f9BB9957100310aD397D2bA31771D939BD4731 10000 ONE mixer NativeAnchor.sol 0xeE2eB8F142e48e5D1bDD34e0924Ed3B4aa0d4222 100000 ONE mixer NativeAnchor.sol 0x7cd173094eF78FFAeDee4e14576A73a79aA716ac Hasher Hasher.json 0x96B8Bff1fE9a9c0656b84d7bd1013faD2435Edc0 Verifier Verifier.sol 0xca2c45fe334fBb9d9356AaB291842b964DB9B0E3","title":"Harmony Testnet Shard 1"},{"location":"mixer-protocols/tornado/deployments/#beresheet-evm","text":"Edgeware is the first supported EVM in the substrate ecosystem. This ecosystem was born out of interoperable ideals. Name Source Address 100 tEDG mixer NativeAnchor.sol 0xc0d863EE313636F067dCF89e6ea904AD5f8DEC65 1000 tEDG mixer NativeAnchor.sol 0xc7c6152214d0Db4e161Fa67fB62811Be7326834A Hasher Hasher.json 0x96B8Bff1fE9a9c0656b84d7bd1013faD2435Edc0 Verifier Verifier.sol 0xca2c45fe334fBb9d9356AaB291842b964DB9B0E3","title":"Beresheet EVM"},{"location":"mixer-protocols/tornado/overview/","text":"Tornado Core \u00b6 The tornado core library defines a set of Solidity smart contracts for mixers. These contracts are used in the dapp for EVM interactions.","title":"Overview"},{"location":"mixer-protocols/tornado/overview/#tornado-core","text":"The tornado core library defines a set of Solidity smart contracts for mixers. These contracts are used in the dapp for EVM interactions.","title":"Tornado Core"},{"location":"mixer-protocols/tornado/contracts/Anchor/","text":"Anchor.sol \u00b6 Description \u00b6 An abstract contract that requires child classes to implement appropriate verification and processes for deposits and withdrawals. Variables \u00b6 verifier \u00b6 Type: public immutable IVerifier denomination \u00b6 Type: public immutable uint256 nullifierHashes \u00b6 Type: public mapping(bytes32 => bool) commitments \u00b6 Type: public mapping(bytes32 => bool) Constructor \u00b6 Details Signature constructor(IVerifier _verifier, IHasher _hasher, uint256 _denomination, uint256 _treeHeight) MerkleTreeWithHistory(_merkleTreeHeight, _hasher) External Functions \u00b6 Calls to deposits require a commitment, which is a hash of some secret values. Deposit \u00b6 Details Signature deposit(bytes32 _commitment) Requires require(..., \"commitment has been submitted\") Emits Deposit Withdraw \u00b6 Details Signature withdraw(address _recipient, address _relayer, uint256 _fee, uint256 _refund) Requires require(_fee <= denomination) require(..., \"The not has already been spent\") require(..., \"Cannot find your merkle root\") require(..., \"Invalid withdraw proof\") Emits Withdraw View Functions \u00b6 isSpent \u00b6 Details Signature isSpent(bytes32 _nullifierHash) public view returns (bool) isSpentArray \u00b6 Details Signature isSpentArray(bytes32[] calldata _nullifierHashes) external view returns (bool[] memory spent) Events \u00b6 Deposit \u00b6 Signature : Deposit(bytes32 indexed commitment, uint32 leafIndex, uint256 timestamp) Withdraw \u00b6 Signature : Withdrawal(address to, bytes32 nullifierHash, address indexed relayer, uint256 fee)","title":"Anchor"},{"location":"mixer-protocols/tornado/contracts/Anchor/#anchorsol","text":"","title":"Anchor.sol"},{"location":"mixer-protocols/tornado/contracts/Anchor/#description","text":"An abstract contract that requires child classes to implement appropriate verification and processes for deposits and withdrawals.","title":"Description"},{"location":"mixer-protocols/tornado/contracts/Anchor/#variables","text":"","title":"Variables"},{"location":"mixer-protocols/tornado/contracts/Anchor/#verifier","text":"Type: public immutable IVerifier","title":"verifier"},{"location":"mixer-protocols/tornado/contracts/Anchor/#denomination","text":"Type: public immutable uint256","title":"denomination"},{"location":"mixer-protocols/tornado/contracts/Anchor/#nullifierhashes","text":"Type: public mapping(bytes32 => bool)","title":"nullifierHashes"},{"location":"mixer-protocols/tornado/contracts/Anchor/#commitments","text":"Type: public mapping(bytes32 => bool)","title":"commitments"},{"location":"mixer-protocols/tornado/contracts/Anchor/#constructor","text":"Details Signature constructor(IVerifier _verifier, IHasher _hasher, uint256 _denomination, uint256 _treeHeight) MerkleTreeWithHistory(_merkleTreeHeight, _hasher)","title":"Constructor"},{"location":"mixer-protocols/tornado/contracts/Anchor/#external-functions","text":"Calls to deposits require a commitment, which is a hash of some secret values.","title":"External Functions"},{"location":"mixer-protocols/tornado/contracts/Anchor/#deposit","text":"Details Signature deposit(bytes32 _commitment) Requires require(..., \"commitment has been submitted\") Emits Deposit","title":"Deposit"},{"location":"mixer-protocols/tornado/contracts/Anchor/#withdraw","text":"Details Signature withdraw(address _recipient, address _relayer, uint256 _fee, uint256 _refund) Requires require(_fee <= denomination) require(..., \"The not has already been spent\") require(..., \"Cannot find your merkle root\") require(..., \"Invalid withdraw proof\") Emits Withdraw","title":"Withdraw"},{"location":"mixer-protocols/tornado/contracts/Anchor/#view-functions","text":"","title":"View Functions"},{"location":"mixer-protocols/tornado/contracts/Anchor/#isspent","text":"Details Signature isSpent(bytes32 _nullifierHash) public view returns (bool)","title":"isSpent"},{"location":"mixer-protocols/tornado/contracts/Anchor/#isspentarray","text":"Details Signature isSpentArray(bytes32[] calldata _nullifierHashes) external view returns (bool[] memory spent)","title":"isSpentArray"},{"location":"mixer-protocols/tornado/contracts/Anchor/#events","text":"","title":"Events"},{"location":"mixer-protocols/tornado/contracts/Anchor/#deposit_1","text":"Signature : Deposit(bytes32 indexed commitment, uint32 leafIndex, uint256 timestamp)","title":"Deposit"},{"location":"mixer-protocols/tornado/contracts/Anchor/#withdraw_1","text":"Signature : Withdrawal(address to, bytes32 nullifierHash, address indexed relayer, uint256 fee)","title":"Withdraw"},{"location":"mixer-protocols/tornado/contracts/IHasher/","text":"IHasher \u00b6 Description \u00b6 The hasher for contracts in tornado core uses MiMC. It is generated from circom's mimcsponge_gencontract.js MiMCSponge \u00b6 Details Signature MiMCSponge(uint256 in_xL, uint256 in_xR) external pure returns (uint256 xL, uint256 xR)","title":"IHasher"},{"location":"mixer-protocols/tornado/contracts/IHasher/#ihasher","text":"","title":"IHasher"},{"location":"mixer-protocols/tornado/contracts/IHasher/#description","text":"The hasher for contracts in tornado core uses MiMC. It is generated from circom's mimcsponge_gencontract.js","title":"Description"},{"location":"mixer-protocols/tornado/contracts/IHasher/#mimcsponge","text":"Details Signature MiMCSponge(uint256 in_xL, uint256 in_xR) external pure returns (uint256 xL, uint256 xR)","title":"MiMCSponge"},{"location":"mixer-protocols/tornado/contracts/IVerifier/","text":"IVerifier \u00b6 Description \u00b6 The verifier exposes the verifyProof view function and is generated from the verifying key for the corresponding SNARK. verifyProof \u00b6 Details Signature verifyProof(bytes memory _proof, uint256[6] memory _input) external returns (bool)","title":"IVerifier"},{"location":"mixer-protocols/tornado/contracts/IVerifier/#iverifier","text":"","title":"IVerifier"},{"location":"mixer-protocols/tornado/contracts/IVerifier/#description","text":"The verifier exposes the verifyProof view function and is generated from the verifying key for the corresponding SNARK.","title":"Description"},{"location":"mixer-protocols/tornado/contracts/IVerifier/#verifyproof","text":"Details Signature verifyProof(bytes memory _proof, uint256[6] memory _input) external returns (bool)","title":"verifyProof"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/","text":"MerkleTreeWithHistory.sol \u00b6 Description \u00b6 The MerkleTreeWithHistory is the data structure which holds the commitments of deposits - which are hashes of secret values picked by the user. When a user wishes to withdraw from the mixer, the user needs to submit a proof which shows the knowledge of these secret values. This proof needs this merkle tree to calculate the path from the leaves (commitments) to the root. Variables \u00b6 hasher \u00b6 Type: public immutable IHasher levels \u00b6 Type: public immutable uint32 filledSubtrees \u00b6 Type: public mapping(uint256 => bytes32) roots \u00b6 Type: public mapping(uint256 => bytes32) ROOT_HISTORY_SIZE \u00b6 Type: public constant uint32 currentRootIndex \u00b6 Type: public uint32 nextIndex \u00b6 Type: public uint32 Constructor \u00b6 Details Signature constructor(uint32 _levels, IHasher _hasher) Requires require(_levels > 0) require(_levels < 32) External Functions \u00b6 hashLeftRight \u00b6 Details Signature function hashLeftRight(IHasher _hasher, bytes32 _left, bytes32 _right) public pure returns (bytes32) Requires require(..., \"_left should be inside the field\") require(..., \"_right should be instide the field\") View Functions \u00b6 isKnownRoot \u00b6 Details Signature isKnownRoot(bytes32 _root) public view returns (bool) getLastRoot \u00b6 Details Signature getLastRoot() public view returns (bytes32) zeros \u00b6 Details Signature zeros(uint256 i) public pure returns (bytes32) Internal Functions \u00b6 _insert \u00b6 Details Signature _insert(bytes32 _leaf) internal returns (uint32 index) Requires require(..., \"merkle tree is full\")","title":"MerkleTreeWithHistory"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#merkletreewithhistorysol","text":"","title":"MerkleTreeWithHistory.sol"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#description","text":"The MerkleTreeWithHistory is the data structure which holds the commitments of deposits - which are hashes of secret values picked by the user. When a user wishes to withdraw from the mixer, the user needs to submit a proof which shows the knowledge of these secret values. This proof needs this merkle tree to calculate the path from the leaves (commitments) to the root.","title":"Description"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#variables","text":"","title":"Variables"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#hasher","text":"Type: public immutable IHasher","title":"hasher"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#levels","text":"Type: public immutable uint32","title":"levels"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#filledsubtrees","text":"Type: public mapping(uint256 => bytes32)","title":"filledSubtrees"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#roots","text":"Type: public mapping(uint256 => bytes32)","title":"roots"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#root_history_size","text":"Type: public constant uint32","title":"ROOT_HISTORY_SIZE"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#currentrootindex","text":"Type: public uint32","title":"currentRootIndex"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#nextindex","text":"Type: public uint32","title":"nextIndex"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#constructor","text":"Details Signature constructor(uint32 _levels, IHasher _hasher) Requires require(_levels > 0) require(_levels < 32)","title":"Constructor"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#external-functions","text":"","title":"External Functions"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#hashleftright","text":"Details Signature function hashLeftRight(IHasher _hasher, bytes32 _left, bytes32 _right) public pure returns (bytes32) Requires require(..., \"_left should be inside the field\") require(..., \"_right should be instide the field\")","title":"hashLeftRight"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#view-functions","text":"","title":"View Functions"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#isknownroot","text":"Details Signature isKnownRoot(bytes32 _root) public view returns (bool)","title":"isKnownRoot"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#getlastroot","text":"Details Signature getLastRoot() public view returns (bytes32)","title":"getLastRoot"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#zeros","text":"Details Signature zeros(uint256 i) public pure returns (bytes32)","title":"zeros"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#internal-functions","text":"","title":"Internal Functions"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#_insert","text":"Details Signature _insert(bytes32 _leaf) internal returns (uint32 index) Requires require(..., \"merkle tree is full\")","title":"_insert"},{"location":"mixer-protocols/tornado/contracts/NativeAnchor/","text":"NativeAnchor.sol \u00b6 Description \u00b6 A concrete instance of a mixer which deals with the native currency of the chain. Constructor \u00b6 Details Signature constructor(IVerifier _verifier, IHasher _hasher, uint256 _denomination, uint256 _merkleTreeHeight) Anchor(_verifier, _hasher, _denomination, _merkleTreeHeight) {} Internal Functions \u00b6 _processWithdraw \u00b6 Details Signature _processWithdraw(address _recipient, address _relayer, uint256 _fee, uint256 _refund) internal override Requires require(msg.value == 0) require(_refund == 0) require(..., \"payment to _recipient did not go through\") require(..., \"payment to _relayer did not go through\") _processDeposit \u00b6 Details Signature _processDeposit() internal override Requires require(msg.value == denomination)","title":"NativeAnchor"},{"location":"mixer-protocols/tornado/contracts/NativeAnchor/#nativeanchorsol","text":"","title":"NativeAnchor.sol"},{"location":"mixer-protocols/tornado/contracts/NativeAnchor/#description","text":"A concrete instance of a mixer which deals with the native currency of the chain.","title":"Description"},{"location":"mixer-protocols/tornado/contracts/NativeAnchor/#constructor","text":"Details Signature constructor(IVerifier _verifier, IHasher _hasher, uint256 _denomination, uint256 _merkleTreeHeight) Anchor(_verifier, _hasher, _denomination, _merkleTreeHeight) {}","title":"Constructor"},{"location":"mixer-protocols/tornado/contracts/NativeAnchor/#internal-functions","text":"","title":"Internal Functions"},{"location":"mixer-protocols/tornado/contracts/NativeAnchor/#_processwithdraw","text":"Details Signature _processWithdraw(address _recipient, address _relayer, uint256 _fee, uint256 _refund) internal override Requires require(msg.value == 0) require(_refund == 0) require(..., \"payment to _recipient did not go through\") require(..., \"payment to _relayer did not go through\")","title":"_processWithdraw"},{"location":"mixer-protocols/tornado/contracts/NativeAnchor/#_processdeposit","text":"Details Signature _processDeposit() internal override Requires require(msg.value == denomination)","title":"_processDeposit"},{"location":"relayer/http-endpoints/","text":"Exposed endpoints the client can query to obtain data about their exposed data, the relayer, or mixer deployments. API v1 \u00b6 IP \u00b6 Relayers can let the client know of their IP address. This is informative to the client, as their privacy is potentially compromised by this information. /api/v1/ip Response Format { \"ip\": <string> } Response Explanation The IP address from which the request was sent to the relayer. Info \u00b6 A client should make a call to the relayer to find which chains it supports, as well as the fees and relayer address to include in the proof generation. /api/v1/info Response Format { evm: { [networkName]: { \"withdrawFeePercentage\": <number>, \"account\": <string>, \"enableLeavesWatcher\": <boolean>, }, ... } } Response Explanation withdrawFeePercentage : The minimum amount of percentage that the relayer requires to send a transaction on the client's behalf. account : The reward account of the relayer, which will collect the fee. enableLeavesWatcher : A boolean flag indicating if the relayer is able to provide a client with the leaves that make up the merkle tree of a particular mixer. EVM Mixer Leaves \u00b6 A client can query the relayer for the leaves (commitments) of a mixer deployment. This information is necessary for building the merkle tree on the client side, in order to build the proof of secrets for a particular commitment. The client can query the blockchain directly, but getting the information from a relayer will be much quicker. /api/v1/leaves/:contractAddress Response Format { \"leaves\": [ <hex-string>, <hex-string>, ... ] } Response explanation The leaves will be properly indexed in the array.","title":"Http Endpoints"},{"location":"relayer/http-endpoints/#api-v1","text":"","title":"API v1"},{"location":"relayer/http-endpoints/#ip","text":"Relayers can let the client know of their IP address. This is informative to the client, as their privacy is potentially compromised by this information. /api/v1/ip Response Format { \"ip\": <string> } Response Explanation The IP address from which the request was sent to the relayer.","title":"IP"},{"location":"relayer/http-endpoints/#info","text":"A client should make a call to the relayer to find which chains it supports, as well as the fees and relayer address to include in the proof generation. /api/v1/info Response Format { evm: { [networkName]: { \"withdrawFeePercentage\": <number>, \"account\": <string>, \"enableLeavesWatcher\": <boolean>, }, ... } } Response Explanation withdrawFeePercentage : The minimum amount of percentage that the relayer requires to send a transaction on the client's behalf. account : The reward account of the relayer, which will collect the fee. enableLeavesWatcher : A boolean flag indicating if the relayer is able to provide a client with the leaves that make up the merkle tree of a particular mixer.","title":"Info"},{"location":"relayer/http-endpoints/#evm-mixer-leaves","text":"A client can query the relayer for the leaves (commitments) of a mixer deployment. This information is necessary for building the merkle tree on the client side, in order to build the proof of secrets for a particular commitment. The client can query the blockchain directly, but getting the information from a relayer will be much quicker. /api/v1/leaves/:contractAddress Response Format { \"leaves\": [ <hex-string>, <hex-string>, ... ] } Response explanation The leaves will be properly indexed in the array.","title":"EVM Mixer Leaves"},{"location":"relayer/overview/","text":"The Relayer offers the end-user privacy and receives fees from the users for providing this service. Relayers can be configured to listen to only the networks that they are interested in. Download the code and start supporting the network!","title":"Overview"},{"location":"relayer/setup/","text":"This document serves as instructions for setting up a Webb Relayer at a publicly accessible endpoint. It will fulfill the requirements for listing your relayer on app.webb.tools. In order to integrate your relayer to app.webb.tools, please submit a PR. - Connections available via https and wss on your domain. Instructions \u00b6 These instructions will assume the user has created a cloud server on Ubuntu 20.04, and is logged into a user with sudo permissions. By the end of these instructions, the relayer will be running and accessible via your endpoint with nginx behind a reverse proxy. Basic Environment Setup \u00b6 ### Setup the machine's environment ### # Update ubuntu packages sudo apt update && sudo apt upgrade # Update snap packages sudo snap install core; sudo snap refresh core # Install dependencies sudo apt install gcc cmake pkg-config libssl-dev git clang libclang-dev sudo apt install build-essential # Install rust curl https://sh.rustup.rs -sSf | sh -s -- -y export PATH=~/.cargo/bin:$PATH source ~/.cargo/env # Install certbot sudo snap install --classic certbot && sudo ln -s /snap/bin/certbot /usr/bin/certbot Relayer setup \u00b6 Get the relayer code: git clone https://github.com/webb-tools/relayer.git Follow the README to create your config.toml for the networks you wish to support. Harmony example configuration port = 9955 [substrate.webb] suri = \"//Alice\" [evm.harmony] http-endpoint = \"https://api.s1.b.hmny.io\" ws-endpoint = \"wss://ws.s1.b.hmny.io\" private-key = <PRIVATE_KEY_AS_HEX_STRING> chain-id = 1666700001 [[evm.harmony.contracts]] contract = \"Anchor\" address = \"0x7cd1F52e5EEdf753e99D945276a725CE533AaD1a\" deployed-at = 12040000 size = 100 events-watcher = { enabled = true, polling-interval = 3000 } withdraw-fee-percentage = 0.05 withdraw-gaslimit = \"0x350000\" [[evm.harmony.contracts]] contract = \"Anchor\" address = \"0xD7f9BB9957100310aD397D2bA31771D939BD4731\" deployed-at = 12892487 size = 1000 events-watcher = { enabled = true, polling-interval = 3000 } withdraw-fee-percentage = 0.03 withdraw-gaslimit = \"0x350000\" [[evm.harmony.contracts]] contract = \"Anchor\" address = \"0xeE2eB8F142e48e5D1bDD34e0924Ed3B4aa0d4222\" deployed-at = 12892648 size = 10000 events-watcher = { enabled = true, polling-interval = 3000 } withdraw-fee-percentage = 0.02 withdraw-gaslimit = \"0x350000\" Full support example configuration port = 9955 [substrate.webb] suri = \"//Alice\" [evm.beresheet] http-endpoint = \"https://beresheet.edgewa.re/evm\" ws-endpoint = \"wss://beresheet1.edgewa.re\" private-key = <PRIVATE_KEY_AS_HEX_STRING> chain-id = 2022 [[evm.beresheet.contracts]] contract = \"Anchor\" address = \"0xf0EA8Fa17daCF79434d10C51941D8Fc24515AbE3\" deployed-at = 299740 size = 10 events-watcher = { enabled = true, polling-interval = 7000} withdraw-fee-percentage = 0.05 withdraw-gaslimit = \"0x350000\" [[evm.beresheet.contracts]] contract = \"Anchor\" address = \"0xc0d863EE313636F067dCF89e6ea904AD5f8DEC65\" deployed-at = 299740 size = 100 events-watcher = { enabled = true, polling-interval = 7000} withdraw-fee-percentage = 0.05 withdraw-gaslimit = \"0x350000\" [[evm.beresheet.contracts]] contract = \"Anchor\" address = \"0xc7c6152214d0Db4e161Fa67fB62811Be7326834A\" deployed-at = 299740 size = 1000 events-watcher = { enabled = true, polling-interval = 7000} withdraw-fee-percentage = 0.05 withdraw-gaslimit = \"0x350000\" [[evm.beresheet.contracts]] contract = \"Anchor\" address = \"0xf0290d80880E3c59512e454E303FcD48f431acA3\" deployed-at = 299740 size = 10000 events-watcher = { enabled = true, polling-interval = 7000} withdraw-fee-percentage = 0.05 withdraw-gaslimit = \"0x350000\" [evm.harmony] http-endpoint = \"https://api.s1.b.hmny.io\" ws-endpoint = \"wss://ws.s1.b.hmny.io\" private-key = <PRIVATE_KEY_AS_HEX_STRING> chain-id = 1666700001 [[evm.harmony.contracts]] contract = \"Anchor\" address = \"0x4c37863bf2642Ba4e8De7e746500C700540119E8\" deployed-at = 13600000 size = 0.0000000001 events-watcher = { enabled = true, polling-interval = 3000 } withdraw-fee-percentage = 0.05 withdraw-gaslimit = \"0x350000\" [[evm.harmony.contracts]] contract = \"Anchor\" address = \"0x7cd1F52e5EEdf753e99D945276a725CE533AaD1a\" deployed-at = 12040000 size = 100 events-watcher = { enabled = true, polling-interval = 3000 } withdraw-fee-percentage = 0.05 withdraw-gaslimit = \"0x350000\" [[evm.harmony.contracts]] contract = \"Anchor\" address = \"0xD7f9BB9957100310aD397D2bA31771D939BD4731\" deployed-at = 12892487 size = 1000 events-watcher = { enabled = true, polling-interval = 3000 } withdraw-fee-percentage = 0.05 withdraw-gaslimit = \"0x350000\" [[evm.harmony.contracts]] contract = \"Anchor\" address = \"0xeE2eB8F142e48e5D1bDD34e0924Ed3B4aa0d4222\" deployed-at = 12892648 size = 10000 events-watcher = { enabled = true, polling-interval = 3000 } withdraw-fee-percentage = 0.05 withdraw-gaslimit = \"0x350000\" [evm.rinkeby] http-endpoint = \"https://rinkeby.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161\" ws-endpoint = \"wss://rinkeby.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161\" private-key = <PRIVATE_KEY_AS_HEX_STRING> chain-id = 4 [[evm.rinkeby.contracts]] contract = \"Anchor\" address = \"0x626FEc5Ffa7Bf1EE8CEd7daBdE545630473E3ABb\" deployed-at = 8896800 size = 0.1 events-watcher = { enabled = true, polling-interval = 15000 } withdraw-fee-percentage = 0.05 withdraw-gaslimit = \"0x350000\" [[evm.rinkeby.contracts]] contract = \"Anchor\" address = \"0x979cBd4917e81447983ef87591B9E1ab21727a61\" deployed-at = 8896800 size = 1 events-watcher = { enabled = true, polling-interval = 15000 } withdraw-fee-percentage = 0.05 withdraw-gaslimit = \"0x350000\" Setup the relayer as a system service: # Create the service file sudo touch /etc/systemd/system/webb-relayer.service # This assumes a config.toml file has been setup in a config/ directory # and the repo has been cloned in the home directory of the user # Paste the following into the service file, and replace the <user>: [Unit] Description=WebbRelayer [Service] Type=exec WorkingDirectory=/home/<user>/relayer ExecStart=/home/<user>/relayer/target/release/webb-relayer -c /home/<user>/relayer/config/config.toml -vvv [Install] WantedBy=multi-user.target Kick off the system service: sudo systemctl enable webb-relayer && sudo systemctl start webb-relayer Nginx Setup \u00b6 Configure your registered domain name with your cloud service provider. Install nginx if it isn't already on your machine: sudo apt install nginx First, we will configure the endpoint linked to your at port 80 for certificate generation Create nginx site files for your domain: cd /etc/nginx/sites-available && sudo cp default <domain name> && sudo ln -s /etc/nginx/sites-available/<domain name> /etc/nginx/sites-enabled/ Modify the nginx sites-available file to: server { listen 80; listen [::]:80; root /var/www/<domain name>/html; index index.html index.htm index.nginx-debian.html; server_name <domain name>; location / { try_files $uri $uri/ =404; } } Check the nginx configuration sudo nginx -t If no issues exist, restart the nginx service sudo systemctl restart nginx Next we will create the self-signed certificate and reconfigure for https and wss support Create the self-signed certificate: sudo certbot certonly --nginx Modify the nginx site file: map $http_upgrade $connection_upgrade { default upgrade; '' close; } server { # SSL configuration # listen 443 ssl; listen [::]:443 ssl; root /var/www/<domain name>/html; server_name <domain name>; ssl_certificate /etc/letsencrypt/live/<domain name>/cert.pem; ssl_certificate_key /etc/letsencrypt/live/<domain name>/privkey.pem; ssl_session_timeout 5m; ssl_protocols SSLv2 SSLv3 TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / { proxy_pass http://127.0.0.1:9955; proxy_pass_request_headers on; proxy_http_version 1.1; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $connection_upgrade; } } Check nginx configuration and restart. Monitoring Setup \u00b6 Relayers will want to setup monitoring to ensure maximum uptime and automatic restarts when things go awry. sudo apt install -y monit modify the monitrc file at: /etc/monit/monitrc set httpd port 2812 and use address localhost allow localhost set daemon 10 set log /var/log/monit.log set idfile /var/lib/monit/id set statefile /var/lib/monit/state set eventqueue basedir /var/lib/monit/events slots 100 check process webb-relayer matching target/release/webb-relayer start program = \"/bin/systemctl restart webb-relayer\" stop program = \"/bin/systemctl kill webb-relayer\" if cpu > 90% for 20 cycles then exec \"/bin/systemctl stop webb-relayer\" and repeat every 10 cycles if cpu > 90% for 64 cycles then exec \"/bin/systemctl kill webb-relayer\" and repeat every 10 cycles if cpu > 90% for 64 cycles then alert if does not exist for 1 cycles then start restart monit and validate: sudo monit reload && sudo monit validate","title":"Setup"},{"location":"relayer/setup/#instructions","text":"These instructions will assume the user has created a cloud server on Ubuntu 20.04, and is logged into a user with sudo permissions. By the end of these instructions, the relayer will be running and accessible via your endpoint with nginx behind a reverse proxy.","title":"Instructions"},{"location":"relayer/setup/#basic-environment-setup","text":"### Setup the machine's environment ### # Update ubuntu packages sudo apt update && sudo apt upgrade # Update snap packages sudo snap install core; sudo snap refresh core # Install dependencies sudo apt install gcc cmake pkg-config libssl-dev git clang libclang-dev sudo apt install build-essential # Install rust curl https://sh.rustup.rs -sSf | sh -s -- -y export PATH=~/.cargo/bin:$PATH source ~/.cargo/env # Install certbot sudo snap install --classic certbot && sudo ln -s /snap/bin/certbot /usr/bin/certbot","title":"Basic Environment Setup"},{"location":"relayer/setup/#relayer-setup","text":"Get the relayer code: git clone https://github.com/webb-tools/relayer.git Follow the README to create your config.toml for the networks you wish to support. Harmony example configuration port = 9955 [substrate.webb] suri = \"//Alice\" [evm.harmony] http-endpoint = \"https://api.s1.b.hmny.io\" ws-endpoint = \"wss://ws.s1.b.hmny.io\" private-key = <PRIVATE_KEY_AS_HEX_STRING> chain-id = 1666700001 [[evm.harmony.contracts]] contract = \"Anchor\" address = \"0x7cd1F52e5EEdf753e99D945276a725CE533AaD1a\" deployed-at = 12040000 size = 100 events-watcher = { enabled = true, polling-interval = 3000 } withdraw-fee-percentage = 0.05 withdraw-gaslimit = \"0x350000\" [[evm.harmony.contracts]] contract = \"Anchor\" address = \"0xD7f9BB9957100310aD397D2bA31771D939BD4731\" deployed-at = 12892487 size = 1000 events-watcher = { enabled = true, polling-interval = 3000 } withdraw-fee-percentage = 0.03 withdraw-gaslimit = \"0x350000\" [[evm.harmony.contracts]] contract = \"Anchor\" address = \"0xeE2eB8F142e48e5D1bDD34e0924Ed3B4aa0d4222\" deployed-at = 12892648 size = 10000 events-watcher = { enabled = true, polling-interval = 3000 } withdraw-fee-percentage = 0.02 withdraw-gaslimit = \"0x350000\" Full support example configuration port = 9955 [substrate.webb] suri = \"//Alice\" [evm.beresheet] http-endpoint = \"https://beresheet.edgewa.re/evm\" ws-endpoint = \"wss://beresheet1.edgewa.re\" private-key = <PRIVATE_KEY_AS_HEX_STRING> chain-id = 2022 [[evm.beresheet.contracts]] contract = \"Anchor\" address = \"0xf0EA8Fa17daCF79434d10C51941D8Fc24515AbE3\" deployed-at = 299740 size = 10 events-watcher = { enabled = true, polling-interval = 7000} withdraw-fee-percentage = 0.05 withdraw-gaslimit = \"0x350000\" [[evm.beresheet.contracts]] contract = \"Anchor\" address = \"0xc0d863EE313636F067dCF89e6ea904AD5f8DEC65\" deployed-at = 299740 size = 100 events-watcher = { enabled = true, polling-interval = 7000} withdraw-fee-percentage = 0.05 withdraw-gaslimit = \"0x350000\" [[evm.beresheet.contracts]] contract = \"Anchor\" address = \"0xc7c6152214d0Db4e161Fa67fB62811Be7326834A\" deployed-at = 299740 size = 1000 events-watcher = { enabled = true, polling-interval = 7000} withdraw-fee-percentage = 0.05 withdraw-gaslimit = \"0x350000\" [[evm.beresheet.contracts]] contract = \"Anchor\" address = \"0xf0290d80880E3c59512e454E303FcD48f431acA3\" deployed-at = 299740 size = 10000 events-watcher = { enabled = true, polling-interval = 7000} withdraw-fee-percentage = 0.05 withdraw-gaslimit = \"0x350000\" [evm.harmony] http-endpoint = \"https://api.s1.b.hmny.io\" ws-endpoint = \"wss://ws.s1.b.hmny.io\" private-key = <PRIVATE_KEY_AS_HEX_STRING> chain-id = 1666700001 [[evm.harmony.contracts]] contract = \"Anchor\" address = \"0x4c37863bf2642Ba4e8De7e746500C700540119E8\" deployed-at = 13600000 size = 0.0000000001 events-watcher = { enabled = true, polling-interval = 3000 } withdraw-fee-percentage = 0.05 withdraw-gaslimit = \"0x350000\" [[evm.harmony.contracts]] contract = \"Anchor\" address = \"0x7cd1F52e5EEdf753e99D945276a725CE533AaD1a\" deployed-at = 12040000 size = 100 events-watcher = { enabled = true, polling-interval = 3000 } withdraw-fee-percentage = 0.05 withdraw-gaslimit = \"0x350000\" [[evm.harmony.contracts]] contract = \"Anchor\" address = \"0xD7f9BB9957100310aD397D2bA31771D939BD4731\" deployed-at = 12892487 size = 1000 events-watcher = { enabled = true, polling-interval = 3000 } withdraw-fee-percentage = 0.05 withdraw-gaslimit = \"0x350000\" [[evm.harmony.contracts]] contract = \"Anchor\" address = \"0xeE2eB8F142e48e5D1bDD34e0924Ed3B4aa0d4222\" deployed-at = 12892648 size = 10000 events-watcher = { enabled = true, polling-interval = 3000 } withdraw-fee-percentage = 0.05 withdraw-gaslimit = \"0x350000\" [evm.rinkeby] http-endpoint = \"https://rinkeby.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161\" ws-endpoint = \"wss://rinkeby.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161\" private-key = <PRIVATE_KEY_AS_HEX_STRING> chain-id = 4 [[evm.rinkeby.contracts]] contract = \"Anchor\" address = \"0x626FEc5Ffa7Bf1EE8CEd7daBdE545630473E3ABb\" deployed-at = 8896800 size = 0.1 events-watcher = { enabled = true, polling-interval = 15000 } withdraw-fee-percentage = 0.05 withdraw-gaslimit = \"0x350000\" [[evm.rinkeby.contracts]] contract = \"Anchor\" address = \"0x979cBd4917e81447983ef87591B9E1ab21727a61\" deployed-at = 8896800 size = 1 events-watcher = { enabled = true, polling-interval = 15000 } withdraw-fee-percentage = 0.05 withdraw-gaslimit = \"0x350000\" Setup the relayer as a system service: # Create the service file sudo touch /etc/systemd/system/webb-relayer.service # This assumes a config.toml file has been setup in a config/ directory # and the repo has been cloned in the home directory of the user # Paste the following into the service file, and replace the <user>: [Unit] Description=WebbRelayer [Service] Type=exec WorkingDirectory=/home/<user>/relayer ExecStart=/home/<user>/relayer/target/release/webb-relayer -c /home/<user>/relayer/config/config.toml -vvv [Install] WantedBy=multi-user.target Kick off the system service: sudo systemctl enable webb-relayer && sudo systemctl start webb-relayer","title":"Relayer setup"},{"location":"relayer/setup/#nginx-setup","text":"Configure your registered domain name with your cloud service provider. Install nginx if it isn't already on your machine: sudo apt install nginx First, we will configure the endpoint linked to your at port 80 for certificate generation Create nginx site files for your domain: cd /etc/nginx/sites-available && sudo cp default <domain name> && sudo ln -s /etc/nginx/sites-available/<domain name> /etc/nginx/sites-enabled/ Modify the nginx sites-available file to: server { listen 80; listen [::]:80; root /var/www/<domain name>/html; index index.html index.htm index.nginx-debian.html; server_name <domain name>; location / { try_files $uri $uri/ =404; } } Check the nginx configuration sudo nginx -t If no issues exist, restart the nginx service sudo systemctl restart nginx Next we will create the self-signed certificate and reconfigure for https and wss support Create the self-signed certificate: sudo certbot certonly --nginx Modify the nginx site file: map $http_upgrade $connection_upgrade { default upgrade; '' close; } server { # SSL configuration # listen 443 ssl; listen [::]:443 ssl; root /var/www/<domain name>/html; server_name <domain name>; ssl_certificate /etc/letsencrypt/live/<domain name>/cert.pem; ssl_certificate_key /etc/letsencrypt/live/<domain name>/privkey.pem; ssl_session_timeout 5m; ssl_protocols SSLv2 SSLv3 TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / { proxy_pass http://127.0.0.1:9955; proxy_pass_request_headers on; proxy_http_version 1.1; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $connection_upgrade; } } Check nginx configuration and restart.","title":"Nginx Setup"},{"location":"relayer/setup/#monitoring-setup","text":"Relayers will want to setup monitoring to ensure maximum uptime and automatic restarts when things go awry. sudo apt install -y monit modify the monitrc file at: /etc/monit/monitrc set httpd port 2812 and use address localhost allow localhost set daemon 10 set log /var/log/monit.log set idfile /var/lib/monit/id set statefile /var/lib/monit/state set eventqueue basedir /var/lib/monit/events slots 100 check process webb-relayer matching target/release/webb-relayer start program = \"/bin/systemctl restart webb-relayer\" stop program = \"/bin/systemctl kill webb-relayer\" if cpu > 90% for 20 cycles then exec \"/bin/systemctl stop webb-relayer\" and repeat every 10 cycles if cpu > 90% for 64 cycles then exec \"/bin/systemctl kill webb-relayer\" and repeat every 10 cycles if cpu > 90% for 64 cycles then alert if does not exist for 1 cycles then start restart monit and validate: sudo monit reload && sudo monit validate","title":"Monitoring Setup"},{"location":"relayer/websockets/","text":"The relayer is setup to receive WebSockets connections at the endpoint /ws . Clients can issue requests to the relayer by sending appropriately formatted data. Websockets Requests \u00b6 Send Transaction to EVM Network \u00b6 The most fundamental aspect of a relayer, is to send transactions on behalf of clients. relayWithdraw Data Formatting { evm: { chain: <string> contract: <string> proof: <string> root: <string> nullifierHash: <string> recipient: <string> relayer: <string> fee: <string> refund: <string> } } Field Explanations chain : The name of the chain to withdraw from. contract : The contract address to withdraw from. proof : The client-side generated proof from secret values. The proof should be generated with appropriate relayer and fee values from the info query. root : The historical merkle root for which the proof was constructed. nullifierHash : The hash of one of the secret values, nullifier, for which the mixer can mark a commitment as spent. recipient : The address for which the funds (denomination - fee) will be sent. relayer : The address for which the fee will be sent. fee : The amount to provide to the relayer. refund : Should be '0' for native tokens, and equivalent to the denomination for ERC20 mixers.","title":"WebSockets"},{"location":"relayer/websockets/#websockets-requests","text":"","title":"Websockets Requests"},{"location":"relayer/websockets/#send-transaction-to-evm-network","text":"The most fundamental aspect of a relayer, is to send transactions on behalf of clients. relayWithdraw Data Formatting { evm: { chain: <string> contract: <string> proof: <string> root: <string> nullifierHash: <string> recipient: <string> relayer: <string> fee: <string> refund: <string> } } Field Explanations chain : The name of the chain to withdraw from. contract : The contract address to withdraw from. proof : The client-side generated proof from secret values. The proof should be generated with appropriate relayer and fee values from the info query. root : The historical merkle root for which the proof was constructed. nullifierHash : The hash of one of the secret values, nullifier, for which the mixer can mark a commitment as spent. recipient : The address for which the funds (denomination - fee) will be sent. relayer : The address for which the fee will be sent. fee : The amount to provide to the relayer. refund : Should be '0' for native tokens, and equivalent to the denomination for ERC20 mixers.","title":"Send Transaction to EVM Network"},{"location":"repos/overview/","text":"There are quite a few repositories that work together to bring our Webb ecosystem to life: Webb Dapp \u00b6 Repo The Webb Dapp is the portal into the Webb. It is the frontend which allows end users to move their assets and retain their privacy. Relayer \u00b6 Repo It is non-trivial to get access to funds in two separate addresses without linking these two addresses. The relayer helps to facilitate privacy from an on-chain transaction perspective. Users send transactions for withdrawing from the ecosystem to the relayer, and the relayer executes these transactions. Webb.rs \u00b6 Repo Implementations of core Webb aspects in rust. Core pieces include data structures like merkle trees, hasher implementations like the pederson hash, EVM interaction with ethers.rs. Tornado Core \u00b6 Repo Forked from Tornado cash - core logic for EVM smart contract mixers. Javascript implementations of circuit and key generation. Scripts for interacting with these smart contracts. Protocol Solidity \u00b6 Repo Implementation of the Webb with private bridges inspired by chainsafe and generalized merkle trees that can accept a variety of hash functions. Anon \u00b6 Repo A substrate node which contains the merkle and mixer pallets. These pallets are built using ed25519 and bulletproofs precompiles. Arkworks Gadgets \u00b6 Repo Gadgets and constraints written using the arkworks libraries for Webb. Darkwebb \u00b6 Repo A substrate node using rust crates to build a parachain implementation of Webb. The darkwebb is a rearchitecting of the anon node to optimize for runtime blob size.","title":"Organisation Repos"},{"location":"repos/overview/#webb-dapp","text":"Repo The Webb Dapp is the portal into the Webb. It is the frontend which allows end users to move their assets and retain their privacy.","title":"Webb Dapp"},{"location":"repos/overview/#relayer","text":"Repo It is non-trivial to get access to funds in two separate addresses without linking these two addresses. The relayer helps to facilitate privacy from an on-chain transaction perspective. Users send transactions for withdrawing from the ecosystem to the relayer, and the relayer executes these transactions.","title":"Relayer"},{"location":"repos/overview/#webbrs","text":"Repo Implementations of core Webb aspects in rust. Core pieces include data structures like merkle trees, hasher implementations like the pederson hash, EVM interaction with ethers.rs.","title":"Webb.rs"},{"location":"repos/overview/#tornado-core","text":"Repo Forked from Tornado cash - core logic for EVM smart contract mixers. Javascript implementations of circuit and key generation. Scripts for interacting with these smart contracts.","title":"Tornado Core"},{"location":"repos/overview/#protocol-solidity","text":"Repo Implementation of the Webb with private bridges inspired by chainsafe and generalized merkle trees that can accept a variety of hash functions.","title":"Protocol Solidity"},{"location":"repos/overview/#anon","text":"Repo A substrate node which contains the merkle and mixer pallets. These pallets are built using ed25519 and bulletproofs precompiles.","title":"Anon"},{"location":"repos/overview/#arkworks-gadgets","text":"Repo Gadgets and constraints written using the arkworks libraries for Webb.","title":"Arkworks Gadgets"},{"location":"repos/overview/#darkwebb","text":"Repo A substrate node using rust crates to build a parachain implementation of Webb. The darkwebb is a rearchitecting of the anon node to optimize for runtime blob size.","title":"Darkwebb"}]}