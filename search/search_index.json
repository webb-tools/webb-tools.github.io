{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Webb We are building privacy tools for the multi-chain world. There are quite a few repositories that work together to bring our Webb ecosystem to life: Webb Dapp Repo The Webb Dapp is the portal into the Webb. It is the frontend which allows end users to move their assets and retain their privacy. Relayer Repo It is non-trivial to get access to funds in two separate addresses without linking these two addresses. The relayer helps to facilitate privacy from an on-chain transaction perspective. Users send transactions for withdrawing from the ecosystem to the relayer, and the relayer executes these transactions. Webb.rs Repo Implementations of core Webb aspects in rust. Core pieces include data structures like merkle trees, hasher implementations like the pederson hash, EVM interaction with ethers.rs. Tornado Core Repo Forked from Tornado cash - core logic for EVM smart contract mixers. Javascript implementations of circuit and key generation. Scripts for interacting with these smart contracts. Protocol Solidity Repo Implementation of the Webb with private bridges inspired by chainsafe and generalized merkle trees that can accept a variety of hash functions. Anon Repo A substrate node which contains the merkle and mixer pallets. These pallets are built using ed25519 and bulletproofs precompiles. Arkworks Gadgets Repo Gadgets and constraints written using the arkworks libraries for Webb. Darkwebb Repo A substrate node using rust crates to build a parachain implementation of Webb. The darkwebb is a rearchitecting of the anon node to optimize for runtime blob size.","title":"Home"},{"location":"#welcome-to-webb","text":"We are building privacy tools for the multi-chain world. There are quite a few repositories that work together to bring our Webb ecosystem to life:","title":"Welcome to Webb"},{"location":"#webb-dapp","text":"Repo The Webb Dapp is the portal into the Webb. It is the frontend which allows end users to move their assets and retain their privacy.","title":"Webb Dapp"},{"location":"#relayer","text":"Repo It is non-trivial to get access to funds in two separate addresses without linking these two addresses. The relayer helps to facilitate privacy from an on-chain transaction perspective. Users send transactions for withdrawing from the ecosystem to the relayer, and the relayer executes these transactions.","title":"Relayer"},{"location":"#webbrs","text":"Repo Implementations of core Webb aspects in rust. Core pieces include data structures like merkle trees, hasher implementations like the pederson hash, EVM interaction with ethers.rs.","title":"Webb.rs"},{"location":"#tornado-core","text":"Repo Forked from Tornado cash - core logic for EVM smart contract mixers. Javascript implementations of circuit and key generation. Scripts for interacting with these smart contracts.","title":"Tornado Core"},{"location":"#protocol-solidity","text":"Repo Implementation of the Webb with private bridges inspired by chainsafe and generalized merkle trees that can accept a variety of hash functions.","title":"Protocol Solidity"},{"location":"#anon","text":"Repo A substrate node which contains the merkle and mixer pallets. These pallets are built using ed25519 and bulletproofs precompiles.","title":"Anon"},{"location":"#arkworks-gadgets","text":"Repo Gadgets and constraints written using the arkworks libraries for Webb.","title":"Arkworks Gadgets"},{"location":"#darkwebb","text":"Repo A substrate node using rust crates to build a parachain implementation of Webb. The darkwebb is a rearchitecting of the anon node to optimize for runtime blob size.","title":"Darkwebb"},{"location":"mixer-protocols/tornado/contracts/","text":"Contracts The exposed APIs of tornado.cash-based solidity mixers for developer use. Interfaces IHasher The hasher for contracts in tornado core uses MiMC. It is generated from circom's mimcsponge_gencontract.js MiMCSponge Details Signature MiMCSponge(uint256 in_xL, uint256 in_xR) external pure returns (uint256 xL, uint256 xR) IVerifier The verifier exposes the verifyProof view function and is generated from the verifying key for the corresponding SNARK. verifyProof Details Signature verifyProof(bytes memory _proof, uint256[6] memory _input) external returns (bool) Contracts NativeAnchor.sol A concrete instance of a mixer which deals with the native currency of the chain. Constructor Details Signature constructor(IVerifier _verifier, IHasher _hasher, uint256 _denomination, uint256 _merkleTreeHeight) Anchor(_verifier, _hasher, _denomination, _merkleTreeHeight) {} Internal Functions _processWithdraw Details Signature _processWithdraw(address _recipient, address _relayer, uint256 _fee, uint256 _refund) internal override Requires require(msg.value == 0) require(_refund == 0) require(..., \"payment to _recipient did not go through\") require(..., \"payment to _relayer did not go through\") _processDeposit Details Signature _processDeposit() internal override Requires require(msg.value == denomination) Anchor.sol An abstract contract that requires child classes to implement appropriate verification and processes for deposits and withdrawals. Variables verifier Type: public immutable IVerifier denomination Type: public immutable uint32 nullifierHashes Type: public mapping(bytes32 => bool) commitments Type: public mapping(bytes32 => bool) Constructor Details Signature constructor(IVerifier _verifier, IHasher _hasher, uint256 _denomination, uint256 _treeHeight) MerkleTreeWithHistory(_merkleTreeHeight, _hasher) External Functions Calls to deposits require a commitment, which is a hash of some secret values. Deposit Details Signature deposit(bytes32 _commitment) Requires require(..., \"commitment has been submitted\") Emits Deposit Withdraw Details Signature withdraw(address _recipient, address _relayer, uint256 _fee, uint256 _refund) Requires require(_fee <= denomination) require(..., \"The not has already been spent\") require(..., \"Cannot find your merkle root\") require(..., \"Invalid withdraw proof\") Emits Withdraw View Functions isSpent Details Signature isSpent(bytes32 _nullifierHash) public view returns (bool) isSpentArray Details Signature isSpentArray(bytes32[] calldata _nullifierHashes) external view returns (bool[] memory spent) Events Deposit Signature : Deposit(bytes32 indexed commitment, uint32 leafIndex, uint256 timestamp) Withdraw Signature : Withdrawal(address to, bytes32 nullifierHash, address indexed relayer, uint256 fee) MerkleTreeWithHistory.sol Variables hasher Type: public immutable IHasher levels Type: public immutable uint32 filledSubtrees Type: public mapping(uint256 => bytes32) roots Type: public mapping(uint256 => bytes32) ROOT_HISTORY_SIZE Type: public constant uint32 currentRootIndex Type: public uint32 nextIndex Type: public uint32 Constructor Details Signature constructor(uint32 _levels, IHasher _hasher) Requires require(_levels > 0) require(_levels < 32) External Functions hashLeftRight Details Signature function hashLeftRight(IHasher _hasher, bytes32 _left, bytes32 _right) public pure returns (bytes32) Requires require(..., \"_left should be inside the field\") require(..., \"_right should be instide the field\") View Functions isKnownRoot Details Signature isKnownRoot(bytes32 _root) public view returns (bool) getLastRoot Details Signature getLastRoot() public view returns (bytes32) zeros Details Signature zeros(uint256 i) public pure returns (bytes32) Internal Functions _insert Details Signature _insert(bytes32 _leaf) internal returns (uint32 index) Requires require(..., \"merkle tree is full\")","title":"Contracts"},{"location":"mixer-protocols/tornado/contracts/#contracts","text":"The exposed APIs of tornado.cash-based solidity mixers for developer use.","title":"Contracts"},{"location":"mixer-protocols/tornado/contracts/#interfaces","text":"","title":"Interfaces"},{"location":"mixer-protocols/tornado/contracts/#ihasher","text":"The hasher for contracts in tornado core uses MiMC. It is generated from circom's mimcsponge_gencontract.js","title":"IHasher"},{"location":"mixer-protocols/tornado/contracts/#mimcsponge","text":"Details Signature MiMCSponge(uint256 in_xL, uint256 in_xR) external pure returns (uint256 xL, uint256 xR)","title":"MiMCSponge"},{"location":"mixer-protocols/tornado/contracts/#iverifier","text":"The verifier exposes the verifyProof view function and is generated from the verifying key for the corresponding SNARK.","title":"IVerifier"},{"location":"mixer-protocols/tornado/contracts/#verifyproof","text":"Details Signature verifyProof(bytes memory _proof, uint256[6] memory _input) external returns (bool)","title":"verifyProof"},{"location":"mixer-protocols/tornado/contracts/#contracts_1","text":"","title":"Contracts"},{"location":"mixer-protocols/tornado/contracts/#nativeanchorsol","text":"A concrete instance of a mixer which deals with the native currency of the chain.","title":"NativeAnchor.sol"},{"location":"mixer-protocols/tornado/contracts/#constructor","text":"Details Signature constructor(IVerifier _verifier, IHasher _hasher, uint256 _denomination, uint256 _merkleTreeHeight) Anchor(_verifier, _hasher, _denomination, _merkleTreeHeight) {}","title":"Constructor"},{"location":"mixer-protocols/tornado/contracts/#internal-functions","text":"","title":"Internal Functions"},{"location":"mixer-protocols/tornado/contracts/#_processwithdraw","text":"Details Signature _processWithdraw(address _recipient, address _relayer, uint256 _fee, uint256 _refund) internal override Requires require(msg.value == 0) require(_refund == 0) require(..., \"payment to _recipient did not go through\") require(..., \"payment to _relayer did not go through\")","title":"_processWithdraw"},{"location":"mixer-protocols/tornado/contracts/#_processdeposit","text":"Details Signature _processDeposit() internal override Requires require(msg.value == denomination)","title":"_processDeposit"},{"location":"mixer-protocols/tornado/contracts/#anchorsol","text":"An abstract contract that requires child classes to implement appropriate verification and processes for deposits and withdrawals.","title":"Anchor.sol"},{"location":"mixer-protocols/tornado/contracts/#variables","text":"","title":"Variables"},{"location":"mixer-protocols/tornado/contracts/#verifier","text":"Type: public immutable IVerifier","title":"verifier"},{"location":"mixer-protocols/tornado/contracts/#denomination","text":"Type: public immutable uint32","title":"denomination"},{"location":"mixer-protocols/tornado/contracts/#nullifierhashes","text":"Type: public mapping(bytes32 => bool)","title":"nullifierHashes"},{"location":"mixer-protocols/tornado/contracts/#commitments","text":"Type: public mapping(bytes32 => bool)","title":"commitments"},{"location":"mixer-protocols/tornado/contracts/#constructor_1","text":"Details Signature constructor(IVerifier _verifier, IHasher _hasher, uint256 _denomination, uint256 _treeHeight) MerkleTreeWithHistory(_merkleTreeHeight, _hasher)","title":"Constructor"},{"location":"mixer-protocols/tornado/contracts/#external-functions","text":"Calls to deposits require a commitment, which is a hash of some secret values.","title":"External Functions"},{"location":"mixer-protocols/tornado/contracts/#deposit","text":"Details Signature deposit(bytes32 _commitment) Requires require(..., \"commitment has been submitted\") Emits Deposit","title":"Deposit"},{"location":"mixer-protocols/tornado/contracts/#withdraw","text":"Details Signature withdraw(address _recipient, address _relayer, uint256 _fee, uint256 _refund) Requires require(_fee <= denomination) require(..., \"The not has already been spent\") require(..., \"Cannot find your merkle root\") require(..., \"Invalid withdraw proof\") Emits Withdraw","title":"Withdraw"},{"location":"mixer-protocols/tornado/contracts/#view-functions","text":"","title":"View Functions"},{"location":"mixer-protocols/tornado/contracts/#isspent","text":"Details Signature isSpent(bytes32 _nullifierHash) public view returns (bool)","title":"isSpent"},{"location":"mixer-protocols/tornado/contracts/#isspentarray","text":"Details Signature isSpentArray(bytes32[] calldata _nullifierHashes) external view returns (bool[] memory spent)","title":"isSpentArray"},{"location":"mixer-protocols/tornado/contracts/#events","text":"","title":"Events"},{"location":"mixer-protocols/tornado/contracts/#deposit_1","text":"Signature : Deposit(bytes32 indexed commitment, uint32 leafIndex, uint256 timestamp)","title":"Deposit"},{"location":"mixer-protocols/tornado/contracts/#withdraw_1","text":"Signature : Withdrawal(address to, bytes32 nullifierHash, address indexed relayer, uint256 fee)","title":"Withdraw"},{"location":"mixer-protocols/tornado/contracts/#merkletreewithhistorysol","text":"","title":"MerkleTreeWithHistory.sol"},{"location":"mixer-protocols/tornado/contracts/#variables_1","text":"","title":"Variables"},{"location":"mixer-protocols/tornado/contracts/#hasher","text":"Type: public immutable IHasher","title":"hasher"},{"location":"mixer-protocols/tornado/contracts/#levels","text":"Type: public immutable uint32","title":"levels"},{"location":"mixer-protocols/tornado/contracts/#filledsubtrees","text":"Type: public mapping(uint256 => bytes32)","title":"filledSubtrees"},{"location":"mixer-protocols/tornado/contracts/#roots","text":"Type: public mapping(uint256 => bytes32)","title":"roots"},{"location":"mixer-protocols/tornado/contracts/#root_history_size","text":"Type: public constant uint32","title":"ROOT_HISTORY_SIZE"},{"location":"mixer-protocols/tornado/contracts/#currentrootindex","text":"Type: public uint32","title":"currentRootIndex"},{"location":"mixer-protocols/tornado/contracts/#nextindex","text":"Type: public uint32","title":"nextIndex"},{"location":"mixer-protocols/tornado/contracts/#constructor_2","text":"Details Signature constructor(uint32 _levels, IHasher _hasher) Requires require(_levels > 0) require(_levels < 32)","title":"Constructor"},{"location":"mixer-protocols/tornado/contracts/#external-functions_1","text":"","title":"External Functions"},{"location":"mixer-protocols/tornado/contracts/#hashleftright","text":"Details Signature function hashLeftRight(IHasher _hasher, bytes32 _left, bytes32 _right) public pure returns (bytes32) Requires require(..., \"_left should be inside the field\") require(..., \"_right should be instide the field\")","title":"hashLeftRight"},{"location":"mixer-protocols/tornado/contracts/#view-functions_1","text":"","title":"View Functions"},{"location":"mixer-protocols/tornado/contracts/#isknownroot","text":"Details Signature isKnownRoot(bytes32 _root) public view returns (bool)","title":"isKnownRoot"},{"location":"mixer-protocols/tornado/contracts/#getlastroot","text":"Details Signature getLastRoot() public view returns (bytes32)","title":"getLastRoot"},{"location":"mixer-protocols/tornado/contracts/#zeros","text":"Details Signature zeros(uint256 i) public pure returns (bytes32)","title":"zeros"},{"location":"mixer-protocols/tornado/contracts/#internal-functions_1","text":"","title":"Internal Functions"},{"location":"mixer-protocols/tornado/contracts/#_insert","text":"Details Signature _insert(bytes32 _leaf) internal returns (uint32 index) Requires require(..., \"merkle tree is full\")","title":"_insert"},{"location":"mixer-protocols/tornado/deployments/","text":"Mixer Deployments If you'd like to interact with the mixers programmatically, we have live deployments at the contracts below. Rinkeby Name Source Address .1 ETH Mixer NativeAnchor.sol 0x626FEc5Ffa7Bf1EE8CEd7daBdE545630473E3ABb 1 ETH Mixer NativeAnchor.sol 0x979cBd4917e81447983ef87591B9E1ab21727a61 Hasher Hasher.json 0xE6C5D1c6cc3c6772694d75f61E949daB100a4489 Verifier Verifier.sol 0x95A5CcfCa50F7Dcf410CE397Bb7Becf1b42Ae601 Harmony Testnet Shard 1 Harmony shares Webb's vision of an interoperable future, and we are happy to have Harmony as one of our first supported chains. Name Source Address 100 ONE mixer NativeAnchor.sol 0x7cd1F52e5EEdf753e99D945276a725CE533AaD1a 1000 ONE mixer NativeAnchor.sol 0xD7f9BB9957100310aD397D2bA31771D939BD4731 10000 ONE mixer NativeAnchor.sol 0xeE2eB8F142e48e5D1bDD34e0924Ed3B4aa0d4222 100000 ONE mixer NativeAnchor.sol 0x7cd173094eF78FFAeDee4e14576A73a79aA716ac Hasher Hasher.json 0x96B8Bff1fE9a9c0656b84d7bd1013faD2435Edc0 Verifier Verifier.sol 0xca2c45fe334fBb9d9356AaB291842b964DB9B0E3 Beresheet EVM Edgeware is the first supported EVM in the substrate ecosystem. This ecosystem was born out of interoperable ideals. Name Source Address 100 tEDG mixer NativeAnchor.sol 0xc0d863EE313636F067dCF89e6ea904AD5f8DEC65 1000 tEDG mixer NativeAnchor.sol 0xc7c6152214d0Db4e161Fa67fB62811Be7326834A Hasher Hasher.json 0x96B8Bff1fE9a9c0656b84d7bd1013faD2435Edc0 Verifier Verifier.sol 0xca2c45fe334fBb9d9356AaB291842b964DB9B0E3","title":"Deployments"},{"location":"mixer-protocols/tornado/deployments/#mixer-deployments","text":"If you'd like to interact with the mixers programmatically, we have live deployments at the contracts below.","title":"Mixer Deployments"},{"location":"mixer-protocols/tornado/deployments/#rinkeby","text":"Name Source Address .1 ETH Mixer NativeAnchor.sol 0x626FEc5Ffa7Bf1EE8CEd7daBdE545630473E3ABb 1 ETH Mixer NativeAnchor.sol 0x979cBd4917e81447983ef87591B9E1ab21727a61 Hasher Hasher.json 0xE6C5D1c6cc3c6772694d75f61E949daB100a4489 Verifier Verifier.sol 0x95A5CcfCa50F7Dcf410CE397Bb7Becf1b42Ae601","title":"Rinkeby"},{"location":"mixer-protocols/tornado/deployments/#harmony-testnet-shard-1","text":"Harmony shares Webb's vision of an interoperable future, and we are happy to have Harmony as one of our first supported chains. Name Source Address 100 ONE mixer NativeAnchor.sol 0x7cd1F52e5EEdf753e99D945276a725CE533AaD1a 1000 ONE mixer NativeAnchor.sol 0xD7f9BB9957100310aD397D2bA31771D939BD4731 10000 ONE mixer NativeAnchor.sol 0xeE2eB8F142e48e5D1bDD34e0924Ed3B4aa0d4222 100000 ONE mixer NativeAnchor.sol 0x7cd173094eF78FFAeDee4e14576A73a79aA716ac Hasher Hasher.json 0x96B8Bff1fE9a9c0656b84d7bd1013faD2435Edc0 Verifier Verifier.sol 0xca2c45fe334fBb9d9356AaB291842b964DB9B0E3","title":"Harmony Testnet Shard 1"},{"location":"mixer-protocols/tornado/deployments/#beresheet-evm","text":"Edgeware is the first supported EVM in the substrate ecosystem. This ecosystem was born out of interoperable ideals. Name Source Address 100 tEDG mixer NativeAnchor.sol 0xc0d863EE313636F067dCF89e6ea904AD5f8DEC65 1000 tEDG mixer NativeAnchor.sol 0xc7c6152214d0Db4e161Fa67fB62811Be7326834A Hasher Hasher.json 0x96B8Bff1fE9a9c0656b84d7bd1013faD2435Edc0 Verifier Verifier.sol 0xca2c45fe334fBb9d9356AaB291842b964DB9B0E3","title":"Beresheet EVM"},{"location":"mixer-protocols/tornado/overview/","text":"Tornado Core The tornado core library defines a set of Solidity smart contracts for mixers. These contracts are used in the dapp for EVM interactions.","title":"Overview"},{"location":"mixer-protocols/tornado/overview/#tornado-core","text":"The tornado core library defines a set of Solidity smart contracts for mixers. These contracts are used in the dapp for EVM interactions.","title":"Tornado Core"},{"location":"relayer/http-endpoints/","text":"Exposed endpoints the client can query to obtain data about their exposed data, the relayer, or mixer deployments. API v1 IP Relayers can let the client know of their IP address. This is informative to the client, as their privacy is potentially compromised by this information. /api/v1/ip Response Format { \"ip\": <string> } Response Explanation The IP address from which the request was sent to the relayer. Info A client should make a call to the relayer to find which chains it supports, as well as the fees and relayer address to include in the proof generation. /api/v1/info Response Format { evm: { [networkName]: { \"withdrawFeePercentage\": <number>, \"account\": <string>, \"enable-leaves-watcher\": <boolean>, }, ... } } Response Explanation withdrawFeePercentage : The minimum amount of percentage that the relayer requires to send a transaction on the client's behalf. account : The reward account of the relayer, which will collect the fee. enable-leaves-watcher : A boolean flag indicating if the relayer is able to provide a client with the leaves that make up the merkle tree of a particular mixer. EVM Mixer Leaves A client can query the relayer for the leaves (commitments) of a mixer deployment. This information is necessary for building the merkle tree on the client side, in order to build the proof of secrets for a particular commitment. The client can query the blockchain directly, but getting the information from a relayer will be much quicker. /api/v1/leaves/{contractAddress} Response Format { \"leaves\": [ { \"commitment\": <string> }, ... ] } Response explanation The leaves will be properly indexed in the array.","title":"Http Endpoints"},{"location":"relayer/http-endpoints/#api-v1","text":"","title":"API v1"},{"location":"relayer/http-endpoints/#ip","text":"Relayers can let the client know of their IP address. This is informative to the client, as their privacy is potentially compromised by this information. /api/v1/ip Response Format { \"ip\": <string> } Response Explanation The IP address from which the request was sent to the relayer.","title":"IP"},{"location":"relayer/http-endpoints/#info","text":"A client should make a call to the relayer to find which chains it supports, as well as the fees and relayer address to include in the proof generation. /api/v1/info Response Format { evm: { [networkName]: { \"withdrawFeePercentage\": <number>, \"account\": <string>, \"enable-leaves-watcher\": <boolean>, }, ... } } Response Explanation withdrawFeePercentage : The minimum amount of percentage that the relayer requires to send a transaction on the client's behalf. account : The reward account of the relayer, which will collect the fee. enable-leaves-watcher : A boolean flag indicating if the relayer is able to provide a client with the leaves that make up the merkle tree of a particular mixer.","title":"Info"},{"location":"relayer/http-endpoints/#evm-mixer-leaves","text":"A client can query the relayer for the leaves (commitments) of a mixer deployment. This information is necessary for building the merkle tree on the client side, in order to build the proof of secrets for a particular commitment. The client can query the blockchain directly, but getting the information from a relayer will be much quicker. /api/v1/leaves/{contractAddress} Response Format { \"leaves\": [ { \"commitment\": <string> }, ... ] } Response explanation The leaves will be properly indexed in the array.","title":"EVM Mixer Leaves"},{"location":"relayer/overview/","text":"The Relayer offers the end-user privacy and receives fees from the users for providing this service. Relayers can be configured to listen to only the networks that they are interested in. Download the code and start supporting the network!","title":"Overview"},{"location":"relayer/websockets/","text":"The relayer is setup to receive WebSockets connections at the endpoint /ws . Clients can issue requests to the relayer by sending appropriately formatted data. Websockets Requests Send Transaction to EVM Network The most fundamental aspect of a relayer, is to send transactions on behalf of clients. relayWithdraw Data Formatting { evm: { [networkName]: { relayWithdraw: { contract: <string> proof: <string> root: <string> nullifierHash: <string> recipient: <string> relayer: <string> fee: <string> refund: <string> } } } } Field Explanations contract : The contract address to withdraw from proof : The client-side generated proof from secret values. The proof should be generated with appropriate relayer and fee values from the info query. root : The historical merkle root for which the proof was constructed. nullifierHash : The hash of one of the secret values, nullifier, for which the mixer can mark a commitment as spent. recipient : The address for which the funds (denomination - fee) will be sent. relayer : The address for which the fee will be sent. fee : The amount to provide to the relayer. refund : Should be '0' for native tokens, and equivalent to the denomination for ERC20 mixers.","title":"WebSockets"},{"location":"relayer/websockets/#websockets-requests","text":"","title":"Websockets Requests"},{"location":"relayer/websockets/#send-transaction-to-evm-network","text":"The most fundamental aspect of a relayer, is to send transactions on behalf of clients. relayWithdraw Data Formatting { evm: { [networkName]: { relayWithdraw: { contract: <string> proof: <string> root: <string> nullifierHash: <string> recipient: <string> relayer: <string> fee: <string> refund: <string> } } } } Field Explanations contract : The contract address to withdraw from proof : The client-side generated proof from secret values. The proof should be generated with appropriate relayer and fee values from the info query. root : The historical merkle root for which the proof was constructed. nullifierHash : The hash of one of the secret values, nullifier, for which the mixer can mark a commitment as spent. recipient : The address for which the funds (denomination - fee) will be sent. relayer : The address for which the fee will be sent. fee : The amount to provide to the relayer. refund : Should be '0' for native tokens, and equivalent to the denomination for ERC20 mixers.","title":"Send Transaction to EVM Network"}]}