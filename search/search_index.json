{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Webb \u00b6 Webb is an ecosystem of privacy protocols and products for a multi-chain world. In this site, you can find information about the protocols we are actively building, the open-source repos we maintain, and other privacy related research and ideas we aim to integrate into our community. Webb Protocol Webb Protocol Technical Roadmap For ways to contribute, join the discussion, or see active discussion of ideas and updates of this project, check out our Webb community forum that also features links to our Telegram, Discord, and more. Webb Community Forum Webb Tools Github Webb Community Telegram Webb Community Discord Philosophy & Ethos \u00b6 We believe that privacy is a fundamental human right and that this needs to extend into the blockchain space sooner rather than later. On blockchain platforms today, we continually expose our data when we participate in the myriad of protocols that exist in the multi-chain world. We move assets across chains to buy NFTs, pay our contributors and employees in cryptocurrency, invest w/ cryptocurrency, and generate large amounts of data that can be mined by anyone with an internet connection. Our mission is to change this by contributing to the growing amount of privacy tools that exist on blockchains today. We are motivated by cross-chain user behavior and want to tackle cross-chain privacy first. You can find more info about our cross-chain protocols in the Bridge Protocol section of the docs site. Where is privacy missing today \u00b6 Privacy is lacking in a variety of places in our current blockchain ecosystem. We don't have: 1. Privacy-preserving asset transfer across chains. 2. Privacy-preserving RPC infrastructure for users of protocols. 3. Privacy-preserving custody and exchanges w/ meaningful liquidity. The first item is what we are tackling with the Webb bridge protocol. It is an interoperable, zero-knowledge proof based cross-chain system for privately moving assets between blockchains. It is a Privacy-as-a-Service protocol that unifies assets under consistent, interoperable representations to scale privacy sets as large as possible. We are working on a fixed-sized deposit based system and plan to build out a fully shielded, interoperable protocol in the future. The second item is what we will tackle next first on top of the Webb bridge protocol. We aim to make privacy infrastructure easily deployable and easily usable by end products. When users of zero-knowledge-based, privacy protocols generate their zero-knowledge proofs, they need to possess private inputs. Oftentimes, retrieving the necessary private inputs requires querying public infrastructure, which exposes the user's privacy. The solution in theory is simple and harder in practice; we need to build private information retrieval systems for these datasets. As the Webb system launches and grows, we will begin integrating private information retrieval into our infrastructure. The third item is an active research area for our project. With a private bridge protocol, it becomes possible to build novel multi-party protocols on top. We are actively investigating building privacy-preserving decentralised exchanges over the Webb bridge. These protocols can leverage advances in multi-party computation to provide both novel custody solutions of shielded assets as well as dark-pool functionality over our Webb architecture. Contributing \u00b6 If any of the ideas laid out here are interesting, don't hesitate to reach out on our community channels or post interesting ideas/articles on our community forum. All constructive types of contributions are welcome!","title":"Home"},{"location":"#welcome-to-webb","text":"Webb is an ecosystem of privacy protocols and products for a multi-chain world. In this site, you can find information about the protocols we are actively building, the open-source repos we maintain, and other privacy related research and ideas we aim to integrate into our community. Webb Protocol Webb Protocol Technical Roadmap For ways to contribute, join the discussion, or see active discussion of ideas and updates of this project, check out our Webb community forum that also features links to our Telegram, Discord, and more. Webb Community Forum Webb Tools Github Webb Community Telegram Webb Community Discord","title":"Welcome to Webb"},{"location":"#philosophy-ethos","text":"We believe that privacy is a fundamental human right and that this needs to extend into the blockchain space sooner rather than later. On blockchain platforms today, we continually expose our data when we participate in the myriad of protocols that exist in the multi-chain world. We move assets across chains to buy NFTs, pay our contributors and employees in cryptocurrency, invest w/ cryptocurrency, and generate large amounts of data that can be mined by anyone with an internet connection. Our mission is to change this by contributing to the growing amount of privacy tools that exist on blockchains today. We are motivated by cross-chain user behavior and want to tackle cross-chain privacy first. You can find more info about our cross-chain protocols in the Bridge Protocol section of the docs site.","title":"Philosophy &amp; Ethos"},{"location":"#where-is-privacy-missing-today","text":"Privacy is lacking in a variety of places in our current blockchain ecosystem. We don't have: 1. Privacy-preserving asset transfer across chains. 2. Privacy-preserving RPC infrastructure for users of protocols. 3. Privacy-preserving custody and exchanges w/ meaningful liquidity. The first item is what we are tackling with the Webb bridge protocol. It is an interoperable, zero-knowledge proof based cross-chain system for privately moving assets between blockchains. It is a Privacy-as-a-Service protocol that unifies assets under consistent, interoperable representations to scale privacy sets as large as possible. We are working on a fixed-sized deposit based system and plan to build out a fully shielded, interoperable protocol in the future. The second item is what we will tackle next first on top of the Webb bridge protocol. We aim to make privacy infrastructure easily deployable and easily usable by end products. When users of zero-knowledge-based, privacy protocols generate their zero-knowledge proofs, they need to possess private inputs. Oftentimes, retrieving the necessary private inputs requires querying public infrastructure, which exposes the user's privacy. The solution in theory is simple and harder in practice; we need to build private information retrieval systems for these datasets. As the Webb system launches and grows, we will begin integrating private information retrieval into our infrastructure. The third item is an active research area for our project. With a private bridge protocol, it becomes possible to build novel multi-party protocols on top. We are actively investigating building privacy-preserving decentralised exchanges over the Webb bridge. These protocols can leverage advances in multi-party computation to provide both novel custody solutions of shielded assets as well as dark-pool functionality over our Webb architecture.","title":"Where is privacy missing today"},{"location":"#contributing","text":"If any of the ideas laid out here are interesting, don't hesitate to reach out on our community channels or post interesting ideas/articles on our community forum. All constructive types of contributions are welcome!","title":"Contributing"},{"location":"bridge-protocols/webb/architecture/","text":"The Webb protocol architecture is modelled off the ChainBridge and Tornado Cash architectures. We merge and augment both protocols and increase the relayer responsibilities to design our private bridge protocol. The modifications can be summarized as: Augmenting Tornado's into Anchor's which additionally track an edge list to other Anchors. Anchors are private transaction systems that function both as Tornados but also as cross-chain bridges. Anchors use a zero-knowledge one-of-many merkle tree membership proof instead of one for a single merkle tree. Anchors can mint/burn the underlying token being deposited and withdrawn. Augmenting ChainBridge's Bridge into a private bridge protocol. We create a new AnchorHandler which modifiers the edge list of Anchors needing updates. We augment the Bridge relayers w/ a multi-party threshold signing scheme, so that one or many threshold networks can govern the bridge. Example diagram of the architecture and governance of cross chain private bridging of WEBB tokens on EVM chains: Definitions \u00b6 commitment \u00b6 A commitment is generated upon a users deposit into an anchor and later used in a ZK proof for withdrawal. The commitment is the PoseidonHash(DestinationChainID + nullifier + secret) . DestinationChainID is a user input indicating the chain they will withdraw on. neighborRoots \u00b6 Every LinkableAnchor stores its neighborRoots , a mapping containing the merkle roots of the anchors it is connected to. Each anchor stores a history of 30 roots, so users can verify against a historical root while new deposits occur. resourceID \u00b6 resourceID 's provide a chain agnostic identifier to connect tokens with the handlers and anchors that interact with that token. A resourceID for a given token and denomination is defined as the hash of that token name concatenated with its denomination. The resourceID for a token used in public bridging that is not tied to a denomination will simply be the hash of its token name. Main System Components \u00b6 Anchor \u00b6 Anchor s are augmented Tornado Cash Tornados that possess graph-like data structures and functionality; that is, they can be connected and have edges. Users interact with Anchors through a deposit/withdraw API. To deposit into a Webb Anchor, a user generates a hashed commitment and submits this to the Anchor's merkle tree for insertion. The commitment contains the chainID of the chain they wish to withdraw on as well as some secret data. Bridge \u00b6 The Bridge contract allows for both fixed denomination, private bridging and standard, public bridging of assets. The private bridging functionality uses an AnchorHandler to track the state of connected chains while the standard bridging uses an ERC20Handler . The Bridge's state is is maintained by a set of relayers through voting. These relayers vote to update the latest merkle roots of connected anchors in the case of private bridging, and to distribute bridged assets in the case of public bridging. AnchorHandler \u00b6 Every Bridge contract has a corresponding AnchorHandler to add or update the neighborRoots of the anchors on that chain after relayers pass and execute a proposals containing connected anchors' root updates. The Handler updates a specific anchor based on a mapping of a resourceID to a LinkableAnchor contract address which is set by the Bridge admin. ERC20Handler \u00b6 Every Bridge contract has a corresponding ERC20Handler to keep track of deposits on a connected bridge. This allows the user to bridge tokens publicly and a fixed denomination as seen in standard bridges. See Chainbridge's Documentation for more detail on this standard bridge architecture.","title":"Architecture"},{"location":"bridge-protocols/webb/architecture/#definitions","text":"","title":"Definitions"},{"location":"bridge-protocols/webb/architecture/#commitment","text":"A commitment is generated upon a users deposit into an anchor and later used in a ZK proof for withdrawal. The commitment is the PoseidonHash(DestinationChainID + nullifier + secret) . DestinationChainID is a user input indicating the chain they will withdraw on.","title":"commitment"},{"location":"bridge-protocols/webb/architecture/#neighborroots","text":"Every LinkableAnchor stores its neighborRoots , a mapping containing the merkle roots of the anchors it is connected to. Each anchor stores a history of 30 roots, so users can verify against a historical root while new deposits occur.","title":"neighborRoots"},{"location":"bridge-protocols/webb/architecture/#resourceid","text":"resourceID 's provide a chain agnostic identifier to connect tokens with the handlers and anchors that interact with that token. A resourceID for a given token and denomination is defined as the hash of that token name concatenated with its denomination. The resourceID for a token used in public bridging that is not tied to a denomination will simply be the hash of its token name.","title":"resourceID"},{"location":"bridge-protocols/webb/architecture/#main-system-components","text":"","title":"Main System Components"},{"location":"bridge-protocols/webb/architecture/#anchor","text":"Anchor s are augmented Tornado Cash Tornados that possess graph-like data structures and functionality; that is, they can be connected and have edges. Users interact with Anchors through a deposit/withdraw API. To deposit into a Webb Anchor, a user generates a hashed commitment and submits this to the Anchor's merkle tree for insertion. The commitment contains the chainID of the chain they wish to withdraw on as well as some secret data.","title":"Anchor"},{"location":"bridge-protocols/webb/architecture/#bridge","text":"The Bridge contract allows for both fixed denomination, private bridging and standard, public bridging of assets. The private bridging functionality uses an AnchorHandler to track the state of connected chains while the standard bridging uses an ERC20Handler . The Bridge's state is is maintained by a set of relayers through voting. These relayers vote to update the latest merkle roots of connected anchors in the case of private bridging, and to distribute bridged assets in the case of public bridging.","title":"Bridge"},{"location":"bridge-protocols/webb/architecture/#anchorhandler","text":"Every Bridge contract has a corresponding AnchorHandler to add or update the neighborRoots of the anchors on that chain after relayers pass and execute a proposals containing connected anchors' root updates. The Handler updates a specific anchor based on a mapping of a resourceID to a LinkableAnchor contract address which is set by the Bridge admin.","title":"AnchorHandler"},{"location":"bridge-protocols/webb/architecture/#erc20handler","text":"Every Bridge contract has a corresponding ERC20Handler to keep track of deposits on a connected bridge. This allows the user to bridge tokens publicly and a fixed denomination as seen in standard bridges. See Chainbridge's Documentation for more detail on this standard bridge architecture.","title":"ERC20Handler"},{"location":"bridge-protocols/webb/deployments/","text":"Anchor Deployments \u00b6 At the moment there are no live deployments of the anchors.","title":"Deployments"},{"location":"bridge-protocols/webb/deployments/#anchor-deployments","text":"At the moment there are no live deployments of the anchors.","title":"Anchor Deployments"},{"location":"bridge-protocols/webb/governance/","text":"Governance \u00b6 Governance on Webb is key to maintaining and increasing the functionality of the protocol for WEBB tokenholders, protocol users, and relayers. Possible governance actions and their corresponding locations are as follows. WEBB Token Governance \u00b6 The WEBB token is used to govern various parts of the Webb protocol deployments. The WEBB token has its own set of bridges for various sizes of deposits that enables holders to move their tokens between supported chains. Anytime a new chain is added to the Webb Network, a corresponding bridge and WEBB token will instantiated for future governance usage. WEBB Governance Proposal Types \u00b6 WEBB tokens will be used to vote on proposals including but not limited to: deploying new anchor contracts, connecting anchors to handlers, connecting handlers to bridges, and whitelisting wrappable assets (see Wrapper Governance Functionality for details). The first three parts of the previous list are all essential to the deployment of new anchors and invoke WEBB token holders to govern these processes using WEBB on the deployed anchor's native chain. The whitelisting of wrappable assets will also take place on the chain where the token wrapper has been deployed. Anchor Deployment on a New Chain Using Governor Bravo \u00b6 In advance, the Webb community will deploy the WEBB token, Gov Bravo, Bridge, Handlers, and AnchorFactory on chains desireable for later anchor deployment. The Bridge will be connected to the ERC20Handler to enable public, standard bridging of WEBB. WEBB holders bridge their existing WEBB to the new chain. WEBB holders vote and execute a proposal to connect the Bridge and Handler calling the Bridge's setResourceID() . WEBB holders vote and execute a proposal to deploy a new anchor using the AnchorFactory. WEBB holders vote and execute a proposal to set the Handler of the newly deployed anchor. The anchor now enables private, cross-chain bridging.","title":"Governance"},{"location":"bridge-protocols/webb/governance/#governance","text":"Governance on Webb is key to maintaining and increasing the functionality of the protocol for WEBB tokenholders, protocol users, and relayers. Possible governance actions and their corresponding locations are as follows.","title":"Governance"},{"location":"bridge-protocols/webb/governance/#webb-token-governance","text":"The WEBB token is used to govern various parts of the Webb protocol deployments. The WEBB token has its own set of bridges for various sizes of deposits that enables holders to move their tokens between supported chains. Anytime a new chain is added to the Webb Network, a corresponding bridge and WEBB token will instantiated for future governance usage.","title":"WEBB Token Governance"},{"location":"bridge-protocols/webb/governance/#webb-governance-proposal-types","text":"WEBB tokens will be used to vote on proposals including but not limited to: deploying new anchor contracts, connecting anchors to handlers, connecting handlers to bridges, and whitelisting wrappable assets (see Wrapper Governance Functionality for details). The first three parts of the previous list are all essential to the deployment of new anchors and invoke WEBB token holders to govern these processes using WEBB on the deployed anchor's native chain. The whitelisting of wrappable assets will also take place on the chain where the token wrapper has been deployed.","title":"WEBB Governance Proposal Types"},{"location":"bridge-protocols/webb/governance/#anchor-deployment-on-a-new-chain-using-governor-bravo","text":"In advance, the Webb community will deploy the WEBB token, Gov Bravo, Bridge, Handlers, and AnchorFactory on chains desireable for later anchor deployment. The Bridge will be connected to the ERC20Handler to enable public, standard bridging of WEBB. WEBB holders bridge their existing WEBB to the new chain. WEBB holders vote and execute a proposal to connect the Bridge and Handler calling the Bridge's setResourceID() . WEBB holders vote and execute a proposal to deploy a new anchor using the AnchorFactory. WEBB holders vote and execute a proposal to set the Handler of the newly deployed anchor. The anchor now enables private, cross-chain bridging.","title":"Anchor Deployment on a New Chain Using Governor Bravo"},{"location":"bridge-protocols/webb/overview/","text":"Webb Protocol \u00b6 The Webb protocol is a private bridge protocol building on top of the chainbridge and Tornado cash protocols. It combines these architectures to create an interoperable privacy set to enable cross-chain private transactions with scalable privacy. More tokens on a particular bridge and more chains connected on a particular bridge only serve to increase the amount of privacy provided by that particular bridge. Bridge Functionality - Roadmap \u00b6 A privacy bridge provides a novel primitive for constructing private applications on top. While we consider a private bridge protocol for asset transfers below, we can also consider generalizations of this to build interoperable and private applications. The buildout of non-financial components of the protocol are not roadmapped but may be worked on in the future, at hackathons, and more. We aim to build out a private bridge protocol for asset transfers in stages, starting with the most primitive use case of transferring and targetting extensions that compose nicely with existing DeFi primitives such as yield aggregators and lending solutions. Version 1 - Shared privacy bridge functionality \u00b6 The first functionality of the protocol is cross-chain, private bridging of Webb wrapped assets. The goal here is to simply provide a protocol for wrapping a base, origin asset into a Webb wrapped asset that can be transferred privately across chains. Version 1.X - Governance functionality \u00b6 The second functionality of the protocol is to integrate governance functionality to allow Webb tokenholders to govern the set of whitelisted origin assets that can be wrapped into a particular bridge's Webb wrapped asset. This is motivated primarily by the ability to scale privacy sets across tokens by aggregating and unifying similar liquidity under a common representation, e.g. the particular Webb wrapped asset. Version 2 - Stable Swap bridges \u00b6 With basic functionality and governance in tact, we can create a cross-chain stable swapping pool. We aim to go live with this architecture after the previous versions are built out. Version 3 - Yield Delegation \u00b6 With an expressive infrastructure in tact, we can continue to expand the scope of what's possible with these interoperable, privacy sets. This bridge protocol allows users to earn yield while contributing to a compatible yield-bearing privacy set. The goal here is to lend out the underlying liquidity to DeFi protocols on each side of the bridge, taking on more risk and also earning more yield in the form of other DeFi assets. Relayer Functionality - Roadmap \u00b6 Bridges are networked applications that span multiple blockchains and must be aware of events and/or state occurring across this network. The endponts of these bridges (e.g. the smart contracts / core protocol logic) are denoted Anchors in our system. These Anchors are required by definition to know about various parts of the state of other anchors, particularly the ones they're connected to across a particular bridge. The backbone of any bridge is made up of the relayers -- otherwise denomted validators, relayers, authorities, nodes, etc. -- that maintain the liveliness of the bridge protocol. Relayers, as their name entails, relay information for a connected set of Anchors on a bridge. This information is then used to update the state of each Anchor and allow applications to reference, both privately and potentially not, properties of data stored across the other connected Anchors. We aim to build a relayer infrastructure that gradually improves in its performance, efficiency, and overall security. We do this in stages by first building the necessary infrastructure to listen to events across a connected set of Anchors and react properly across a Bridge to preserve the liveness of the protocol. Version 1 - Multi-sig governance functionality \u00b6 The first iteration of the bridge relayer is responsible for event listening and transaction execution. - Event listening across a set of connected anchors to learn of new deposits on a Bridge. - Proposal creation and vote submission over the Bridge's governance process. - Data replication and an API for inspecting Anchor state off-chain. Version 2 - Multi-party Threshold governance functionality \u00b6 We then plan to integrate a DKG into a Substrate node for future governance purposes. - Direct integration into a (currently) Substrate chain or potentially other blockchain node (Cosmos-SDK) - Bootstraps off existing validator set and participates in consensus. - Execution of a distributed key generation protocol to generate a threshold key. Version 3 - Auxiliary staking and punishment functionality \u00b6 We will integrate the DKG directly into the Bridge governance system, allowing the bridge to be governed by a threshold key (or many). - Integrate staking mechanism over finality authorities for registering local key matter. - Integrate punishment mechanism over improper behavior in the DKG. - Develop an on-chain pallet to govern the threshold and generate threshold signatures of Bridge.sol governance transactions.","title":"Overview"},{"location":"bridge-protocols/webb/overview/#webb-protocol","text":"The Webb protocol is a private bridge protocol building on top of the chainbridge and Tornado cash protocols. It combines these architectures to create an interoperable privacy set to enable cross-chain private transactions with scalable privacy. More tokens on a particular bridge and more chains connected on a particular bridge only serve to increase the amount of privacy provided by that particular bridge.","title":"Webb Protocol"},{"location":"bridge-protocols/webb/overview/#bridge-functionality-roadmap","text":"A privacy bridge provides a novel primitive for constructing private applications on top. While we consider a private bridge protocol for asset transfers below, we can also consider generalizations of this to build interoperable and private applications. The buildout of non-financial components of the protocol are not roadmapped but may be worked on in the future, at hackathons, and more. We aim to build out a private bridge protocol for asset transfers in stages, starting with the most primitive use case of transferring and targetting extensions that compose nicely with existing DeFi primitives such as yield aggregators and lending solutions.","title":"Bridge Functionality - Roadmap"},{"location":"bridge-protocols/webb/overview/#version-1-shared-privacy-bridge-functionality","text":"The first functionality of the protocol is cross-chain, private bridging of Webb wrapped assets. The goal here is to simply provide a protocol for wrapping a base, origin asset into a Webb wrapped asset that can be transferred privately across chains.","title":"Version 1 - Shared privacy bridge functionality"},{"location":"bridge-protocols/webb/overview/#version-1x-governance-functionality","text":"The second functionality of the protocol is to integrate governance functionality to allow Webb tokenholders to govern the set of whitelisted origin assets that can be wrapped into a particular bridge's Webb wrapped asset. This is motivated primarily by the ability to scale privacy sets across tokens by aggregating and unifying similar liquidity under a common representation, e.g. the particular Webb wrapped asset.","title":"Version 1.X - Governance functionality"},{"location":"bridge-protocols/webb/overview/#version-2-stable-swap-bridges","text":"With basic functionality and governance in tact, we can create a cross-chain stable swapping pool. We aim to go live with this architecture after the previous versions are built out.","title":"Version 2 - Stable Swap bridges"},{"location":"bridge-protocols/webb/overview/#version-3-yield-delegation","text":"With an expressive infrastructure in tact, we can continue to expand the scope of what's possible with these interoperable, privacy sets. This bridge protocol allows users to earn yield while contributing to a compatible yield-bearing privacy set. The goal here is to lend out the underlying liquidity to DeFi protocols on each side of the bridge, taking on more risk and also earning more yield in the form of other DeFi assets.","title":"Version 3 - Yield Delegation"},{"location":"bridge-protocols/webb/overview/#relayer-functionality-roadmap","text":"Bridges are networked applications that span multiple blockchains and must be aware of events and/or state occurring across this network. The endponts of these bridges (e.g. the smart contracts / core protocol logic) are denoted Anchors in our system. These Anchors are required by definition to know about various parts of the state of other anchors, particularly the ones they're connected to across a particular bridge. The backbone of any bridge is made up of the relayers -- otherwise denomted validators, relayers, authorities, nodes, etc. -- that maintain the liveliness of the bridge protocol. Relayers, as their name entails, relay information for a connected set of Anchors on a bridge. This information is then used to update the state of each Anchor and allow applications to reference, both privately and potentially not, properties of data stored across the other connected Anchors. We aim to build a relayer infrastructure that gradually improves in its performance, efficiency, and overall security. We do this in stages by first building the necessary infrastructure to listen to events across a connected set of Anchors and react properly across a Bridge to preserve the liveness of the protocol.","title":"Relayer Functionality - Roadmap"},{"location":"bridge-protocols/webb/overview/#version-1-multi-sig-governance-functionality","text":"The first iteration of the bridge relayer is responsible for event listening and transaction execution. - Event listening across a set of connected anchors to learn of new deposits on a Bridge. - Proposal creation and vote submission over the Bridge's governance process. - Data replication and an API for inspecting Anchor state off-chain.","title":"Version 1 - Multi-sig governance functionality"},{"location":"bridge-protocols/webb/overview/#version-2-multi-party-threshold-governance-functionality","text":"We then plan to integrate a DKG into a Substrate node for future governance purposes. - Direct integration into a (currently) Substrate chain or potentially other blockchain node (Cosmos-SDK) - Bootstraps off existing validator set and participates in consensus. - Execution of a distributed key generation protocol to generate a threshold key.","title":"Version 2 - Multi-party Threshold governance functionality"},{"location":"bridge-protocols/webb/overview/#version-3-auxiliary-staking-and-punishment-functionality","text":"We will integrate the DKG directly into the Bridge governance system, allowing the bridge to be governed by a threshold key (or many). - Integrate staking mechanism over finality authorities for registering local key matter. - Integrate punishment mechanism over improper behavior in the DKG. - Develop an on-chain pallet to govern the threshold and generate threshold signatures of Bridge.sol governance transactions.","title":"Version 3 - Auxiliary staking and punishment functionality"},{"location":"bridge-protocols/webb/technical-roadmap/","text":"Technical Roadmap \u00b6 Overview \u00b6 The Webb protocol is the first protocol built by Webb Technologies. It is a non-custodial private bridge protocol that uses smart contracts to bootstrap a zero-knowledge bridge. It is designed to work in all possible smart contracting environments. The current working repos for this protocol are targeting the EVM & Rust based chains such as Substrate. https://github.com/webb-tools/protocol-solidity https://github.com/webb-tools/protocol-substrate Goals \u00b6 The goals for the protocol are to grow into a trustless, private bridge overlying existing cross-chain communication protocols such as Polkadot's XCMP, Cosmos's IBC, or Celo's Optics. We will use the following checklist to track network deployments. [ ] Ethereum - as a smart contract [ ] Polkadot - as a smart contract or parachain [ ] Kusama - as a smart contract or parachain [ ] Harmony - as a smart contract or comsos-sdk chain [ ] Edgeware - as a smart contract or pallet [ ] Cosmos - as a smart contract or cosmos-sdk chain [ ] Celo - as a smart contract [ ] Polygon - as a smart contract [ ] Solana - as a smart contract Protocol Implementations \u00b6 We will use the following checklist to track protocol implementations [ ] Solidity [ ] Rust [ ] Golang [ ] Leo [ ] Cairo [ ] Ink! Objectives - Q3 2021 \u00b6 A test EVM bridge deployment can be made between Ethereum, Edgeware, and Harmony's test networks. Networks with instability will be exchanged or removed from the bridge if needed. In order to do so we need: [ ] protocol-solidity v1 protocol [ ] relayer v2 w/ Webb protocol support [ ] protocol-substrate v1 protocol [ ] Upon completion of first two milestones, deploy a small capped bridge at $10,000 approximate value on each side. protocol-solidity v1 \u00b6 Necessary items before deploying the bridge [ ] Add governable wrapping limit, denote by LimitedGovernedTokenWrapper . [ ] Integration tests on a single chain [ ] Deploy 2 bridges, 2 comp tokens, 2 anchors, 2 governor bravos on the same chain [ ] Case 1: Repeat steps 2-5 for each bridge: Deploy GovernedTokenWrapper1, GovernedTokenWrapper2 Deploy a mock Token Add Token . address to GovernedTokenWrapper1 . tokens Deploy LinkableERC20Anchor with GovernedTokenWrapper1 as the ERC20. Deposit Create a note that commits to withdraw on the bridge that was not deposited into. Deposit x tokens into one bridge, record the note . Deposit T more random notes into both sides of the bridge. Withdraw Generate the zero-knowledge proof for withdrawal Collect roots of each anchor Collect merkle membership proof for anchor deposited into Generate witness . Submit witness to the anchor on the \"other side of the bridge\". Submit tx w/ proof to the destination bridge. Mint tokens if no available liquidity is in the locked_pool . Verify balance updates in each respective token. Unwrap Deploy a mock UnwrappingToken . Add UnwrappingToken . address to GovernedTokenWrapper2 . tokens relayer v1 \u00b6 Relayer v2 is geared towards including chainbridge governance functionality. This means functionality for voting, closing, and executing proposals to update edges on the bridge. We want to test this with a sufficient relayer network and proposal passing threshold. [ ] Deploy relayer v1 to test networks: Rinkeby, Harmony Shard 1, Edgeware Beresheet. Chainbridge governance: [ ] Listen to events on both bridges. On receive event, pass to state machine and return a transaction / call State machine should update inner state and remove transactions that get executed by other relayers. If transaction, add to a queue. If call, execute. Pull from queue using a random number generator with a TBD distribution. If transaction. execute. [ ] Define strategy builder class for building voting strategies. Use a state machine and local storage Strategies for honest and greedy execution. Transaction Relayer [ ] Integration tests on all chains participating on the bridge [ ] Deployment as described above in protocol-solidity v1 . [ ] Case 1: Relayer actions are executed in intervals of k seconds Expose an api: /api/v2/relay for clients to relay TXes through. On received TX, Verify & validate it natively. Store in a queue . Every k seconds, pull a batch of TXes from the queue . Submit them to the chain. protocol-substrate v1 \u00b6 The Substrate implementation of the protocol should follow from protocol-solidity . [ ] Integrate chainbridge-substrate to the repo. [ ] Develop Anchor pallet. Bridge gadget using circom-compatible Poseidon . Graph functionality with access-control for Bridge/Handler pallet. Ability to add edge if called by governor/bridge Ability to update edge if called by governor/bridge [ ] Integration of chainbridge-substrate w/ Anchor pallet tests [ ] Define two Anchor pallets and two chainbridge-substrate bridges. Ensure this can be done with the architecture (e.g. using instances) [ ] Full integration tests with relayer v3 . Objectives - Q4 2021 \u00b6 A test Substrate \u2190 \u2192 EVM bridge deployment can be made between Ethereum, Edgeware (Frontier), and Substrate networks like Kusama, Polkadot. For this to be possible, we need to extend relayer functionality to support Substrate's chainbridge governance and serve as an oracle over the merkle roots of our protocol's merkle trees. [ ] relayer v2-3 w/ chainbridge-substrate governance & bridge tx relayer for Substrate [ ] protocol-substrate v2 protocol [ ] dkg-gadget v1 protocol relayer v2 - v3 \u00b6 Once protocol-substrate v1 is built we can begin building the integration into the relayer v2 . This means integrating chainbridge-substrate governance and transaction relaying system for bridge transactions on Substrate networks into the service. protocol-substrate v1.X \u00b6 We want to position the Substrate side of the network to provide various privacy services that augment the functionality of the bridge and complete useful revenue generating tasks. These tasks can range in the future from various distributed custody, social key recovery, and private information retrieval services. [ ] Integrate relayer v2 into the protocol-substrate service.rs . [ ] Develop Relayer Election pallet [ ] Proof of Authority system at genesis [ ] Proof of stake elected system at first upgrade [ ] Relayers register w/ necessary metadata Reward address IP / IPFS multihash / P2P node address / validator keys [ ] Develop DKG pallet. [ ] Store necessary metadata in pallet storage. protocol-substrate/dkg-gadget v1 \u00b6 A DKG for Webb can become a critical piece of our scalability and network value. We initially are motivated by using a DKG protocol to generate a threshold keypair that can be used to govern the anchor deployments. [ ] Design gossip protocol for running the DKG. [ ] Integrate DKG as separate p2p worker running alongside consensus mechanism. [ ] Add support for multiple DKGs if reasonable (depending on ability to generalise). [ ] Add functionality for: [ ] Signing ETH transactions for chainbridge-solidity governance. [ ] Signing Substrate transactions for chainbridge-substrate governance. Objectives - Q1 2022 \u00b6 Launching of parachains & live (capped) deployments for various tokens in the ecosystem: [ ] Deployments: [ ] Stablecoin sets: USDC / DAI [ ] BTC sets: WBTC / TBTC / InterBTC [ ] zk-gadgets - PLONK gadgets, updating setup, and dynamically configurable bridge. [ ] Webb Protocol v2 protocol implementation in Solidity and Substrate/Rust. deployments \u00b6 Deployments to various networks should occur with a limited initial liquidity. Initial liquidity providers will govern the limit thereafter. zk-gadgets \u00b6 PLONK for the circom circuits. Other updatable setups for arkworks circuits (whether Marlin works or PLONK needs to be built). protocol-solidity / protocol-substrate v2 \u00b6 V2 comes with an upgrade to our zero-knowledge infrastructure by integrating PLONK as the targetted prover/verifier. We mainly want to work with updatable setups to build an updatable and dynamic bridge. Additionally, we want to research and plan for a way to tackle a variable deposit, interoperable shielded pool, which will likely depend on Halo2 or similarly recursive proving schemes.","title":"Technical Roadmap"},{"location":"bridge-protocols/webb/technical-roadmap/#technical-roadmap","text":"","title":"Technical Roadmap"},{"location":"bridge-protocols/webb/technical-roadmap/#overview","text":"The Webb protocol is the first protocol built by Webb Technologies. It is a non-custodial private bridge protocol that uses smart contracts to bootstrap a zero-knowledge bridge. It is designed to work in all possible smart contracting environments. The current working repos for this protocol are targeting the EVM & Rust based chains such as Substrate. https://github.com/webb-tools/protocol-solidity https://github.com/webb-tools/protocol-substrate","title":"Overview"},{"location":"bridge-protocols/webb/technical-roadmap/#goals","text":"The goals for the protocol are to grow into a trustless, private bridge overlying existing cross-chain communication protocols such as Polkadot's XCMP, Cosmos's IBC, or Celo's Optics. We will use the following checklist to track network deployments. [ ] Ethereum - as a smart contract [ ] Polkadot - as a smart contract or parachain [ ] Kusama - as a smart contract or parachain [ ] Harmony - as a smart contract or comsos-sdk chain [ ] Edgeware - as a smart contract or pallet [ ] Cosmos - as a smart contract or cosmos-sdk chain [ ] Celo - as a smart contract [ ] Polygon - as a smart contract [ ] Solana - as a smart contract","title":"Goals"},{"location":"bridge-protocols/webb/technical-roadmap/#protocol-implementations","text":"We will use the following checklist to track protocol implementations [ ] Solidity [ ] Rust [ ] Golang [ ] Leo [ ] Cairo [ ] Ink!","title":"Protocol Implementations"},{"location":"bridge-protocols/webb/technical-roadmap/#objectives-q3-2021","text":"A test EVM bridge deployment can be made between Ethereum, Edgeware, and Harmony's test networks. Networks with instability will be exchanged or removed from the bridge if needed. In order to do so we need: [ ] protocol-solidity v1 protocol [ ] relayer v2 w/ Webb protocol support [ ] protocol-substrate v1 protocol [ ] Upon completion of first two milestones, deploy a small capped bridge at $10,000 approximate value on each side.","title":"Objectives - Q3 2021"},{"location":"bridge-protocols/webb/technical-roadmap/#protocol-solidity-v1","text":"Necessary items before deploying the bridge [ ] Add governable wrapping limit, denote by LimitedGovernedTokenWrapper . [ ] Integration tests on a single chain [ ] Deploy 2 bridges, 2 comp tokens, 2 anchors, 2 governor bravos on the same chain [ ] Case 1: Repeat steps 2-5 for each bridge: Deploy GovernedTokenWrapper1, GovernedTokenWrapper2 Deploy a mock Token Add Token . address to GovernedTokenWrapper1 . tokens Deploy LinkableERC20Anchor with GovernedTokenWrapper1 as the ERC20. Deposit Create a note that commits to withdraw on the bridge that was not deposited into. Deposit x tokens into one bridge, record the note . Deposit T more random notes into both sides of the bridge. Withdraw Generate the zero-knowledge proof for withdrawal Collect roots of each anchor Collect merkle membership proof for anchor deposited into Generate witness . Submit witness to the anchor on the \"other side of the bridge\". Submit tx w/ proof to the destination bridge. Mint tokens if no available liquidity is in the locked_pool . Verify balance updates in each respective token. Unwrap Deploy a mock UnwrappingToken . Add UnwrappingToken . address to GovernedTokenWrapper2 . tokens","title":"protocol-solidity v1"},{"location":"bridge-protocols/webb/technical-roadmap/#relayer-v1","text":"Relayer v2 is geared towards including chainbridge governance functionality. This means functionality for voting, closing, and executing proposals to update edges on the bridge. We want to test this with a sufficient relayer network and proposal passing threshold. [ ] Deploy relayer v1 to test networks: Rinkeby, Harmony Shard 1, Edgeware Beresheet. Chainbridge governance: [ ] Listen to events on both bridges. On receive event, pass to state machine and return a transaction / call State machine should update inner state and remove transactions that get executed by other relayers. If transaction, add to a queue. If call, execute. Pull from queue using a random number generator with a TBD distribution. If transaction. execute. [ ] Define strategy builder class for building voting strategies. Use a state machine and local storage Strategies for honest and greedy execution. Transaction Relayer [ ] Integration tests on all chains participating on the bridge [ ] Deployment as described above in protocol-solidity v1 . [ ] Case 1: Relayer actions are executed in intervals of k seconds Expose an api: /api/v2/relay for clients to relay TXes through. On received TX, Verify & validate it natively. Store in a queue . Every k seconds, pull a batch of TXes from the queue . Submit them to the chain.","title":"relayer v1"},{"location":"bridge-protocols/webb/technical-roadmap/#protocol-substrate-v1","text":"The Substrate implementation of the protocol should follow from protocol-solidity . [ ] Integrate chainbridge-substrate to the repo. [ ] Develop Anchor pallet. Bridge gadget using circom-compatible Poseidon . Graph functionality with access-control for Bridge/Handler pallet. Ability to add edge if called by governor/bridge Ability to update edge if called by governor/bridge [ ] Integration of chainbridge-substrate w/ Anchor pallet tests [ ] Define two Anchor pallets and two chainbridge-substrate bridges. Ensure this can be done with the architecture (e.g. using instances) [ ] Full integration tests with relayer v3 .","title":"protocol-substrate v1"},{"location":"bridge-protocols/webb/technical-roadmap/#objectives-q4-2021","text":"A test Substrate \u2190 \u2192 EVM bridge deployment can be made between Ethereum, Edgeware (Frontier), and Substrate networks like Kusama, Polkadot. For this to be possible, we need to extend relayer functionality to support Substrate's chainbridge governance and serve as an oracle over the merkle roots of our protocol's merkle trees. [ ] relayer v2-3 w/ chainbridge-substrate governance & bridge tx relayer for Substrate [ ] protocol-substrate v2 protocol [ ] dkg-gadget v1 protocol","title":"Objectives - Q4 2021"},{"location":"bridge-protocols/webb/technical-roadmap/#relayer-v2-v3","text":"Once protocol-substrate v1 is built we can begin building the integration into the relayer v2 . This means integrating chainbridge-substrate governance and transaction relaying system for bridge transactions on Substrate networks into the service.","title":"relayer v2 - v3"},{"location":"bridge-protocols/webb/technical-roadmap/#protocol-substrate-v1x","text":"We want to position the Substrate side of the network to provide various privacy services that augment the functionality of the bridge and complete useful revenue generating tasks. These tasks can range in the future from various distributed custody, social key recovery, and private information retrieval services. [ ] Integrate relayer v2 into the protocol-substrate service.rs . [ ] Develop Relayer Election pallet [ ] Proof of Authority system at genesis [ ] Proof of stake elected system at first upgrade [ ] Relayers register w/ necessary metadata Reward address IP / IPFS multihash / P2P node address / validator keys [ ] Develop DKG pallet. [ ] Store necessary metadata in pallet storage.","title":"protocol-substrate v1.X"},{"location":"bridge-protocols/webb/technical-roadmap/#protocol-substratedkg-gadget-v1","text":"A DKG for Webb can become a critical piece of our scalability and network value. We initially are motivated by using a DKG protocol to generate a threshold keypair that can be used to govern the anchor deployments. [ ] Design gossip protocol for running the DKG. [ ] Integrate DKG as separate p2p worker running alongside consensus mechanism. [ ] Add support for multiple DKGs if reasonable (depending on ability to generalise). [ ] Add functionality for: [ ] Signing ETH transactions for chainbridge-solidity governance. [ ] Signing Substrate transactions for chainbridge-substrate governance.","title":"protocol-substrate/dkg-gadget v1"},{"location":"bridge-protocols/webb/technical-roadmap/#objectives-q1-2022","text":"Launching of parachains & live (capped) deployments for various tokens in the ecosystem: [ ] Deployments: [ ] Stablecoin sets: USDC / DAI [ ] BTC sets: WBTC / TBTC / InterBTC [ ] zk-gadgets - PLONK gadgets, updating setup, and dynamically configurable bridge. [ ] Webb Protocol v2 protocol implementation in Solidity and Substrate/Rust.","title":"Objectives - Q1 2022"},{"location":"bridge-protocols/webb/technical-roadmap/#deployments","text":"Deployments to various networks should occur with a limited initial liquidity. Initial liquidity providers will govern the limit thereafter.","title":"deployments"},{"location":"bridge-protocols/webb/technical-roadmap/#zk-gadgets","text":"PLONK for the circom circuits. Other updatable setups for arkworks circuits (whether Marlin works or PLONK needs to be built).","title":"zk-gadgets"},{"location":"bridge-protocols/webb/technical-roadmap/#protocol-solidity-protocol-substrate-v2","text":"V2 comes with an upgrade to our zero-knowledge infrastructure by integrating PLONK as the targetted prover/verifier. We mainly want to work with updatable setups to build an updatable and dynamic bridge. Additionally, we want to research and plan for a way to tackle a variable deposit, interoperable shielded pool, which will likely depend on Halo2 or similarly recursive proving schemes.","title":"protocol-solidity / protocol-substrate v2"},{"location":"bridge-protocols/webb/circuits/CommitmentHasher/","text":"CommitmentHasher \u00b6 template CommitmentHasher() Inputs \u00b6 chainID secret nullifier Outputs \u00b6 commitment nullifierHash Sub-Gadgets \u00b6 HashLeftRight which is a two input Poseidon hasher Hasher3 which is a three input Poseidon hasher Functionality/How it Works \u00b6 Used to compute the commitment and nullifierHash . Does so by using the hasher sub-gadgets. Sets commitment to Poseidon(chainID, secret, nullifier) and nullifierHash to Poseidon(nullifier, nullifier) . The hasher circuits for the Poseidon hash function are taken from circomlib. References \u00b6 https://github.com/tornadocash/tornado-core/blob/master/circuits/withdraw.circom","title":"CommitmentHasher"},{"location":"bridge-protocols/webb/circuits/CommitmentHasher/#commitmenthasher","text":"template CommitmentHasher()","title":"CommitmentHasher"},{"location":"bridge-protocols/webb/circuits/CommitmentHasher/#inputs","text":"chainID secret nullifier","title":"Inputs"},{"location":"bridge-protocols/webb/circuits/CommitmentHasher/#outputs","text":"commitment nullifierHash","title":"Outputs"},{"location":"bridge-protocols/webb/circuits/CommitmentHasher/#sub-gadgets","text":"HashLeftRight which is a two input Poseidon hasher Hasher3 which is a three input Poseidon hasher","title":"Sub-Gadgets"},{"location":"bridge-protocols/webb/circuits/CommitmentHasher/#functionalityhow-it-works","text":"Used to compute the commitment and nullifierHash . Does so by using the hasher sub-gadgets. Sets commitment to Poseidon(chainID, secret, nullifier) and nullifierHash to Poseidon(nullifier, nullifier) . The hasher circuits for the Poseidon hash function are taken from circomlib.","title":"Functionality/How it Works"},{"location":"bridge-protocols/webb/circuits/CommitmentHasher/#references","text":"https://github.com/tornadocash/tornado-core/blob/master/circuits/withdraw.circom","title":"References"},{"location":"bridge-protocols/webb/circuits/DualMux/","text":"DualMux \u00b6 template DualMux() Inputs \u00b6 in[2] , two inputs s , a binary selector variable Outputs \u00b6 out[2] , two outputs Sub-Gadgets \u00b6 None Functionality/How it Works \u00b6 Checks if s is a binary variable (by including a contraint s*(1-s) === 0 . If s is 0 returns [in[0], in[1] , if s is 1 returns [in[1], in[0]] . References \u00b6 https://github.com/tornadocash/tornado-core/blob/master/circuits/merkleTree.circom","title":"DualMux"},{"location":"bridge-protocols/webb/circuits/DualMux/#dualmux","text":"template DualMux()","title":"DualMux"},{"location":"bridge-protocols/webb/circuits/DualMux/#inputs","text":"in[2] , two inputs s , a binary selector variable","title":"Inputs"},{"location":"bridge-protocols/webb/circuits/DualMux/#outputs","text":"out[2] , two outputs","title":"Outputs"},{"location":"bridge-protocols/webb/circuits/DualMux/#sub-gadgets","text":"None","title":"Sub-Gadgets"},{"location":"bridge-protocols/webb/circuits/DualMux/#functionalityhow-it-works","text":"Checks if s is a binary variable (by including a contraint s*(1-s) === 0 . If s is 0 returns [in[0], in[1] , if s is 1 returns [in[1], in[0]] .","title":"Functionality/How it Works"},{"location":"bridge-protocols/webb/circuits/DualMux/#references","text":"https://github.com/tornadocash/tornado-core/blob/master/circuits/merkleTree.circom","title":"References"},{"location":"bridge-protocols/webb/circuits/ManyMerkleTreeChecker/","text":"ManyMerkleTreeChecker \u00b6 template ManyMerkleTreeChecker(levels, length) Inputs \u00b6 leaf (corresponds to a commitment on an anchor Merkle tree) pathElements[levels] pathIndices[levels] roots[length] diffs[length] Outputs \u00b6 None Sub-Gadgets \u00b6 DualMux() . See: HashLeftRight() which is a two input Poseidon hasher. SetMembership(length) . See: Functionality/How it Works \u00b6 Uses HashLeftRight() to compute Merkle root from pathElements[levels] and the leaf . The DualMux() gadget is necessary because depending on whether the Merkle proof element is on the left or right side (as indicated by pathIndices[levels] ), the inputs to HashLeftRight() have to be re-ordered. This is because Poseidon(left, right) does not equal Poseidon(right, left) . Uses the SetMembership(length) gadget to check whether the computed root is in roots[length] . References \u00b6 https://github.com/tornadocash/tornado-core/blob/master/circuits/merkleTree.circom","title":"ManyMerkleTreeChecker"},{"location":"bridge-protocols/webb/circuits/ManyMerkleTreeChecker/#manymerkletreechecker","text":"template ManyMerkleTreeChecker(levels, length)","title":"ManyMerkleTreeChecker"},{"location":"bridge-protocols/webb/circuits/ManyMerkleTreeChecker/#inputs","text":"leaf (corresponds to a commitment on an anchor Merkle tree) pathElements[levels] pathIndices[levels] roots[length] diffs[length]","title":"Inputs"},{"location":"bridge-protocols/webb/circuits/ManyMerkleTreeChecker/#outputs","text":"None","title":"Outputs"},{"location":"bridge-protocols/webb/circuits/ManyMerkleTreeChecker/#sub-gadgets","text":"DualMux() . See: HashLeftRight() which is a two input Poseidon hasher. SetMembership(length) . See:","title":"Sub-Gadgets"},{"location":"bridge-protocols/webb/circuits/ManyMerkleTreeChecker/#functionalityhow-it-works","text":"Uses HashLeftRight() to compute Merkle root from pathElements[levels] and the leaf . The DualMux() gadget is necessary because depending on whether the Merkle proof element is on the left or right side (as indicated by pathIndices[levels] ), the inputs to HashLeftRight() have to be re-ordered. This is because Poseidon(left, right) does not equal Poseidon(right, left) . Uses the SetMembership(length) gadget to check whether the computed root is in roots[length] .","title":"Functionality/How it Works"},{"location":"bridge-protocols/webb/circuits/ManyMerkleTreeChecker/#references","text":"https://github.com/tornadocash/tornado-core/blob/master/circuits/merkleTree.circom","title":"References"},{"location":"bridge-protocols/webb/circuits/SetMembership/","text":"SetMembership \u00b6 template SetMembership(length) Inputs \u00b6 element set[length] diffs[length] Outputs \u00b6 None Sub-Gadgets \u00b6 None Functionality/How it Works \u00b6 (taken from code comments) For a given set of elements, prover first computes the difference between each element in the set and the element they are proving knowledge of. We constrain this operation accordingly. We then multiply all differences and constrain this value by zero. If the prover actually knows an element in the set then for that element, it must hold that the difference is 0. Therefore, the product of 0 and anything else should be 0. The prove can't lie by adding a zero into the diffs[length[ set because we constrain those to match all elements in the set, respectively.","title":"SetMembership"},{"location":"bridge-protocols/webb/circuits/SetMembership/#setmembership","text":"template SetMembership(length)","title":"SetMembership"},{"location":"bridge-protocols/webb/circuits/SetMembership/#inputs","text":"element set[length] diffs[length]","title":"Inputs"},{"location":"bridge-protocols/webb/circuits/SetMembership/#outputs","text":"None","title":"Outputs"},{"location":"bridge-protocols/webb/circuits/SetMembership/#sub-gadgets","text":"None","title":"Sub-Gadgets"},{"location":"bridge-protocols/webb/circuits/SetMembership/#functionalityhow-it-works","text":"(taken from code comments) For a given set of elements, prover first computes the difference between each element in the set and the element they are proving knowledge of. We constrain this operation accordingly. We then multiply all differences and constrain this value by zero. If the prover actually knows an element in the set then for that element, it must hold that the difference is 0. Therefore, the product of 0 and anything else should be 0. The prove can't lie by adding a zero into the diffs[length[ set because we constrain those to match all elements in the set, respectively.","title":"Functionality/How it Works"},{"location":"bridge-protocols/webb/contracts/Anchor/","text":"Anchor.sol \u00b6 Implementation Description \u00b6 A contrac that implements the appropriate remaining functions for processing deposits and withdrawals for an AnchorBase.sol . This contract inherits all the methods of the base LinkableAnchor.sol and AnchorBase.sol contracts. Variables \u00b6 token \u00b6 Type: public immutable token Constructor \u00b6 Details Signature constructor( IVerifier _verifier, IPoseidonT3 _hasher, uint256 _denomination, uint32 _merkleTreeHeight, ITokenWrapper _token, address _bridge, address _admin, address _handler, uint8 _maxEdges ) LinkableAnchor(_verifier, _hasher, _denomination, _merkleTreeHeight, _bridge, _admin, _handler, _maxEdges) Internal Functions \u00b6 Calls to deposits require a commitment, which is a hash of some secret values. _processDeposit \u00b6 Details Signature _processDeposit() Requires require(msg.value == 0, \"ETH value is supposed to be 0 for ERC20 instance\") _processWithdraw \u00b6 Details Signature _processWithdraw( address payable _recipient, address payable _relayer, uint256 _fee, uint256 _refund ) Requires require(msg.value == _refund, \"Incorrect refund amount received by the contract\")","title":"Anchor"},{"location":"bridge-protocols/webb/contracts/Anchor/#anchorsol","text":"Implementation","title":"Anchor.sol"},{"location":"bridge-protocols/webb/contracts/Anchor/#description","text":"A contrac that implements the appropriate remaining functions for processing deposits and withdrawals for an AnchorBase.sol . This contract inherits all the methods of the base LinkableAnchor.sol and AnchorBase.sol contracts.","title":"Description"},{"location":"bridge-protocols/webb/contracts/Anchor/#variables","text":"","title":"Variables"},{"location":"bridge-protocols/webb/contracts/Anchor/#token","text":"Type: public immutable token","title":"token"},{"location":"bridge-protocols/webb/contracts/Anchor/#constructor","text":"Details Signature constructor( IVerifier _verifier, IPoseidonT3 _hasher, uint256 _denomination, uint32 _merkleTreeHeight, ITokenWrapper _token, address _bridge, address _admin, address _handler, uint8 _maxEdges ) LinkableAnchor(_verifier, _hasher, _denomination, _merkleTreeHeight, _bridge, _admin, _handler, _maxEdges)","title":"Constructor"},{"location":"bridge-protocols/webb/contracts/Anchor/#internal-functions","text":"Calls to deposits require a commitment, which is a hash of some secret values.","title":"Internal Functions"},{"location":"bridge-protocols/webb/contracts/Anchor/#_processdeposit","text":"Details Signature _processDeposit() Requires require(msg.value == 0, \"ETH value is supposed to be 0 for ERC20 instance\")","title":"_processDeposit"},{"location":"bridge-protocols/webb/contracts/Anchor/#_processwithdraw","text":"Details Signature _processWithdraw( address payable _recipient, address payable _relayer, uint256 _fee, uint256 _refund ) Requires require(msg.value == _refund, \"Incorrect refund amount received by the contract\")","title":"_processWithdraw"},{"location":"bridge-protocols/webb/contracts/AnchorBase/","text":"AnchorBase.sol \u00b6 Implementation Description \u00b6 An abstract contract that requires child classes to implement appropriate verification and processes for deposits and withdrawals. Variables \u00b6 bridge \u00b6 Type: public address admin \u00b6 Type: public address handler \u00b6 Type: public address verifier \u00b6 Type: public immutable IVerifier denomination \u00b6 Type: public immutable uint256 maxEdges \u00b6 Type: public immutable uint8 nullifierHashes \u00b6 Type: public mapping(bytes32 => bool) commitments \u00b6 Type: public mapping(bytes32 => bool) Edge \u00b6 Type: struct Edge { uint256 chainID; bytes32 root; uint256 height; } edgeIndex \u00b6 Type: mapping(uint256 => uint256) edgeExistsForChain \u00b6 Type: public mapping(uint256 => bool) edgeList \u00b6 Type: public Edge[] neighborRoots \u00b6 Type: public mapping(uint256 => mapping(uint32 => bytes32)) currentNeighborRootIndex \u00b6 Type: public mapping(uint256 => uint32) Constructor \u00b6 Details Signature constructor( IVerifier _verifier, IHasher _hasher, uint256 _denomination, uint32 _merkleTreeHeight, uint8 _maxEdges ) MerkleTreePoseidon(_merkleTreeHeight, _hasher) External Functions \u00b6 Calls to deposits require a commitment, which is a hash of some secret values. deposit \u00b6 Details Signature deposit(bytes32 _commitment) Requires require(..., \"commitment has been submitted\") Emits Deposit withdraw \u00b6 Details Signature withdraw( bytes calldata _proof, PublicInputs calldata _publicInputs ) Requires require(_fee <= denomination) require(..., \"The note has already been spent\") require(..., \"Cannot find your merkle root\") require(..., \"Incorrect root array length\") require(..., \"Neighbor root not found\") require(..., \"Invalid withdraw proof\") Emits Withdraw View Functions \u00b6 isSpent \u00b6 Details Signature isSpent(bytes32 _nullifierHash) public view returns (bool) isSpentArray \u00b6 Details Signature isSpentArray(bytes32[] calldata _nullifierHashes) external view returns (bool[] memory spent) getLatestNeighborRoots \u00b6 Details Signature getLatestNeighborRoots() public view returns (bytes32[1] memory roots) isKnownNeighborRoot \u00b6 Details Signature isKnownNeighborRoot(uint256 neighborChainID, bytes32 _root) public view returns (bool) Events \u00b6 Deposit \u00b6 Signature : Deposit(bytes32 indexed commitment, uint32 leafIndex, uint256 timestamp) Withdraw \u00b6 Signature : Withdrawal(address to, bytes32 nullifierHash, address indexed relayer, uint256 fee) EdgeAddition \u00b6 Signature : EdgeAddition(uint256 chainID, uint256 height, bytes32 merkleRoot) EdgeUpdate \u00b6 Signature : EdgeUpdate(uint256 chainID, uint256 height, bytes32 merkleRoot) RootHistoryRecorded \u00b6 Signature : RootHistoryRecorded(uint timestamp, bytes32[1] roots) RootHistoryUpdate \u00b6 Signature : RootHistoryUpdate(uint timestamp, bytes32[1] roots)","title":"AnchorBase"},{"location":"bridge-protocols/webb/contracts/AnchorBase/#anchorbasesol","text":"Implementation","title":"AnchorBase.sol"},{"location":"bridge-protocols/webb/contracts/AnchorBase/#description","text":"An abstract contract that requires child classes to implement appropriate verification and processes for deposits and withdrawals.","title":"Description"},{"location":"bridge-protocols/webb/contracts/AnchorBase/#variables","text":"","title":"Variables"},{"location":"bridge-protocols/webb/contracts/AnchorBase/#bridge","text":"Type: public address","title":"bridge"},{"location":"bridge-protocols/webb/contracts/AnchorBase/#admin","text":"Type: public address","title":"admin"},{"location":"bridge-protocols/webb/contracts/AnchorBase/#handler","text":"Type: public address","title":"handler"},{"location":"bridge-protocols/webb/contracts/AnchorBase/#verifier","text":"Type: public immutable IVerifier","title":"verifier"},{"location":"bridge-protocols/webb/contracts/AnchorBase/#denomination","text":"Type: public immutable uint256","title":"denomination"},{"location":"bridge-protocols/webb/contracts/AnchorBase/#maxedges","text":"Type: public immutable uint8","title":"maxEdges"},{"location":"bridge-protocols/webb/contracts/AnchorBase/#nullifierhashes","text":"Type: public mapping(bytes32 => bool)","title":"nullifierHashes"},{"location":"bridge-protocols/webb/contracts/AnchorBase/#commitments","text":"Type: public mapping(bytes32 => bool)","title":"commitments"},{"location":"bridge-protocols/webb/contracts/AnchorBase/#edge","text":"Type: struct Edge { uint256 chainID; bytes32 root; uint256 height; }","title":"Edge"},{"location":"bridge-protocols/webb/contracts/AnchorBase/#edgeindex","text":"Type: mapping(uint256 => uint256)","title":"edgeIndex"},{"location":"bridge-protocols/webb/contracts/AnchorBase/#edgeexistsforchain","text":"Type: public mapping(uint256 => bool)","title":"edgeExistsForChain"},{"location":"bridge-protocols/webb/contracts/AnchorBase/#edgelist","text":"Type: public Edge[]","title":"edgeList"},{"location":"bridge-protocols/webb/contracts/AnchorBase/#neighborroots","text":"Type: public mapping(uint256 => mapping(uint32 => bytes32))","title":"neighborRoots"},{"location":"bridge-protocols/webb/contracts/AnchorBase/#currentneighborrootindex","text":"Type: public mapping(uint256 => uint32)","title":"currentNeighborRootIndex"},{"location":"bridge-protocols/webb/contracts/AnchorBase/#constructor","text":"Details Signature constructor( IVerifier _verifier, IHasher _hasher, uint256 _denomination, uint32 _merkleTreeHeight, uint8 _maxEdges ) MerkleTreePoseidon(_merkleTreeHeight, _hasher)","title":"Constructor"},{"location":"bridge-protocols/webb/contracts/AnchorBase/#external-functions","text":"Calls to deposits require a commitment, which is a hash of some secret values.","title":"External Functions"},{"location":"bridge-protocols/webb/contracts/AnchorBase/#deposit","text":"Details Signature deposit(bytes32 _commitment) Requires require(..., \"commitment has been submitted\") Emits Deposit","title":"deposit"},{"location":"bridge-protocols/webb/contracts/AnchorBase/#withdraw","text":"Details Signature withdraw( bytes calldata _proof, PublicInputs calldata _publicInputs ) Requires require(_fee <= denomination) require(..., \"The note has already been spent\") require(..., \"Cannot find your merkle root\") require(..., \"Incorrect root array length\") require(..., \"Neighbor root not found\") require(..., \"Invalid withdraw proof\") Emits Withdraw","title":"withdraw"},{"location":"bridge-protocols/webb/contracts/AnchorBase/#view-functions","text":"","title":"View Functions"},{"location":"bridge-protocols/webb/contracts/AnchorBase/#isspent","text":"Details Signature isSpent(bytes32 _nullifierHash) public view returns (bool)","title":"isSpent"},{"location":"bridge-protocols/webb/contracts/AnchorBase/#isspentarray","text":"Details Signature isSpentArray(bytes32[] calldata _nullifierHashes) external view returns (bool[] memory spent)","title":"isSpentArray"},{"location":"bridge-protocols/webb/contracts/AnchorBase/#getlatestneighborroots","text":"Details Signature getLatestNeighborRoots() public view returns (bytes32[1] memory roots)","title":"getLatestNeighborRoots"},{"location":"bridge-protocols/webb/contracts/AnchorBase/#isknownneighborroot","text":"Details Signature isKnownNeighborRoot(uint256 neighborChainID, bytes32 _root) public view returns (bool)","title":"isKnownNeighborRoot"},{"location":"bridge-protocols/webb/contracts/AnchorBase/#events","text":"","title":"Events"},{"location":"bridge-protocols/webb/contracts/AnchorBase/#deposit_1","text":"Signature : Deposit(bytes32 indexed commitment, uint32 leafIndex, uint256 timestamp)","title":"Deposit"},{"location":"bridge-protocols/webb/contracts/AnchorBase/#withdraw_1","text":"Signature : Withdrawal(address to, bytes32 nullifierHash, address indexed relayer, uint256 fee)","title":"Withdraw"},{"location":"bridge-protocols/webb/contracts/AnchorBase/#edgeaddition","text":"Signature : EdgeAddition(uint256 chainID, uint256 height, bytes32 merkleRoot)","title":"EdgeAddition"},{"location":"bridge-protocols/webb/contracts/AnchorBase/#edgeupdate","text":"Signature : EdgeUpdate(uint256 chainID, uint256 height, bytes32 merkleRoot)","title":"EdgeUpdate"},{"location":"bridge-protocols/webb/contracts/AnchorBase/#roothistoryrecorded","text":"Signature : RootHistoryRecorded(uint timestamp, bytes32[1] roots)","title":"RootHistoryRecorded"},{"location":"bridge-protocols/webb/contracts/AnchorBase/#roothistoryupdate","text":"Signature : RootHistoryUpdate(uint timestamp, bytes32[1] roots)","title":"RootHistoryUpdate"},{"location":"bridge-protocols/webb/contracts/LinkableAnchor/","text":"LinkableAnchor.sol \u00b6 Implementation Description \u00b6 An abstract contract that implements the linking functionality for bridging anchors across chains. This contract inherits all the methods of the base AnchorBase.sol contract. Constructor \u00b6 Details Signature constructor( IVerifier _verifier, IHasher _hasher, uint256 _denomination, uint32 _merkleTreeHeight, address _bridge, address _admin, address _handler, uint8 _maxEdges ) AnchorBase(_verifier, _hasher, _denomination, _merkleTreeHeight, _maxEdges) External Functions \u00b6 Calls to deposits require a commitment, which is a hash of some secret values. setHandler \u00b6 Details Signature setHandler(address _handler) Requires require(..., \"sender is not the bridge\") setBridge \u00b6 Details Signature setBridge(address _bridge) Requires require(..., \"sender is not the admin\") addEdge \u00b6 Details Signature addEdge( uint256 sourceChainID, bytes32 root, uint256 leafIndex ) Requires require(..., \"sender is not the handler\") require(..., \"This Anchor is at capacity\") Emits EdgeAddition, RootHistoryUpdate updateEdge \u00b6 Details Signature updateEdge( uint256 sourceChainID, bytes32 root, uint256 leafIndex ) Requires require(..., \"sender is not the handler\") require(..., \"Chain must be integrated from the bridge before updates\") require(..., \"New height must be greater\") Emits EdgeUpdate, RootHistoryUpdate","title":"LinkableAnchor"},{"location":"bridge-protocols/webb/contracts/LinkableAnchor/#linkableanchorsol","text":"Implementation","title":"LinkableAnchor.sol"},{"location":"bridge-protocols/webb/contracts/LinkableAnchor/#description","text":"An abstract contract that implements the linking functionality for bridging anchors across chains. This contract inherits all the methods of the base AnchorBase.sol contract.","title":"Description"},{"location":"bridge-protocols/webb/contracts/LinkableAnchor/#constructor","text":"Details Signature constructor( IVerifier _verifier, IHasher _hasher, uint256 _denomination, uint32 _merkleTreeHeight, address _bridge, address _admin, address _handler, uint8 _maxEdges ) AnchorBase(_verifier, _hasher, _denomination, _merkleTreeHeight, _maxEdges)","title":"Constructor"},{"location":"bridge-protocols/webb/contracts/LinkableAnchor/#external-functions","text":"Calls to deposits require a commitment, which is a hash of some secret values.","title":"External Functions"},{"location":"bridge-protocols/webb/contracts/LinkableAnchor/#sethandler","text":"Details Signature setHandler(address _handler) Requires require(..., \"sender is not the bridge\")","title":"setHandler"},{"location":"bridge-protocols/webb/contracts/LinkableAnchor/#setbridge","text":"Details Signature setBridge(address _bridge) Requires require(..., \"sender is not the admin\")","title":"setBridge"},{"location":"bridge-protocols/webb/contracts/LinkableAnchor/#addedge","text":"Details Signature addEdge( uint256 sourceChainID, bytes32 root, uint256 leafIndex ) Requires require(..., \"sender is not the handler\") require(..., \"This Anchor is at capacity\") Emits EdgeAddition, RootHistoryUpdate","title":"addEdge"},{"location":"bridge-protocols/webb/contracts/LinkableAnchor/#updateedge","text":"Details Signature updateEdge( uint256 sourceChainID, bytes32 root, uint256 leafIndex ) Requires require(..., \"sender is not the handler\") require(..., \"Chain must be integrated from the bridge before updates\") require(..., \"New height must be greater\") Emits EdgeUpdate, RootHistoryUpdate","title":"updateEdge"},{"location":"bridge-protocols/webb/contracts/MerkleTreePoseidon/","text":"MerkleTreePoseidon.sol \u00b6 Implementation Description \u00b6 The MerkleTreePoseidon is an deployment ready implementation of a MerkleTreeWithHistoryPoseidon.sol and inherits all its methods. It populates the zero hashes and implements the hash function for contracts that inherit it.","title":"MerkleTreePoseidon.sol"},{"location":"bridge-protocols/webb/contracts/MerkleTreePoseidon/#merkletreeposeidonsol","text":"Implementation","title":"MerkleTreePoseidon.sol"},{"location":"bridge-protocols/webb/contracts/MerkleTreePoseidon/#description","text":"The MerkleTreePoseidon is an deployment ready implementation of a MerkleTreeWithHistoryPoseidon.sol and inherits all its methods. It populates the zero hashes and implements the hash function for contracts that inherit it.","title":"Description"},{"location":"bridge-protocols/webb/contracts/MerkleTreeWithHistoryPoseidon/","text":"MerkleTreeWithHistoryPoseidon.sol \u00b6 Implementation Description \u00b6 The MerkleTreeWithHistoryPoseidon is abstract contract and data structure which holds the commitments of deposits - which are hashes of secret values picked by the user. When a user wishes to withdraw from the mixer, the user needs to submit a proof which shows the knowledge of these secret values. Variables \u00b6 hasher \u00b6 Type: public immutable IPoseidonT3 levels \u00b6 Type: public immutable uint32 filledSubtrees \u00b6 Type: public mapping(uint256 => bytes32) roots \u00b6 Type: public mapping(uint256 => bytes32) ROOT_HISTORY_SIZE \u00b6 Type: public constant uint32 currentRootIndex \u00b6 Type: public uint32 nextIndex \u00b6 Type: public uint32 Constructor \u00b6 Details Signature constructor(uint32 _levels, IPoseidonT3 _hasher) Requires require(_levels > 0) require(_levels < 32) External Functions \u00b6 hashLeftRight \u00b6 Details Signature function hashLeftRight(IPoseidonT3 _hasher, bytes32 _left, bytes32 _right) public pure returns (bytes32) Requires require(..., \"_left should be inside the field\") require(..., \"_right should be instide the field\") View Functions \u00b6 isKnownRoot \u00b6 Details Signature isKnownRoot(bytes32 _root) public view returns (bool) getLastRoot \u00b6 Details Signature getLastRoot() public view returns (bytes32) zeros \u00b6 Details Signature zeros(uint256 i) public pure returns (bytes32) Internal Functions \u00b6 _insert \u00b6 Details Signature _insert(bytes32 _leaf) internal returns (uint32 index) Requires require(..., \"merkle tree is full\")","title":"MerkleTreeWithHistoryPoseidon"},{"location":"bridge-protocols/webb/contracts/MerkleTreeWithHistoryPoseidon/#merkletreewithhistoryposeidonsol","text":"Implementation","title":"MerkleTreeWithHistoryPoseidon.sol"},{"location":"bridge-protocols/webb/contracts/MerkleTreeWithHistoryPoseidon/#description","text":"The MerkleTreeWithHistoryPoseidon is abstract contract and data structure which holds the commitments of deposits - which are hashes of secret values picked by the user. When a user wishes to withdraw from the mixer, the user needs to submit a proof which shows the knowledge of these secret values.","title":"Description"},{"location":"bridge-protocols/webb/contracts/MerkleTreeWithHistoryPoseidon/#variables","text":"","title":"Variables"},{"location":"bridge-protocols/webb/contracts/MerkleTreeWithHistoryPoseidon/#hasher","text":"Type: public immutable IPoseidonT3","title":"hasher"},{"location":"bridge-protocols/webb/contracts/MerkleTreeWithHistoryPoseidon/#levels","text":"Type: public immutable uint32","title":"levels"},{"location":"bridge-protocols/webb/contracts/MerkleTreeWithHistoryPoseidon/#filledsubtrees","text":"Type: public mapping(uint256 => bytes32)","title":"filledSubtrees"},{"location":"bridge-protocols/webb/contracts/MerkleTreeWithHistoryPoseidon/#roots","text":"Type: public mapping(uint256 => bytes32)","title":"roots"},{"location":"bridge-protocols/webb/contracts/MerkleTreeWithHistoryPoseidon/#root_history_size","text":"Type: public constant uint32","title":"ROOT_HISTORY_SIZE"},{"location":"bridge-protocols/webb/contracts/MerkleTreeWithHistoryPoseidon/#currentrootindex","text":"Type: public uint32","title":"currentRootIndex"},{"location":"bridge-protocols/webb/contracts/MerkleTreeWithHistoryPoseidon/#nextindex","text":"Type: public uint32","title":"nextIndex"},{"location":"bridge-protocols/webb/contracts/MerkleTreeWithHistoryPoseidon/#constructor","text":"Details Signature constructor(uint32 _levels, IPoseidonT3 _hasher) Requires require(_levels > 0) require(_levels < 32)","title":"Constructor"},{"location":"bridge-protocols/webb/contracts/MerkleTreeWithHistoryPoseidon/#external-functions","text":"","title":"External Functions"},{"location":"bridge-protocols/webb/contracts/MerkleTreeWithHistoryPoseidon/#hashleftright","text":"Details Signature function hashLeftRight(IPoseidonT3 _hasher, bytes32 _left, bytes32 _right) public pure returns (bytes32) Requires require(..., \"_left should be inside the field\") require(..., \"_right should be instide the field\")","title":"hashLeftRight"},{"location":"bridge-protocols/webb/contracts/MerkleTreeWithHistoryPoseidon/#view-functions","text":"","title":"View Functions"},{"location":"bridge-protocols/webb/contracts/MerkleTreeWithHistoryPoseidon/#isknownroot","text":"Details Signature isKnownRoot(bytes32 _root) public view returns (bool)","title":"isKnownRoot"},{"location":"bridge-protocols/webb/contracts/MerkleTreeWithHistoryPoseidon/#getlastroot","text":"Details Signature getLastRoot() public view returns (bytes32)","title":"getLastRoot"},{"location":"bridge-protocols/webb/contracts/MerkleTreeWithHistoryPoseidon/#zeros","text":"Details Signature zeros(uint256 i) public pure returns (bytes32)","title":"zeros"},{"location":"bridge-protocols/webb/contracts/MerkleTreeWithHistoryPoseidon/#internal-functions","text":"","title":"Internal Functions"},{"location":"bridge-protocols/webb/contracts/MerkleTreeWithHistoryPoseidon/#_insert","text":"Details Signature _insert(bytes32 _leaf) internal returns (uint32 index) Requires require(..., \"merkle tree is full\")","title":"_insert"},{"location":"bridge-protocols/webb/contracts/overview/","text":"Protocol-Solidity Documentation \u00b6 Suppose Alice wants to deposit on chain 1 and later wants to withdraw on chain 2. Depositing \u00b6 She deposits funds and a commitment ( hash(destinationChainID, nullifier, secret) ) from her account on chain 1 to the anchor (a smart contract) on chain 1. The form of the commitment means that Alice must pre-commit to which chain she will withdraw or refresh (more on this later) on, in this case, chain 2. The anchor on chain 1 adds Alice's commitment to its Merkle Tree. This emits an event Deposit(_commitment, insertedIndex, block.timestamp) . A relayer picks up this event and opens a proposal to update (or add, if an edge does not already exist) Anchor 2's edge to Anchor 1. Anchor 2 stores a cache of Anchor 1's last 30 historical Merkle roots. If the proposal succeeds, Anchor 1's Merkle root will be added to this cache. This proposal is then voted on by the relayers. This begs the question, why do we have to vote. This is because relayers may choose to submit bogus proposals (of deposits that never happened) or ignore some deposits or do other malicious activities... If the proposal passes, then executeProposal happens. The AnchorHandler then updates Anchor 2's edge to Anchor 1. At this point Anchor 2 is \"aware\" of Alice's deposit into Anchor 1. By this we mean Alice can now submit a valid zero-knowledge proof to withdraw into chain 2 (more on this in the sections below). Basics of Zero-Knowledge Proofs \u00b6 Suppose we have an arithmetic circuit. A satisfying assignment to the circuit consists of inputs such that all the constraints of the circuit are satisfied. A proof of a satisfying assignment for the circuit is a proof that we know some satisfying assignment to the circuit (note the most obvious way to do this is to just provide a satisfying assignment). Now, lets call some of the inputs to the circuit as public and some as private. A zero-knowledge proof of a satisfying assignment for the circuit is a proof that we know some satisfying assignment to the circuit without revealing any information about the private inputs. Withdrawing without Taking Privacy \u00b6 An action which takes privacy is any action that provides information about private data. Alice wishes to withdraw in a way which takes the least amount of privacy possible. Recall that each anchor stores a cache of the last 30 historical Merkle roots of each anchor it has an edge to. To withdraw on chain 2, Alice must prove to the anchor 2 that her deposit commitment is a leaf on a Merkle tree with root in one of these caches. We call such a proof a one-of-many Merkle proof . Let's look at a naive approach that Alice can take to achieve this. Alice sends her secret and nullifier from her address on chain 2 to the anchor on chain 2. She also sends a one-of-many Merkle proof that Poseidon(destinationChainID = 2, nullifier, secret) is a leaf in a Merkle tree with root in one of the caches maintained by anchor 2. The anchor on chain 2 can then verify the one-of-many Merkle proof and release funds to Alice's account on chain 2. Let's now understand where privacy is being taken in this approach. When Alice deposited, she submitted funds along with a commitment to the anchor on chain 1. This data is available to the public. Now, if she publicly reveals her secret and nullifier when she withdraws on chain 2, anyone can can calculate Poseidon(destinationChainID = 2, nullifier, secret) and see that it equals her deposit commitment on chain 1. At this point everyone knows that Alice's accounts on chain 1 and chain 2 are controlled by the same person. If someone knows Alice's address on chain 1, then they also know it on chain 2. Thus, Alice's transfer of funds from chain 1 to chain 2 takes a large amount of privacy if she reveals the secret and nullifier . So our first desiderata is that Alice should be able to withdraw without revealing her secret and nullifier . In a similar vein, sending a one-of-many Merkle proof also requires Alice to reveal her deposit commitment, which in turn takes her privacy. So our second desiderata is that Alice should be able to withdraw without revealing the one-of-many Merkle proof. In the next section, we show how Alice can achieve these two desiderata using zero-knowledge proofs . There is one last thing to consider. If Alice sends the withdrawal proof to chain 2's anchor from her own account, anyone who knows Alice's address on chain 2, knows that it is her executing the withdrawal. To make this process more private, Alice can instead send the proof to a relayer which then submits the proof to anchor. The relayer sets the recipient of the withdrawal funds to be a fresh new account, which Alice controls. This improves Alice's privacy since noone can link her to the fresh new account. So our third desiderata is that Alice should withdraw using a relayer . Using Zero-Knowledge Proofs for Withdrawals \u00b6 We describe a Withdraw circuit such that the constrainsts of these circuits are satisfied if and only if Alice can validly withdraw on chain 2. The Withdraw circuit contains two paramters length and levels . length is the number of anchors connected via an edge across the bridge. levels is the height of the anchor Merkle trees. The private inputs to the circuit are: secret nullifier pathElements[levels] , an array of the Merkle proof elements. pathIndices[levels] , a binary array that indicates whether the corresponding pathElement element is on the left or right side of the Merkle tree. diffs[length] , an artifact of the SetMembership gadget that we describe below. The public inputs to the circuit are: nullifierHash , which equals Poseidon(nullifier, nullifier) . Its use is described in a section below. recipient , the address of the recipient (not used in computation). relayer , the address of the relayer (not used in computation). fee , the fee paid by Alice to the relayer (not used in computation). refund described in a section below (not used in any computation) refreshCommitment described in a section below (not used in any computation) chainID , the destination chain ID, or in our case 2. roots[length] the set of roots Alice's is proving membership in. The Withdraw circuit is actually the composition of smaller gadget circuits: The CommitmentHasher circuit takes in the secret and nullifier and computes the commitment and the nullifierHash . Withdraw then checks that the computed nullifierHash is equal to the public input nulliferHash . This check is needed because otherwise, Alice can submit a bogus nullifierHash and double spend (more on this in a later section). The SetMembership gadget takes in an element and a set and checks whether that element is in the set . Actually, SetMembership also takes in diffs[length] but we will explain more about this later. The ManyMerkleTreeChecker gadget is responsible for checking the one-of-many Merkle proof. It takes in the commitment , pathElements[levels] , pathIndices[levels] and computes the root of the Merkle tree corresponding to these inputs. It also takes in roots[length] and uses the SetMembership gadget to check whether the computed Merkle root (from the previous sentence) is in roots[length] . We describe the individual gadgets in more detail in the pages below: DualMux CommitmentHasher SetMembership ManyMerkleTreeChecker Refund \u00b6 Suppose a relayer submits a correct proof to an anchor on chain 2 and funds are withdrawn into a fresh new account for Alice. Suppose these funds are non-native tokens. Then, Alice cannot spend these tokens since she cannot pay the gas fees for transactions. A way around this is for Alice to pay the relayer an amount equal to fee + refund and have the relayer deposit an amount equal to refund into the fresh account. Preventing Double Spending \u00b6 How do we prevent Alice from double spending her deposit. We split our discussion into to cases: Case 1: Double spending the same deposit on the same chain: This is impossible due to the nullifierHash . When Alice withdraws on chain 2 the nullifierHash = Poseidon(nullifier, nullifier) is stored by the anchor. When she tries to withdraw with the same commitment the anchor will check its set of stored nullifierHash es and will realize she is trying to double spend. Case 2: Double spending the same deposit on different chains: This is impossible because the commitment contains the destination chain. Therefore, if Alice tries to withdraw a commitment with destination chain ID equal to 2 on chain 3, the verifier will reject Alice's proof. Refresh Commitment \u00b6 Recall that Alice must commit to her destination chain when she deposits. Suppose Alice wants to change her destination chain from chain 2 to chain 3. She would have to withdraw on chain 2 and then redeposit into the anchor on chain 2 with her destination chain set to chain 3. A refresh commitment allows these two steps to be combined into one function call. It allows Alice to add a commitment to the Merkle tree on anchor 2 with the destination chain set to chain 3, while simultaneously guaranteeing that she can no longer withdraw her original deposit. The refreshCommitment signal in the Withdraw circuit is set to this new commitment if a refresh commitment is being done. If a traditional withdrawal is being made, the refreshCommitment signal is set to 0. References \u00b6 https://github.com/tornadocash/tornado-core/blob/master/circuits/withdraw.circom","title":"Overview"},{"location":"bridge-protocols/webb/contracts/overview/#protocol-solidity-documentation","text":"Suppose Alice wants to deposit on chain 1 and later wants to withdraw on chain 2.","title":"Protocol-Solidity Documentation"},{"location":"bridge-protocols/webb/contracts/overview/#depositing","text":"She deposits funds and a commitment ( hash(destinationChainID, nullifier, secret) ) from her account on chain 1 to the anchor (a smart contract) on chain 1. The form of the commitment means that Alice must pre-commit to which chain she will withdraw or refresh (more on this later) on, in this case, chain 2. The anchor on chain 1 adds Alice's commitment to its Merkle Tree. This emits an event Deposit(_commitment, insertedIndex, block.timestamp) . A relayer picks up this event and opens a proposal to update (or add, if an edge does not already exist) Anchor 2's edge to Anchor 1. Anchor 2 stores a cache of Anchor 1's last 30 historical Merkle roots. If the proposal succeeds, Anchor 1's Merkle root will be added to this cache. This proposal is then voted on by the relayers. This begs the question, why do we have to vote. This is because relayers may choose to submit bogus proposals (of deposits that never happened) or ignore some deposits or do other malicious activities... If the proposal passes, then executeProposal happens. The AnchorHandler then updates Anchor 2's edge to Anchor 1. At this point Anchor 2 is \"aware\" of Alice's deposit into Anchor 1. By this we mean Alice can now submit a valid zero-knowledge proof to withdraw into chain 2 (more on this in the sections below).","title":"Depositing"},{"location":"bridge-protocols/webb/contracts/overview/#basics-of-zero-knowledge-proofs","text":"Suppose we have an arithmetic circuit. A satisfying assignment to the circuit consists of inputs such that all the constraints of the circuit are satisfied. A proof of a satisfying assignment for the circuit is a proof that we know some satisfying assignment to the circuit (note the most obvious way to do this is to just provide a satisfying assignment). Now, lets call some of the inputs to the circuit as public and some as private. A zero-knowledge proof of a satisfying assignment for the circuit is a proof that we know some satisfying assignment to the circuit without revealing any information about the private inputs.","title":"Basics of Zero-Knowledge Proofs"},{"location":"bridge-protocols/webb/contracts/overview/#withdrawing-without-taking-privacy","text":"An action which takes privacy is any action that provides information about private data. Alice wishes to withdraw in a way which takes the least amount of privacy possible. Recall that each anchor stores a cache of the last 30 historical Merkle roots of each anchor it has an edge to. To withdraw on chain 2, Alice must prove to the anchor 2 that her deposit commitment is a leaf on a Merkle tree with root in one of these caches. We call such a proof a one-of-many Merkle proof . Let's look at a naive approach that Alice can take to achieve this. Alice sends her secret and nullifier from her address on chain 2 to the anchor on chain 2. She also sends a one-of-many Merkle proof that Poseidon(destinationChainID = 2, nullifier, secret) is a leaf in a Merkle tree with root in one of the caches maintained by anchor 2. The anchor on chain 2 can then verify the one-of-many Merkle proof and release funds to Alice's account on chain 2. Let's now understand where privacy is being taken in this approach. When Alice deposited, she submitted funds along with a commitment to the anchor on chain 1. This data is available to the public. Now, if she publicly reveals her secret and nullifier when she withdraws on chain 2, anyone can can calculate Poseidon(destinationChainID = 2, nullifier, secret) and see that it equals her deposit commitment on chain 1. At this point everyone knows that Alice's accounts on chain 1 and chain 2 are controlled by the same person. If someone knows Alice's address on chain 1, then they also know it on chain 2. Thus, Alice's transfer of funds from chain 1 to chain 2 takes a large amount of privacy if she reveals the secret and nullifier . So our first desiderata is that Alice should be able to withdraw without revealing her secret and nullifier . In a similar vein, sending a one-of-many Merkle proof also requires Alice to reveal her deposit commitment, which in turn takes her privacy. So our second desiderata is that Alice should be able to withdraw without revealing the one-of-many Merkle proof. In the next section, we show how Alice can achieve these two desiderata using zero-knowledge proofs . There is one last thing to consider. If Alice sends the withdrawal proof to chain 2's anchor from her own account, anyone who knows Alice's address on chain 2, knows that it is her executing the withdrawal. To make this process more private, Alice can instead send the proof to a relayer which then submits the proof to anchor. The relayer sets the recipient of the withdrawal funds to be a fresh new account, which Alice controls. This improves Alice's privacy since noone can link her to the fresh new account. So our third desiderata is that Alice should withdraw using a relayer .","title":"Withdrawing without Taking Privacy"},{"location":"bridge-protocols/webb/contracts/overview/#using-zero-knowledge-proofs-for-withdrawals","text":"We describe a Withdraw circuit such that the constrainsts of these circuits are satisfied if and only if Alice can validly withdraw on chain 2. The Withdraw circuit contains two paramters length and levels . length is the number of anchors connected via an edge across the bridge. levels is the height of the anchor Merkle trees. The private inputs to the circuit are: secret nullifier pathElements[levels] , an array of the Merkle proof elements. pathIndices[levels] , a binary array that indicates whether the corresponding pathElement element is on the left or right side of the Merkle tree. diffs[length] , an artifact of the SetMembership gadget that we describe below. The public inputs to the circuit are: nullifierHash , which equals Poseidon(nullifier, nullifier) . Its use is described in a section below. recipient , the address of the recipient (not used in computation). relayer , the address of the relayer (not used in computation). fee , the fee paid by Alice to the relayer (not used in computation). refund described in a section below (not used in any computation) refreshCommitment described in a section below (not used in any computation) chainID , the destination chain ID, or in our case 2. roots[length] the set of roots Alice's is proving membership in. The Withdraw circuit is actually the composition of smaller gadget circuits: The CommitmentHasher circuit takes in the secret and nullifier and computes the commitment and the nullifierHash . Withdraw then checks that the computed nullifierHash is equal to the public input nulliferHash . This check is needed because otherwise, Alice can submit a bogus nullifierHash and double spend (more on this in a later section). The SetMembership gadget takes in an element and a set and checks whether that element is in the set . Actually, SetMembership also takes in diffs[length] but we will explain more about this later. The ManyMerkleTreeChecker gadget is responsible for checking the one-of-many Merkle proof. It takes in the commitment , pathElements[levels] , pathIndices[levels] and computes the root of the Merkle tree corresponding to these inputs. It also takes in roots[length] and uses the SetMembership gadget to check whether the computed Merkle root (from the previous sentence) is in roots[length] . We describe the individual gadgets in more detail in the pages below: DualMux CommitmentHasher SetMembership ManyMerkleTreeChecker","title":"Using Zero-Knowledge Proofs for Withdrawals"},{"location":"bridge-protocols/webb/contracts/overview/#refund","text":"Suppose a relayer submits a correct proof to an anchor on chain 2 and funds are withdrawn into a fresh new account for Alice. Suppose these funds are non-native tokens. Then, Alice cannot spend these tokens since she cannot pay the gas fees for transactions. A way around this is for Alice to pay the relayer an amount equal to fee + refund and have the relayer deposit an amount equal to refund into the fresh account.","title":"Refund"},{"location":"bridge-protocols/webb/contracts/overview/#preventing-double-spending","text":"How do we prevent Alice from double spending her deposit. We split our discussion into to cases: Case 1: Double spending the same deposit on the same chain: This is impossible due to the nullifierHash . When Alice withdraws on chain 2 the nullifierHash = Poseidon(nullifier, nullifier) is stored by the anchor. When she tries to withdraw with the same commitment the anchor will check its set of stored nullifierHash es and will realize she is trying to double spend. Case 2: Double spending the same deposit on different chains: This is impossible because the commitment contains the destination chain. Therefore, if Alice tries to withdraw a commitment with destination chain ID equal to 2 on chain 3, the verifier will reject Alice's proof.","title":"Preventing Double Spending"},{"location":"bridge-protocols/webb/contracts/overview/#refresh-commitment","text":"Recall that Alice must commit to her destination chain when she deposits. Suppose Alice wants to change her destination chain from chain 2 to chain 3. She would have to withdraw on chain 2 and then redeposit into the anchor on chain 2 with her destination chain set to chain 3. A refresh commitment allows these two steps to be combined into one function call. It allows Alice to add a commitment to the Merkle tree on anchor 2 with the destination chain set to chain 3, while simultaneously guaranteeing that she can no longer withdraw her original deposit. The refreshCommitment signal in the Withdraw circuit is set to this new commitment if a refresh commitment is being done. If a traditional withdrawal is being made, the refreshCommitment signal is set to 0.","title":"Refresh Commitment"},{"location":"bridge-protocols/webb/contracts/overview/#references","text":"https://github.com/tornadocash/tornado-core/blob/master/circuits/withdraw.circom","title":"References"},{"location":"bridge-protocols/webb/pallets/overview/","text":"Substrate implementation of the Webb Protocol \u00b6 Here you can information about the pallets used in the Substrate version of the Webb Protocol.","title":"Pallets"},{"location":"bridge-protocols/webb/pallets/overview/#substrate-implementation-of-the-webb-protocol","text":"Here you can information about the pallets used in the Substrate version of the Webb Protocol.","title":"Substrate implementation of the Webb Protocol"},{"location":"mixer-protocols/tornado/deployments/","text":"Mixer Deployments \u00b6 If you'd like to interact with the mixers programmatically, we have live deployments at the contracts below. Mainnets \u00b6 Harmony \u00b6 Name Source Address 100 ONE Mixer NativeAnchor.sol 0x2B9A7085Afba278BEc6bBfFb399A3C042ED05046 10000 ONE mixer NativeAnchor.sol 0x4b271E1E67B3eE56467599cd46f1F74A5a369c72 Hasher Hasher.json 0x9C6b3365EBD9273d991cAb377aa6585735B1Cd43 Verifier Verifier.sol 0x6032dF7d3494c83BBB9095169844aeB0dea1c7C5 Shiden \u00b6 Name Source Address 10 SDN Mixer NativeAnchor.sol 0x2B9A7085Afba278BEc6bBfFb399A3C042ED05046 1000 SDN mixer NativeAnchor.sol 0x548555a3275B6fadD5d2B9740a7655cB7f856148 Hasher Hasher.json 0x9C6b3365EBD9273d991cAb377aa6585735B1Cd43 Verifier Verifier.sol 0x6032dF7d3494c83BBB9095169844aeB0dea1c7C5 Edgeware \u00b6 Name Source Address 10000 EDG Mixer NativeAnchor.sol 0x2B9A7085Afba278BEc6bBfFb399A3C042ED05046 Hasher Hasher.json 0x9C6b3365EBD9273d991cAb377aa6585735B1Cd43 Verifier Verifier.sol 0x6032dF7d3494c83BBB9095169844aeB0dea1c7C5 Testnets \u00b6 Rinkeby \u00b6 Name Source Address .1 ETH Mixer NativeAnchor.sol 0x626FEc5Ffa7Bf1EE8CEd7daBdE545630473E3ABb 1 ETH Mixer NativeAnchor.sol 0x979cBd4917e81447983ef87591B9E1ab21727a61 Hasher Hasher.json 0xE6C5D1c6cc3c6772694d75f61E949daB100a4489 Verifier Verifier.sol 0x95A5CcfCa50F7Dcf410CE397Bb7Becf1b42Ae601 Harmony Testnet Shard 1 \u00b6 Harmony shares Webb's vision of an interoperable future, and we are happy to have Harmony as one of our first supported chains. Name Source Address 100 ONE mixer NativeAnchor.sol 0x7cd1F52e5EEdf753e99D945276a725CE533AaD1a 1000 ONE mixer NativeAnchor.sol 0xD7f9BB9957100310aD397D2bA31771D939BD4731 10000 ONE mixer NativeAnchor.sol 0xeE2eB8F142e48e5D1bDD34e0924Ed3B4aa0d4222 100000 ONE mixer NativeAnchor.sol 0x7cd173094eF78FFAeDee4e14576A73a79aA716ac Hasher Hasher.json 0x96B8Bff1fE9a9c0656b84d7bd1013faD2435Edc0 Verifier Verifier.sol 0xca2c45fe334fBb9d9356AaB291842b964DB9B0E3 Beresheet EVM \u00b6 Edgeware is the first supported EVM in the substrate ecosystem. This ecosystem was born out of interoperable ideals. Name Source Address 100 tEDG mixer NativeAnchor.sol 0xc0d863EE313636F067dCF89e6ea904AD5f8DEC65 1000 tEDG mixer NativeAnchor.sol 0xc7c6152214d0Db4e161Fa67fB62811Be7326834A Hasher Hasher.json 0x96B8Bff1fE9a9c0656b84d7bd1013faD2435Edc0 Verifier Verifier.sol 0xca2c45fe334fBb9d9356AaB291842b964DB9B0E3","title":"Deployments"},{"location":"mixer-protocols/tornado/deployments/#mixer-deployments","text":"If you'd like to interact with the mixers programmatically, we have live deployments at the contracts below.","title":"Mixer Deployments"},{"location":"mixer-protocols/tornado/deployments/#mainnets","text":"","title":"Mainnets"},{"location":"mixer-protocols/tornado/deployments/#harmony","text":"Name Source Address 100 ONE Mixer NativeAnchor.sol 0x2B9A7085Afba278BEc6bBfFb399A3C042ED05046 10000 ONE mixer NativeAnchor.sol 0x4b271E1E67B3eE56467599cd46f1F74A5a369c72 Hasher Hasher.json 0x9C6b3365EBD9273d991cAb377aa6585735B1Cd43 Verifier Verifier.sol 0x6032dF7d3494c83BBB9095169844aeB0dea1c7C5","title":"Harmony"},{"location":"mixer-protocols/tornado/deployments/#shiden","text":"Name Source Address 10 SDN Mixer NativeAnchor.sol 0x2B9A7085Afba278BEc6bBfFb399A3C042ED05046 1000 SDN mixer NativeAnchor.sol 0x548555a3275B6fadD5d2B9740a7655cB7f856148 Hasher Hasher.json 0x9C6b3365EBD9273d991cAb377aa6585735B1Cd43 Verifier Verifier.sol 0x6032dF7d3494c83BBB9095169844aeB0dea1c7C5","title":"Shiden"},{"location":"mixer-protocols/tornado/deployments/#edgeware","text":"Name Source Address 10000 EDG Mixer NativeAnchor.sol 0x2B9A7085Afba278BEc6bBfFb399A3C042ED05046 Hasher Hasher.json 0x9C6b3365EBD9273d991cAb377aa6585735B1Cd43 Verifier Verifier.sol 0x6032dF7d3494c83BBB9095169844aeB0dea1c7C5","title":"Edgeware"},{"location":"mixer-protocols/tornado/deployments/#testnets","text":"","title":"Testnets"},{"location":"mixer-protocols/tornado/deployments/#rinkeby","text":"Name Source Address .1 ETH Mixer NativeAnchor.sol 0x626FEc5Ffa7Bf1EE8CEd7daBdE545630473E3ABb 1 ETH Mixer NativeAnchor.sol 0x979cBd4917e81447983ef87591B9E1ab21727a61 Hasher Hasher.json 0xE6C5D1c6cc3c6772694d75f61E949daB100a4489 Verifier Verifier.sol 0x95A5CcfCa50F7Dcf410CE397Bb7Becf1b42Ae601","title":"Rinkeby"},{"location":"mixer-protocols/tornado/deployments/#harmony-testnet-shard-1","text":"Harmony shares Webb's vision of an interoperable future, and we are happy to have Harmony as one of our first supported chains. Name Source Address 100 ONE mixer NativeAnchor.sol 0x7cd1F52e5EEdf753e99D945276a725CE533AaD1a 1000 ONE mixer NativeAnchor.sol 0xD7f9BB9957100310aD397D2bA31771D939BD4731 10000 ONE mixer NativeAnchor.sol 0xeE2eB8F142e48e5D1bDD34e0924Ed3B4aa0d4222 100000 ONE mixer NativeAnchor.sol 0x7cd173094eF78FFAeDee4e14576A73a79aA716ac Hasher Hasher.json 0x96B8Bff1fE9a9c0656b84d7bd1013faD2435Edc0 Verifier Verifier.sol 0xca2c45fe334fBb9d9356AaB291842b964DB9B0E3","title":"Harmony Testnet Shard 1"},{"location":"mixer-protocols/tornado/deployments/#beresheet-evm","text":"Edgeware is the first supported EVM in the substrate ecosystem. This ecosystem was born out of interoperable ideals. Name Source Address 100 tEDG mixer NativeAnchor.sol 0xc0d863EE313636F067dCF89e6ea904AD5f8DEC65 1000 tEDG mixer NativeAnchor.sol 0xc7c6152214d0Db4e161Fa67fB62811Be7326834A Hasher Hasher.json 0x96B8Bff1fE9a9c0656b84d7bd1013faD2435Edc0 Verifier Verifier.sol 0xca2c45fe334fBb9d9356AaB291842b964DB9B0E3","title":"Beresheet EVM"},{"location":"mixer-protocols/tornado/overview/","text":"Tornado Core \u00b6 The tornado core library defines a set of Solidity smart contracts for mixers. These contracts are used in the dapp for EVM interactions.","title":"Overview"},{"location":"mixer-protocols/tornado/overview/#tornado-core","text":"The tornado core library defines a set of Solidity smart contracts for mixers. These contracts are used in the dapp for EVM interactions.","title":"Tornado Core"},{"location":"mixer-protocols/tornado/contracts/Anchor/","text":"Anchor.sol \u00b6 Description \u00b6 An abstract contract that requires child classes to implement appropriate verification and processes for deposits and withdrawals. Variables \u00b6 verifier \u00b6 Type: public immutable IVerifier denomination \u00b6 Type: public immutable uint256 nullifierHashes \u00b6 Type: public mapping(bytes32 => bool) commitments \u00b6 Type: public mapping(bytes32 => bool) Constructor \u00b6 Details Signature constructor(IVerifier _verifier, IHasher _hasher, uint256 _denomination, uint256 _treeHeight) MerkleTreeWithHistory(_merkleTreeHeight, _hasher) External Functions \u00b6 Calls to deposits require a commitment, which is a hash of some secret values. Deposit \u00b6 Details Signature deposit(bytes32 _commitment) Requires require(..., \"commitment has been submitted\") Emits Deposit Withdraw \u00b6 Details Signature withdraw(address _recipient, address _relayer, uint256 _fee, uint256 _refund) Requires require(_fee <= denomination) require(..., \"The not has already been spent\") require(..., \"Cannot find your merkle root\") require(..., \"Invalid withdraw proof\") Emits Withdraw View Functions \u00b6 isSpent \u00b6 Details Signature isSpent(bytes32 _nullifierHash) public view returns (bool) isSpentArray \u00b6 Details Signature isSpentArray(bytes32[] calldata _nullifierHashes) external view returns (bool[] memory spent) Events \u00b6 Deposit \u00b6 Signature : Deposit(bytes32 indexed commitment, uint32 leafIndex, uint256 timestamp) Withdraw \u00b6 Signature : Withdrawal(address to, bytes32 nullifierHash, address indexed relayer, uint256 fee)","title":"Anchor"},{"location":"mixer-protocols/tornado/contracts/Anchor/#anchorsol","text":"","title":"Anchor.sol"},{"location":"mixer-protocols/tornado/contracts/Anchor/#description","text":"An abstract contract that requires child classes to implement appropriate verification and processes for deposits and withdrawals.","title":"Description"},{"location":"mixer-protocols/tornado/contracts/Anchor/#variables","text":"","title":"Variables"},{"location":"mixer-protocols/tornado/contracts/Anchor/#verifier","text":"Type: public immutable IVerifier","title":"verifier"},{"location":"mixer-protocols/tornado/contracts/Anchor/#denomination","text":"Type: public immutable uint256","title":"denomination"},{"location":"mixer-protocols/tornado/contracts/Anchor/#nullifierhashes","text":"Type: public mapping(bytes32 => bool)","title":"nullifierHashes"},{"location":"mixer-protocols/tornado/contracts/Anchor/#commitments","text":"Type: public mapping(bytes32 => bool)","title":"commitments"},{"location":"mixer-protocols/tornado/contracts/Anchor/#constructor","text":"Details Signature constructor(IVerifier _verifier, IHasher _hasher, uint256 _denomination, uint256 _treeHeight) MerkleTreeWithHistory(_merkleTreeHeight, _hasher)","title":"Constructor"},{"location":"mixer-protocols/tornado/contracts/Anchor/#external-functions","text":"Calls to deposits require a commitment, which is a hash of some secret values.","title":"External Functions"},{"location":"mixer-protocols/tornado/contracts/Anchor/#deposit","text":"Details Signature deposit(bytes32 _commitment) Requires require(..., \"commitment has been submitted\") Emits Deposit","title":"Deposit"},{"location":"mixer-protocols/tornado/contracts/Anchor/#withdraw","text":"Details Signature withdraw(address _recipient, address _relayer, uint256 _fee, uint256 _refund) Requires require(_fee <= denomination) require(..., \"The not has already been spent\") require(..., \"Cannot find your merkle root\") require(..., \"Invalid withdraw proof\") Emits Withdraw","title":"Withdraw"},{"location":"mixer-protocols/tornado/contracts/Anchor/#view-functions","text":"","title":"View Functions"},{"location":"mixer-protocols/tornado/contracts/Anchor/#isspent","text":"Details Signature isSpent(bytes32 _nullifierHash) public view returns (bool)","title":"isSpent"},{"location":"mixer-protocols/tornado/contracts/Anchor/#isspentarray","text":"Details Signature isSpentArray(bytes32[] calldata _nullifierHashes) external view returns (bool[] memory spent)","title":"isSpentArray"},{"location":"mixer-protocols/tornado/contracts/Anchor/#events","text":"","title":"Events"},{"location":"mixer-protocols/tornado/contracts/Anchor/#deposit_1","text":"Signature : Deposit(bytes32 indexed commitment, uint32 leafIndex, uint256 timestamp)","title":"Deposit"},{"location":"mixer-protocols/tornado/contracts/Anchor/#withdraw_1","text":"Signature : Withdrawal(address to, bytes32 nullifierHash, address indexed relayer, uint256 fee)","title":"Withdraw"},{"location":"mixer-protocols/tornado/contracts/IHasher/","text":"IHasher \u00b6 Description \u00b6 The hasher for contracts in tornado core uses MiMC. It is generated from circom's mimcsponge_gencontract.js MiMCSponge \u00b6 Details Signature MiMCSponge(uint256 in_xL, uint256 in_xR) external pure returns (uint256 xL, uint256 xR)","title":"IHasher"},{"location":"mixer-protocols/tornado/contracts/IHasher/#ihasher","text":"","title":"IHasher"},{"location":"mixer-protocols/tornado/contracts/IHasher/#description","text":"The hasher for contracts in tornado core uses MiMC. It is generated from circom's mimcsponge_gencontract.js","title":"Description"},{"location":"mixer-protocols/tornado/contracts/IHasher/#mimcsponge","text":"Details Signature MiMCSponge(uint256 in_xL, uint256 in_xR) external pure returns (uint256 xL, uint256 xR)","title":"MiMCSponge"},{"location":"mixer-protocols/tornado/contracts/IVerifier/","text":"IVerifier \u00b6 Description \u00b6 The verifier exposes the verifyProof view function and is generated from the verifying key for the corresponding SNARK. verifyProof \u00b6 Details Signature verifyProof(bytes memory _proof, uint256[6] memory _input) external returns (bool)","title":"IVerifier"},{"location":"mixer-protocols/tornado/contracts/IVerifier/#iverifier","text":"","title":"IVerifier"},{"location":"mixer-protocols/tornado/contracts/IVerifier/#description","text":"The verifier exposes the verifyProof view function and is generated from the verifying key for the corresponding SNARK.","title":"Description"},{"location":"mixer-protocols/tornado/contracts/IVerifier/#verifyproof","text":"Details Signature verifyProof(bytes memory _proof, uint256[6] memory _input) external returns (bool)","title":"verifyProof"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/","text":"MerkleTreeWithHistory.sol \u00b6 Description \u00b6 The MerkleTreeWithHistory is the data structure which holds the commitments of deposits - which are hashes of secret values picked by the user. When a user wishes to withdraw from the mixer, the user needs to submit a proof which shows the knowledge of these secret values. This proof needs this merkle tree to calculate the path from the leaves (commitments) to the root. Variables \u00b6 hasher \u00b6 Type: public immutable IHasher levels \u00b6 Type: public immutable uint32 filledSubtrees \u00b6 Type: public mapping(uint256 => bytes32) roots \u00b6 Type: public mapping(uint256 => bytes32) ROOT_HISTORY_SIZE \u00b6 Type: public constant uint32 currentRootIndex \u00b6 Type: public uint32 nextIndex \u00b6 Type: public uint32 Constructor \u00b6 Details Signature constructor(uint32 _levels, IHasher _hasher) Requires require(_levels > 0) require(_levels < 32) External Functions \u00b6 hashLeftRight \u00b6 Details Signature function hashLeftRight(IHasher _hasher, bytes32 _left, bytes32 _right) public pure returns (bytes32) Requires require(..., \"_left should be inside the field\") require(..., \"_right should be instide the field\") View Functions \u00b6 isKnownRoot \u00b6 Details Signature isKnownRoot(bytes32 _root) public view returns (bool) getLastRoot \u00b6 Details Signature getLastRoot() public view returns (bytes32) zeros \u00b6 Details Signature zeros(uint256 i) public pure returns (bytes32) Internal Functions \u00b6 _insert \u00b6 Details Signature _insert(bytes32 _leaf) internal returns (uint32 index) Requires require(..., \"merkle tree is full\")","title":"MerkleTreeWithHistory"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#merkletreewithhistorysol","text":"","title":"MerkleTreeWithHistory.sol"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#description","text":"The MerkleTreeWithHistory is the data structure which holds the commitments of deposits - which are hashes of secret values picked by the user. When a user wishes to withdraw from the mixer, the user needs to submit a proof which shows the knowledge of these secret values. This proof needs this merkle tree to calculate the path from the leaves (commitments) to the root.","title":"Description"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#variables","text":"","title":"Variables"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#hasher","text":"Type: public immutable IHasher","title":"hasher"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#levels","text":"Type: public immutable uint32","title":"levels"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#filledsubtrees","text":"Type: public mapping(uint256 => bytes32)","title":"filledSubtrees"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#roots","text":"Type: public mapping(uint256 => bytes32)","title":"roots"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#root_history_size","text":"Type: public constant uint32","title":"ROOT_HISTORY_SIZE"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#currentrootindex","text":"Type: public uint32","title":"currentRootIndex"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#nextindex","text":"Type: public uint32","title":"nextIndex"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#constructor","text":"Details Signature constructor(uint32 _levels, IHasher _hasher) Requires require(_levels > 0) require(_levels < 32)","title":"Constructor"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#external-functions","text":"","title":"External Functions"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#hashleftright","text":"Details Signature function hashLeftRight(IHasher _hasher, bytes32 _left, bytes32 _right) public pure returns (bytes32) Requires require(..., \"_left should be inside the field\") require(..., \"_right should be instide the field\")","title":"hashLeftRight"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#view-functions","text":"","title":"View Functions"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#isknownroot","text":"Details Signature isKnownRoot(bytes32 _root) public view returns (bool)","title":"isKnownRoot"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#getlastroot","text":"Details Signature getLastRoot() public view returns (bytes32)","title":"getLastRoot"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#zeros","text":"Details Signature zeros(uint256 i) public pure returns (bytes32)","title":"zeros"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#internal-functions","text":"","title":"Internal Functions"},{"location":"mixer-protocols/tornado/contracts/MerkleTreeWithHistory/#_insert","text":"Details Signature _insert(bytes32 _leaf) internal returns (uint32 index) Requires require(..., \"merkle tree is full\")","title":"_insert"},{"location":"mixer-protocols/tornado/contracts/NativeAnchor/","text":"NativeAnchor.sol \u00b6 Description \u00b6 A concrete instance of a mixer which deals with the native currency of the chain. Constructor \u00b6 Details Signature constructor(IVerifier _verifier, IHasher _hasher, uint256 _denomination, uint256 _merkleTreeHeight) Anchor(_verifier, _hasher, _denomination, _merkleTreeHeight) {} Internal Functions \u00b6 _processWithdraw \u00b6 Details Signature _processWithdraw(address _recipient, address _relayer, uint256 _fee, uint256 _refund) internal override Requires require(msg.value == 0) require(_refund == 0) require(..., \"payment to _recipient did not go through\") require(..., \"payment to _relayer did not go through\") _processDeposit \u00b6 Details Signature _processDeposit() internal override Requires require(msg.value == denomination)","title":"NativeAnchor"},{"location":"mixer-protocols/tornado/contracts/NativeAnchor/#nativeanchorsol","text":"","title":"NativeAnchor.sol"},{"location":"mixer-protocols/tornado/contracts/NativeAnchor/#description","text":"A concrete instance of a mixer which deals with the native currency of the chain.","title":"Description"},{"location":"mixer-protocols/tornado/contracts/NativeAnchor/#constructor","text":"Details Signature constructor(IVerifier _verifier, IHasher _hasher, uint256 _denomination, uint256 _merkleTreeHeight) Anchor(_verifier, _hasher, _denomination, _merkleTreeHeight) {}","title":"Constructor"},{"location":"mixer-protocols/tornado/contracts/NativeAnchor/#internal-functions","text":"","title":"Internal Functions"},{"location":"mixer-protocols/tornado/contracts/NativeAnchor/#_processwithdraw","text":"Details Signature _processWithdraw(address _recipient, address _relayer, uint256 _fee, uint256 _refund) internal override Requires require(msg.value == 0) require(_refund == 0) require(..., \"payment to _recipient did not go through\") require(..., \"payment to _relayer did not go through\")","title":"_processWithdraw"},{"location":"mixer-protocols/tornado/contracts/NativeAnchor/#_processdeposit","text":"Details Signature _processDeposit() internal override Requires require(msg.value == denomination)","title":"_processDeposit"},{"location":"relayer/http-endpoints/","text":"Exposed endpoints the client can query to obtain data about their exposed data, the relayer, or mixer deployments. API v1 \u00b6 IP \u00b6 Relayers can let the client know of their IP address. This is informative to the client, as their privacy is potentially compromised by this information. /api/v1/ip Response Format { \"ip\": <string> } Response Explanation The IP address from which the request was sent to the relayer. Info \u00b6 A client should make a call to the relayer to find which chains it supports, as well as the fees and relayer address to include in the proof generation. /api/v1/info Response Format { evm: { [networkName]: { \"withdrawFeePercentage\": <number>, \"account\": <string>, \"enableLeavesWatcher\": <boolean>, }, ... } } Response Explanation withdrawFeePercentage : The minimum amount of percentage that the relayer requires to send a transaction on the client's behalf. account : The reward account of the relayer, which will collect the fee. enableLeavesWatcher : A boolean flag indicating if the relayer is able to provide a client with the leaves that make up the merkle tree of a particular mixer. EVM Mixer Leaves \u00b6 A client can query the relayer for the leaves (commitments) of a mixer deployment. This information is necessary for building the merkle tree on the client side, in order to build the proof of secrets for a particular commitment. The client can query the blockchain directly, but getting the information from a relayer will be much quicker. chainID: A hex string for the appropriate chain id contractAddress: The contract address of the mixer to query /api/v1/leaves/:chainId/:contractAddress Response Format { \"leaves\": [ <hex-string>, <hex-string>, ... ], \"lastQueriedBlock\": <hex-string> } Response explanation The leaves will be properly indexed in the array. The lastQueriedBlock will contain the block number of the deposit transaction which created the leaf in the last entry of the leaves array.","title":"Http Endpoints"},{"location":"relayer/http-endpoints/#api-v1","text":"","title":"API v1"},{"location":"relayer/http-endpoints/#ip","text":"Relayers can let the client know of their IP address. This is informative to the client, as their privacy is potentially compromised by this information. /api/v1/ip Response Format { \"ip\": <string> } Response Explanation The IP address from which the request was sent to the relayer.","title":"IP"},{"location":"relayer/http-endpoints/#info","text":"A client should make a call to the relayer to find which chains it supports, as well as the fees and relayer address to include in the proof generation. /api/v1/info Response Format { evm: { [networkName]: { \"withdrawFeePercentage\": <number>, \"account\": <string>, \"enableLeavesWatcher\": <boolean>, }, ... } } Response Explanation withdrawFeePercentage : The minimum amount of percentage that the relayer requires to send a transaction on the client's behalf. account : The reward account of the relayer, which will collect the fee. enableLeavesWatcher : A boolean flag indicating if the relayer is able to provide a client with the leaves that make up the merkle tree of a particular mixer.","title":"Info"},{"location":"relayer/http-endpoints/#evm-mixer-leaves","text":"A client can query the relayer for the leaves (commitments) of a mixer deployment. This information is necessary for building the merkle tree on the client side, in order to build the proof of secrets for a particular commitment. The client can query the blockchain directly, but getting the information from a relayer will be much quicker. chainID: A hex string for the appropriate chain id contractAddress: The contract address of the mixer to query /api/v1/leaves/:chainId/:contractAddress Response Format { \"leaves\": [ <hex-string>, <hex-string>, ... ], \"lastQueriedBlock\": <hex-string> } Response explanation The leaves will be properly indexed in the array. The lastQueriedBlock will contain the block number of the deposit transaction which created the leaf in the last entry of the leaves array.","title":"EVM Mixer Leaves"},{"location":"relayer/overview/","text":"The Relayer offers the end-user privacy and receives fees from the users for providing this service. Relayers can be configured to listen to only the networks that they are interested in. Download the code and start supporting the network!","title":"Overview"},{"location":"relayer/setup/","text":"This document serves as instructions for setting up a Webb Relayer at a publicly accessible endpoint. It will fulfill the requirements for listing your relayer on app.webb.tools. In order to integrate your relayer to app.webb.tools, please submit a PR. - Connections available via https and wss on your domain. Instructions \u00b6 These instructions will assume the user has created a cloud server on Ubuntu 20.04, and is logged into a user with sudo permissions. By the end of these instructions, the relayer will be running and accessible via your endpoint with nginx behind a reverse proxy. Basic Environment Setup \u00b6 ### Setup the machine's environment ### # Update ubuntu packages sudo apt update && sudo apt upgrade # Update snap packages sudo snap install core; sudo snap refresh core # Install dependencies sudo apt install gcc cmake pkg-config libssl-dev git clang libclang-dev sudo apt install build-essential # Install rust curl https://sh.rustup.rs -sSf | sh -s -- -y export PATH=~/.cargo/bin:$PATH source ~/.cargo/env # Install certbot sudo snap install --classic certbot && sudo ln -s /snap/bin/certbot /usr/bin/certbot # Get the relayer code git clone https://github.com/webb-tools/relayer.git # Build the executable cd relayer && cargo build --release Relayer Configuration \u00b6 Create your .env file in the base directory of the project. A list of potential networks to support is defined below. Make sure to provide the private key with funds on the appropriate network. Remove networks which you do not wish to support from below. List of supported networks .env # Mainnets WEBB_EVM_HARMONYMAINNET0_ENABLED=true WEBB_EVM_SHIDEN_ENABLED=true HARMONYMAINNET0_PRIVATE_KEY=<0x_PREFIXED_PRIVATE_KEY_AS_HEX_STRING> SHIDEN_PRIVATE_KEY=<0x_PREFIXED_PRIVATE_KEY_AS_HEX_STRING> # Testnets WEBB_EVM_HARMONYTESTNET0_ENABLED=true WEBB_EVM_HARMONYTESTNET1_ENABLED=true WEBB_EVM_RINKEBY_ENABLED=true WEBB_EVM_GOERLI_ENABLED=true WEBB_EVM_ROPSTEN_ENABLED=true WEBB_EVM_BERESHEET_ENABLED=true HARMONYTESTNET0_PRIVATE_KEY=<0x_PREFIXED_PRIVATE_KEY_AS_HEX_STRING> HARMONYTESTNET1_PRIVATE_KEY=<0x_PREFIXED_PRIVATE_KEY_AS_HEX_STRING> RINKEBY_PRIVATE_KEY=<0x_PREFIXED_PRIVATE_KEY_AS_HEX_STRING> GOERLI_PRIVATE_KEY=<0x_PREFIXED_PRIVATE_KEY_AS_HEX_STRING> ROPSTEN_PRIVATE_KEY=<0x_PREFIXED_PRIVATE_KEY_AS_HEX_STRING> BERESHEET_PRIVATE_KEY=<0x_PREFIXED_PRIVATE_KEY_AS_HEX_STRING> Fine-tuned Configuration \u00b6 All configurations in the repo can be tuned to your preference. Below is a line-by-line explanation of all configurable values for an example configuration supporting Rinkeby: Rinkeby configuration [evm.rinkeby] # Endpoints to archival nodes which are running for the given network http-endpoint = \"https://rinkeby.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161\" ws-endpoint = \"wss://rinkeby.infura.io/ws/v3/9aa3d95b3bc440fa88ea12eaa4456161\" # The block explorer of the given network for clickable transactions in relayer logs explorer = \"https://rinkeby.etherscan.io\" # The chain-id of the network chain-id = 4 # The hex string private key correlating to a value in the .env file. private-key = \"$RINKEBY_PRIVATE_KEY\" # A network configuration can define multiple contracts to listen to [[evm.rinkeby.contracts]] # The 'Tornado' contract is a tornado cash implementation contract = \"Tornado\" # The address for the particular contract address = \"0x626FEc5Ffa7Bf1EE8CEd7daBdE545630473E3ABb\" # The relayer may query for previous state starting from the deployed-at block until the present block. deployed-at = 8896800 # The denomination for mixers - applicable for 'Tornado' and 'Anchor' contracts size = 0.1 # If the events-watcher is enabled, the relayer will poll for events of this contract at the interval and update its own # storage. Used for providing leaves to clients that request them, and necessary for integration in the dapp. events-watcher = { enabled = false, polling-interval = 15000 } # The fee defined by the relayer for sending transactions on behalf of clients. withdraw-fee-percentage = 0.05 # Configurable gaslimit for transactions. Set this to a reasonable value for the given chain. withdraw-gaslimit = \"0x350000\" [[evm.rinkeby.contracts]] # An 'Anchor' contract is the building block of the bridge protocol. It provides privacy like a 'Tornado' # contract and maintains state for the anchors which link to it for cross-chain functionality. contract = \"Anchor\" address = \"0x15A66977f0A9D21e09eB6C1B42b001aF992f0C8f\" deployed-at = 9568750 size = 0.01 events-watcher = { enabled = true, polling-interval = 15000 } withdraw-fee-percentage = 0 withdraw-gaslimit = \"0x350000\" linked-anchors = [ { chain = \"ropsten\", address = \"0x0711Ea63FDEDD2c8a9d3C9340a5A8F6cd84b6A92\" }, { chain = \"goerli\", address = \"0x025348e15e9d5529E5A4A55E8eA7eC923b7fB8b6\" }, ] Relayer setup \u00b6 Setup the relayer as a system service: # Create the service file sudo touch /etc/systemd/system/webb-relayer.service # This assumes a config.toml file has been setup in a config/ directory # and the repo has been cloned in the home directory of the user # Paste the following into the service file, and replace the <user>: [Unit] Description=WebbRelayer [Service] Type=exec WorkingDirectory=/home/<user>/relayer ExecStart=/home/<user>/relayer/target/release/webb-relayer -c /home/<user>/relayer/config/ -vvv [Install] WantedBy=multi-user.target Kick off the system service: sudo systemctl enable webb-relayer && sudo systemctl start webb-relayer Nginx Setup \u00b6 Configure your registered domain name with your cloud service provider. Install nginx if it isn't already on your machine: sudo apt install nginx First, we will configure the endpoint linked to your at port 80 for certificate generation Create nginx site files for your domain: cd /etc/nginx/sites-available && sudo cp default <domain name> && sudo ln -s /etc/nginx/sites-available/<domain name> /etc/nginx/sites-enabled/ Modify the nginx sites-available file to: server { listen 80; listen [::]:80; root /var/www/<domain name>/html; index index.html index.htm index.nginx-debian.html; server_name <domain name>; location / { try_files $uri $uri/ =404; } } Check the nginx configuration sudo nginx -t If no issues exist, restart the nginx service sudo systemctl restart nginx Next we will create the self-signed certificate and reconfigure for https and wss support Create the self-signed certificate: sudo certbot certonly --nginx Modify the nginx site file: map $http_upgrade $connection_upgrade { default upgrade; '' close; } server { # SSL configuration # listen 443 ssl; listen [::]:443 ssl; root /var/www/<domain name>/html; server_name <domain name>; ssl_certificate /etc/letsencrypt/live/<domain name>/cert.pem; ssl_certificate_key /etc/letsencrypt/live/<domain name>/privkey.pem; ssl_session_timeout 5m; ssl_protocols SSLv2 SSLv3 TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / { proxy_pass http://127.0.0.1:9955; proxy_pass_request_headers on; proxy_http_version 1.1; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $connection_upgrade; } } Check nginx configuration and restart. Monitoring Setup \u00b6 Relayers will want to setup monitoring to ensure maximum uptime and automatic restarts when things go awry. sudo apt install -y monit modify the monitrc file at: /etc/monit/monitrc set httpd port 2812 and use address localhost allow localhost set daemon 10 set log /var/log/monit.log set idfile /var/lib/monit/id set statefile /var/lib/monit/state set eventqueue basedir /var/lib/monit/events slots 100 check process webb-relayer matching target/release/webb-relayer start program = \"/bin/systemctl restart webb-relayer\" stop program = \"/bin/systemctl kill webb-relayer\" if cpu > 90% for 20 cycles then exec \"/bin/systemctl stop webb-relayer\" and repeat every 10 cycles if cpu > 90% for 64 cycles then exec \"/bin/systemctl kill webb-relayer\" and repeat every 10 cycles if cpu > 90% for 64 cycles then alert if does not exist for 1 cycles then start restart monit and validate: sudo monit reload && sudo monit validate Dapp Integration \u00b6 After completing the above steps, submit a PR with changes for your https endpoint: Webb Dapp","title":"Setup"},{"location":"relayer/setup/#instructions","text":"These instructions will assume the user has created a cloud server on Ubuntu 20.04, and is logged into a user with sudo permissions. By the end of these instructions, the relayer will be running and accessible via your endpoint with nginx behind a reverse proxy.","title":"Instructions"},{"location":"relayer/setup/#basic-environment-setup","text":"### Setup the machine's environment ### # Update ubuntu packages sudo apt update && sudo apt upgrade # Update snap packages sudo snap install core; sudo snap refresh core # Install dependencies sudo apt install gcc cmake pkg-config libssl-dev git clang libclang-dev sudo apt install build-essential # Install rust curl https://sh.rustup.rs -sSf | sh -s -- -y export PATH=~/.cargo/bin:$PATH source ~/.cargo/env # Install certbot sudo snap install --classic certbot && sudo ln -s /snap/bin/certbot /usr/bin/certbot # Get the relayer code git clone https://github.com/webb-tools/relayer.git # Build the executable cd relayer && cargo build --release","title":"Basic Environment Setup"},{"location":"relayer/setup/#relayer-configuration","text":"Create your .env file in the base directory of the project. A list of potential networks to support is defined below. Make sure to provide the private key with funds on the appropriate network. Remove networks which you do not wish to support from below. List of supported networks .env # Mainnets WEBB_EVM_HARMONYMAINNET0_ENABLED=true WEBB_EVM_SHIDEN_ENABLED=true HARMONYMAINNET0_PRIVATE_KEY=<0x_PREFIXED_PRIVATE_KEY_AS_HEX_STRING> SHIDEN_PRIVATE_KEY=<0x_PREFIXED_PRIVATE_KEY_AS_HEX_STRING> # Testnets WEBB_EVM_HARMONYTESTNET0_ENABLED=true WEBB_EVM_HARMONYTESTNET1_ENABLED=true WEBB_EVM_RINKEBY_ENABLED=true WEBB_EVM_GOERLI_ENABLED=true WEBB_EVM_ROPSTEN_ENABLED=true WEBB_EVM_BERESHEET_ENABLED=true HARMONYTESTNET0_PRIVATE_KEY=<0x_PREFIXED_PRIVATE_KEY_AS_HEX_STRING> HARMONYTESTNET1_PRIVATE_KEY=<0x_PREFIXED_PRIVATE_KEY_AS_HEX_STRING> RINKEBY_PRIVATE_KEY=<0x_PREFIXED_PRIVATE_KEY_AS_HEX_STRING> GOERLI_PRIVATE_KEY=<0x_PREFIXED_PRIVATE_KEY_AS_HEX_STRING> ROPSTEN_PRIVATE_KEY=<0x_PREFIXED_PRIVATE_KEY_AS_HEX_STRING> BERESHEET_PRIVATE_KEY=<0x_PREFIXED_PRIVATE_KEY_AS_HEX_STRING>","title":"Relayer Configuration"},{"location":"relayer/setup/#fine-tuned-configuration","text":"All configurations in the repo can be tuned to your preference. Below is a line-by-line explanation of all configurable values for an example configuration supporting Rinkeby: Rinkeby configuration [evm.rinkeby] # Endpoints to archival nodes which are running for the given network http-endpoint = \"https://rinkeby.infura.io/v3/9aa3d95b3bc440fa88ea12eaa4456161\" ws-endpoint = \"wss://rinkeby.infura.io/ws/v3/9aa3d95b3bc440fa88ea12eaa4456161\" # The block explorer of the given network for clickable transactions in relayer logs explorer = \"https://rinkeby.etherscan.io\" # The chain-id of the network chain-id = 4 # The hex string private key correlating to a value in the .env file. private-key = \"$RINKEBY_PRIVATE_KEY\" # A network configuration can define multiple contracts to listen to [[evm.rinkeby.contracts]] # The 'Tornado' contract is a tornado cash implementation contract = \"Tornado\" # The address for the particular contract address = \"0x626FEc5Ffa7Bf1EE8CEd7daBdE545630473E3ABb\" # The relayer may query for previous state starting from the deployed-at block until the present block. deployed-at = 8896800 # The denomination for mixers - applicable for 'Tornado' and 'Anchor' contracts size = 0.1 # If the events-watcher is enabled, the relayer will poll for events of this contract at the interval and update its own # storage. Used for providing leaves to clients that request them, and necessary for integration in the dapp. events-watcher = { enabled = false, polling-interval = 15000 } # The fee defined by the relayer for sending transactions on behalf of clients. withdraw-fee-percentage = 0.05 # Configurable gaslimit for transactions. Set this to a reasonable value for the given chain. withdraw-gaslimit = \"0x350000\" [[evm.rinkeby.contracts]] # An 'Anchor' contract is the building block of the bridge protocol. It provides privacy like a 'Tornado' # contract and maintains state for the anchors which link to it for cross-chain functionality. contract = \"Anchor\" address = \"0x15A66977f0A9D21e09eB6C1B42b001aF992f0C8f\" deployed-at = 9568750 size = 0.01 events-watcher = { enabled = true, polling-interval = 15000 } withdraw-fee-percentage = 0 withdraw-gaslimit = \"0x350000\" linked-anchors = [ { chain = \"ropsten\", address = \"0x0711Ea63FDEDD2c8a9d3C9340a5A8F6cd84b6A92\" }, { chain = \"goerli\", address = \"0x025348e15e9d5529E5A4A55E8eA7eC923b7fB8b6\" }, ]","title":"Fine-tuned Configuration"},{"location":"relayer/setup/#relayer-setup","text":"Setup the relayer as a system service: # Create the service file sudo touch /etc/systemd/system/webb-relayer.service # This assumes a config.toml file has been setup in a config/ directory # and the repo has been cloned in the home directory of the user # Paste the following into the service file, and replace the <user>: [Unit] Description=WebbRelayer [Service] Type=exec WorkingDirectory=/home/<user>/relayer ExecStart=/home/<user>/relayer/target/release/webb-relayer -c /home/<user>/relayer/config/ -vvv [Install] WantedBy=multi-user.target Kick off the system service: sudo systemctl enable webb-relayer && sudo systemctl start webb-relayer","title":"Relayer setup"},{"location":"relayer/setup/#nginx-setup","text":"Configure your registered domain name with your cloud service provider. Install nginx if it isn't already on your machine: sudo apt install nginx First, we will configure the endpoint linked to your at port 80 for certificate generation Create nginx site files for your domain: cd /etc/nginx/sites-available && sudo cp default <domain name> && sudo ln -s /etc/nginx/sites-available/<domain name> /etc/nginx/sites-enabled/ Modify the nginx sites-available file to: server { listen 80; listen [::]:80; root /var/www/<domain name>/html; index index.html index.htm index.nginx-debian.html; server_name <domain name>; location / { try_files $uri $uri/ =404; } } Check the nginx configuration sudo nginx -t If no issues exist, restart the nginx service sudo systemctl restart nginx Next we will create the self-signed certificate and reconfigure for https and wss support Create the self-signed certificate: sudo certbot certonly --nginx Modify the nginx site file: map $http_upgrade $connection_upgrade { default upgrade; '' close; } server { # SSL configuration # listen 443 ssl; listen [::]:443 ssl; root /var/www/<domain name>/html; server_name <domain name>; ssl_certificate /etc/letsencrypt/live/<domain name>/cert.pem; ssl_certificate_key /etc/letsencrypt/live/<domain name>/privkey.pem; ssl_session_timeout 5m; ssl_protocols SSLv2 SSLv3 TLSv1 TLSv1.1 TLSv1.2; ssl_ciphers HIGH:!aNULL:!MD5; ssl_prefer_server_ciphers on; location / { proxy_pass http://127.0.0.1:9955; proxy_pass_request_headers on; proxy_http_version 1.1; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection $connection_upgrade; } } Check nginx configuration and restart.","title":"Nginx Setup"},{"location":"relayer/setup/#monitoring-setup","text":"Relayers will want to setup monitoring to ensure maximum uptime and automatic restarts when things go awry. sudo apt install -y monit modify the monitrc file at: /etc/monit/monitrc set httpd port 2812 and use address localhost allow localhost set daemon 10 set log /var/log/monit.log set idfile /var/lib/monit/id set statefile /var/lib/monit/state set eventqueue basedir /var/lib/monit/events slots 100 check process webb-relayer matching target/release/webb-relayer start program = \"/bin/systemctl restart webb-relayer\" stop program = \"/bin/systemctl kill webb-relayer\" if cpu > 90% for 20 cycles then exec \"/bin/systemctl stop webb-relayer\" and repeat every 10 cycles if cpu > 90% for 64 cycles then exec \"/bin/systemctl kill webb-relayer\" and repeat every 10 cycles if cpu > 90% for 64 cycles then alert if does not exist for 1 cycles then start restart monit and validate: sudo monit reload && sudo monit validate","title":"Monitoring Setup"},{"location":"relayer/setup/#dapp-integration","text":"After completing the above steps, submit a PR with changes for your https endpoint: Webb Dapp","title":"Dapp Integration"},{"location":"relayer/websockets/","text":"The relayer is setup to receive WebSockets connections at the endpoint /ws . Clients can issue requests to the relayer by sending appropriately formatted data. Websockets Requests \u00b6 Send Transaction to EVM Network \u00b6 The most fundamental aspect of a relayer, is to send transactions on behalf of clients. relayWithdraw Data Formatting { evm: { chain: <string> contract: <string> proof: <string> root: <string> nullifierHash: <string> recipient: <string> relayer: <string> fee: <string> refund: <string> } } Field Explanations chain : The name of the chain to withdraw from. contract : The contract address to withdraw from. proof : The client-side generated proof from secret values. The proof should be generated with appropriate relayer and fee values from the info query. root : The historical merkle root for which the proof was constructed. nullifierHash : The hash of one of the secret values, nullifier, for which the mixer can mark a commitment as spent. recipient : The address for which the funds (denomination - fee) will be sent. relayer : The address for which the fee will be sent. fee : The amount to provide to the relayer. refund : Should be '0' for native tokens, and equivalent to the denomination for ERC20 mixers.","title":"WebSockets"},{"location":"relayer/websockets/#websockets-requests","text":"","title":"Websockets Requests"},{"location":"relayer/websockets/#send-transaction-to-evm-network","text":"The most fundamental aspect of a relayer, is to send transactions on behalf of clients. relayWithdraw Data Formatting { evm: { chain: <string> contract: <string> proof: <string> root: <string> nullifierHash: <string> recipient: <string> relayer: <string> fee: <string> refund: <string> } } Field Explanations chain : The name of the chain to withdraw from. contract : The contract address to withdraw from. proof : The client-side generated proof from secret values. The proof should be generated with appropriate relayer and fee values from the info query. root : The historical merkle root for which the proof was constructed. nullifierHash : The hash of one of the secret values, nullifier, for which the mixer can mark a commitment as spent. recipient : The address for which the funds (denomination - fee) will be sent. relayer : The address for which the fee will be sent. fee : The amount to provide to the relayer. refund : Should be '0' for native tokens, and equivalent to the denomination for ERC20 mixers.","title":"Send Transaction to EVM Network"},{"location":"repos/overview/","text":"There are quite a few repositories that work together to bring our Webb ecosystem to life: Webb Dapp \u00b6 Repo The Webb Dapp is the portal into the Webb. It is the frontend which allows end users to move their assets and retain their privacy. Relayer \u00b6 Repo It is non-trivial to get access to funds in two separate addresses without linking these two addresses. The relayer helps to facilitate privacy from an on-chain transaction perspective. Users send transactions for withdrawing from the ecosystem to the relayer, and the relayer executes these transactions. Webb.rs \u00b6 Repo Implementations of core Webb aspects in rust. Core pieces include data structures like merkle trees, hasher implementations like the pederson hash, EVM interaction with ethers.rs. Tornado Core \u00b6 Repo Forked from Tornado cash - core logic for EVM smart contract mixers. Javascript implementations of circuit and key generation. Scripts for interacting with these smart contracts. Protocol Solidity \u00b6 Repo Implementation of the Webb with private bridges inspired by chainsafe and generalized merkle trees that can accept a variety of hash functions. Anon \u00b6 Repo A substrate node which contains the merkle and mixer pallets. These pallets are built using ed25519 and bulletproofs precompiles. Arkworks Gadgets \u00b6 Repo Gadgets and constraints written using the arkworks libraries for Webb. Protocol Substrate \u00b6 Repo A substrate node using rust crates to build a parachain implementation of Webb. protocol-substrate is a rearchitecting of the anon node to optimize for runtime blob size.","title":"Organisation Repos"},{"location":"repos/overview/#webb-dapp","text":"Repo The Webb Dapp is the portal into the Webb. It is the frontend which allows end users to move their assets and retain their privacy.","title":"Webb Dapp"},{"location":"repos/overview/#relayer","text":"Repo It is non-trivial to get access to funds in two separate addresses without linking these two addresses. The relayer helps to facilitate privacy from an on-chain transaction perspective. Users send transactions for withdrawing from the ecosystem to the relayer, and the relayer executes these transactions.","title":"Relayer"},{"location":"repos/overview/#webbrs","text":"Repo Implementations of core Webb aspects in rust. Core pieces include data structures like merkle trees, hasher implementations like the pederson hash, EVM interaction with ethers.rs.","title":"Webb.rs"},{"location":"repos/overview/#tornado-core","text":"Repo Forked from Tornado cash - core logic for EVM smart contract mixers. Javascript implementations of circuit and key generation. Scripts for interacting with these smart contracts.","title":"Tornado Core"},{"location":"repos/overview/#protocol-solidity","text":"Repo Implementation of the Webb with private bridges inspired by chainsafe and generalized merkle trees that can accept a variety of hash functions.","title":"Protocol Solidity"},{"location":"repos/overview/#anon","text":"Repo A substrate node which contains the merkle and mixer pallets. These pallets are built using ed25519 and bulletproofs precompiles.","title":"Anon"},{"location":"repos/overview/#arkworks-gadgets","text":"Repo Gadgets and constraints written using the arkworks libraries for Webb.","title":"Arkworks Gadgets"},{"location":"repos/overview/#protocol-substrate","text":"Repo A substrate node using rust crates to build a parachain implementation of Webb. protocol-substrate is a rearchitecting of the anon node to optimize for runtime blob size.","title":"Protocol Substrate"},{"location":"shielded-pool-protocols/tornado-pool/overview/","text":"Basics of Tornado Pool \u00b6 Tornado Pool allows for users to deposit and withdraw arbitrary amounts. It also allows users to do a shielded transfer to another user inside the pool. UTXO Model \u00b6 The project utilizes the UTXO (unspent transaction output) model to handle users' funds, so we first review it. (partially copied from Wikipedia) The total UTXOs present in the Tornado Pool represents a set (which we call the UTXO set). Every transaction consumes elements from this set and creates new ones that are added to the set. Thus, the set represents all of the funds in the Tornado Pool. put exact structure here Let's first see how different actions affect the total size of the UTXO set of the Tornado Pool. Depositing into the Pool: This increases the amount of funds in the UTXO set by the deposit amount. Withdrawing from the Pool: This decreases the amount of funds in the UTXO set by the withdrawal amount. Shielded Transaction to Another User: This keeps the amount of funds in the UTXO set the same. We define the inputUTXOs to be the elements from the UTXO set that are spent during a transaction. We define the outputUTXOs to be the elements of the UTXO set that are created during a transaction. If there are no funds being deposited or withdrawn from the Tornado Pool, we have the following invariant for any transaction: sum of inputUTXOs = sum of outputUTXOs . Suppose publicAmount is being deposited or withdrawn from the pool. Then, for any transaction we have the following invariant sum of inputUTXOs + publicAmount = sum of outputUTXOs . Let's do an example with numbers: Initially the UTXO set = {} (is empty). Alice deposits 8 ETH into pool. inputUTXOs = {0 ETH} publicAmount = 8 ETH outputUTXOs = {8 ETH} UTXO Set = {8 ETH} Alice deposits 9 ETH into pool. UTXO Set = {8 ETH, 9 ETH} inputUTXOs = {0 ETH} publicAmount = 9 ETH outputUTXOs = {9 ETH} UTXO Set = {8 ETH, 9 ETH} Alice withdraws 11 ETH from pool. inputUTXOs = {8 ETH, 9 ETH} publicAmount = -11 ETH outputUTXOs = {6 ETH} UTXO Set = {6 ETH} Bob deposits 1 ETH into pool. inputUTXOs = {0 ETH} publicAmount = 1 ETH outputUTXOs = {1 ETH} UTXO Set = {6 ETH} Alice transfers 3 ETH to Bob. inputUTXOs = {6 ETH} publicAmount = 0 ETH outputUTXOs = {3 ETH, 3 ETH} UTXO Set = {3 ETH, 3 ETH, 1 ETH} Notice that the invariant sum of inputUTXOs + publicAmount = sum of outputUTXOs holds in each of the steps. Since this invariant covers depositing and withdrawing, we do not need separate functions for each but rather a single transact function which takes care of both depositing and withdrawing. When Alice calls the transact function on the Tornado Pool contract she will submit a proof that (amongst other things) the invariant holds for her proposed transaction. Exact UTXO Structure \u00b6 Although in the examples in the previous section we represented a UTXO by its amount , the exact structure of a UTXO in Tornado Pool is more complex. In Tornado Pool, a UTXO is a triplet {amount, publicKey, blinding} and the commitiment that gets added to the Merkle tree maintained by the Tornado Pool is Poseidon(amount, publicKey, blinding) . The blinding is a random number, like the secret in the original Tornado cash. The public key corresponds to the owner of the UTXO and when transact is called, it is checked that only the person with the corresponding private key can spend the input (more on exactly how this happens in a later section). The private key and public key are related by: publicKey = Poseidon(privateKey) . Preventing Double Spending via Nullifiers \u00b6 What prevents Alice from spending the same UTXO twice? Tornado Pool has a nullifier corresponding to every UTXO. When a UTXO is spent, the corresponding nullifier is recorded on the Tornado Pool smart contract, which prevents the same UTXO from being spent again. The structure of the nullifier is Poseidon(commitment, merklePath, privateKey) . Note this structure implies that the nullifier of each UTXO is unique. Transaction Proof \u00b6 When Alice submits calls the transact function on the smart contract, she needs to prove the following things (there are few other things she needs to show, but we omit them for now) about her transaction: The inputUTXOs she wants to spend actually exist She owns the inputUTXOs that she wants to spend. The inputUTXOs that she wants to spend have not already been spent. The invariant sum of inputUTXOs + publicAmount = sum of outputUTXOs holds. She needs to do this while keeping certain information private. Therefore, like in the original Tornado Cash, Alice uses zero-knowledge proofs to convince the smart contract that she is submitting a valid transaction. To do so, we construct a Transaction(levels, nIns, nOuts, zeroLeaf) circuit, such that the constraints of this circuit are satisfied if and only if Alice submits a valid transaction. levels is the number of levels in the Tornado Pool Merkle tree, nIns is the number of inputUTXOs being spent, nOuts is the number of outputUTXOs being created, and zeroLeaf is Poseidon(0, 0) . The private inputs to the Transaction circuit are: inAmount[nIns] , the amount for each of the inputUTXOs inPrivateKey[nIns] , the private key for each of the inputUTXOs inBlinding[nIns] , the blinding for each of the inputUTXOs inPathIndices[nIns] , a binary string that indicates whether the corresponding pathElement element is on the left or right side of the Merkle tree for each inputUTXO inPathElements[nIns][levels] an array of the Merkle proof elements for each inputUTXO outAmount[nOuts] , the amount of each of the outputUTXOs outPubKey[nOuts] , the public key of each of the outputUTXOs outBlinding[nOuts] , the blinding of each of the outputUTXOs The public inputs to the Transaction circuit are: root the root of the Tornado Pool Merkle tree publicAmount , explained in detail in the section below extDataHash , hash of extData (which contains information like the recipient , relayer and fee )..not used in any computations, so we will ignore discussing it. inputNullifier[nIns] , the nullifier corresponding to each of the inputUTXOs outputCommitment[nOuts] , the commitment of each of the outputUTXOs The Transaction circuit works as follows: For each inputUTXO : The public key is calculated from the private key using a KeyPair() gadget. The commitment is calculated from the amount, public key and blinding. A MerkleProof(levels) gadget is used to check whether the commitment exists in the Tornado Pool Merkle tree The above three steps show that the inputUTXOs that Alice wants to spend exist and are owned by her. It is also checked that the nullifiers are correctly computed. This is so that Alice doesn't submit a bogus inputNullifier[nIns] array and then double spend the inputUTXOs . For each outputUTXO : It's checked that the output commitments are correctly computed. It's also checked that there are no two input nullifiers which are the same. This prevents double spending the same inputUTXO within a single transact call. The invariant sumIns = publicAmount + sumOuts is checked where sumIns is the sum of the elements in inAmount[nIns] and sumOuts is the sum of the elements in outAmount[nOuts] . The individual gadgets are explained in more detail here: merkleProof.circom keypair.circom extamount, fees, and Privacy Relayers \u00b6 Similar to Tornado Cash, to add more privacy, relayers are used to execute the transactions. These relayers take fees. The publicAmount is the amount actually transferred to/from the Tornado Pool during a transact . Due to relayer fees, this differs from the amount of funds a user must send during a deposit/shielded transfer or the amount the user actually receives during a withdraw transact: this amount is known as extAmount . The publicAmount is derived from extAmount via the formula: publicAmount = extAmount - fee . To see why this makes sense lets look at a concrete example where fee = 5 ETH . There are three cases for the three types of transactions (although recall that all of them are encompassed by the single function transact ): Deposit Transact: Say we want to deposit 10 into the Tornado Pool. We really have to send 15 ETH since 5 ETH is taken by the relayer. So 15 ETH = extamount = 10 ETH + 5 ETH = publicAmount + fee . Shielded Transfer: The publicAmount is 0 ETH, but we really have to send 5 ETH to pay the relayer. We have: 0 ETH = publicAmount = 5 ETH - 5 ETH = extAmount - fee . Withdraw Transact: Say you want to withdraw 10 ETH, you really have to withdraw 15 ETH since 5 ETH will go to the relayer. So publicAmount = -15 ETH = -10 ETH - 5 ETH = extAmount - fee . References \u00b6 https://github.com/tornadocash/tornado-pool https://en.wikipedia.org/wiki/Unspent_transaction_output","title":"Overview"},{"location":"shielded-pool-protocols/tornado-pool/overview/#basics-of-tornado-pool","text":"Tornado Pool allows for users to deposit and withdraw arbitrary amounts. It also allows users to do a shielded transfer to another user inside the pool.","title":"Basics of Tornado Pool"},{"location":"shielded-pool-protocols/tornado-pool/overview/#utxo-model","text":"The project utilizes the UTXO (unspent transaction output) model to handle users' funds, so we first review it. (partially copied from Wikipedia) The total UTXOs present in the Tornado Pool represents a set (which we call the UTXO set). Every transaction consumes elements from this set and creates new ones that are added to the set. Thus, the set represents all of the funds in the Tornado Pool. put exact structure here Let's first see how different actions affect the total size of the UTXO set of the Tornado Pool. Depositing into the Pool: This increases the amount of funds in the UTXO set by the deposit amount. Withdrawing from the Pool: This decreases the amount of funds in the UTXO set by the withdrawal amount. Shielded Transaction to Another User: This keeps the amount of funds in the UTXO set the same. We define the inputUTXOs to be the elements from the UTXO set that are spent during a transaction. We define the outputUTXOs to be the elements of the UTXO set that are created during a transaction. If there are no funds being deposited or withdrawn from the Tornado Pool, we have the following invariant for any transaction: sum of inputUTXOs = sum of outputUTXOs . Suppose publicAmount is being deposited or withdrawn from the pool. Then, for any transaction we have the following invariant sum of inputUTXOs + publicAmount = sum of outputUTXOs . Let's do an example with numbers: Initially the UTXO set = {} (is empty). Alice deposits 8 ETH into pool. inputUTXOs = {0 ETH} publicAmount = 8 ETH outputUTXOs = {8 ETH} UTXO Set = {8 ETH} Alice deposits 9 ETH into pool. UTXO Set = {8 ETH, 9 ETH} inputUTXOs = {0 ETH} publicAmount = 9 ETH outputUTXOs = {9 ETH} UTXO Set = {8 ETH, 9 ETH} Alice withdraws 11 ETH from pool. inputUTXOs = {8 ETH, 9 ETH} publicAmount = -11 ETH outputUTXOs = {6 ETH} UTXO Set = {6 ETH} Bob deposits 1 ETH into pool. inputUTXOs = {0 ETH} publicAmount = 1 ETH outputUTXOs = {1 ETH} UTXO Set = {6 ETH} Alice transfers 3 ETH to Bob. inputUTXOs = {6 ETH} publicAmount = 0 ETH outputUTXOs = {3 ETH, 3 ETH} UTXO Set = {3 ETH, 3 ETH, 1 ETH} Notice that the invariant sum of inputUTXOs + publicAmount = sum of outputUTXOs holds in each of the steps. Since this invariant covers depositing and withdrawing, we do not need separate functions for each but rather a single transact function which takes care of both depositing and withdrawing. When Alice calls the transact function on the Tornado Pool contract she will submit a proof that (amongst other things) the invariant holds for her proposed transaction.","title":"UTXO Model"},{"location":"shielded-pool-protocols/tornado-pool/overview/#exact-utxo-structure","text":"Although in the examples in the previous section we represented a UTXO by its amount , the exact structure of a UTXO in Tornado Pool is more complex. In Tornado Pool, a UTXO is a triplet {amount, publicKey, blinding} and the commitiment that gets added to the Merkle tree maintained by the Tornado Pool is Poseidon(amount, publicKey, blinding) . The blinding is a random number, like the secret in the original Tornado cash. The public key corresponds to the owner of the UTXO and when transact is called, it is checked that only the person with the corresponding private key can spend the input (more on exactly how this happens in a later section). The private key and public key are related by: publicKey = Poseidon(privateKey) .","title":"Exact UTXO Structure"},{"location":"shielded-pool-protocols/tornado-pool/overview/#preventing-double-spending-via-nullifiers","text":"What prevents Alice from spending the same UTXO twice? Tornado Pool has a nullifier corresponding to every UTXO. When a UTXO is spent, the corresponding nullifier is recorded on the Tornado Pool smart contract, which prevents the same UTXO from being spent again. The structure of the nullifier is Poseidon(commitment, merklePath, privateKey) . Note this structure implies that the nullifier of each UTXO is unique.","title":"Preventing Double Spending via Nullifiers"},{"location":"shielded-pool-protocols/tornado-pool/overview/#transaction-proof","text":"When Alice submits calls the transact function on the smart contract, she needs to prove the following things (there are few other things she needs to show, but we omit them for now) about her transaction: The inputUTXOs she wants to spend actually exist She owns the inputUTXOs that she wants to spend. The inputUTXOs that she wants to spend have not already been spent. The invariant sum of inputUTXOs + publicAmount = sum of outputUTXOs holds. She needs to do this while keeping certain information private. Therefore, like in the original Tornado Cash, Alice uses zero-knowledge proofs to convince the smart contract that she is submitting a valid transaction. To do so, we construct a Transaction(levels, nIns, nOuts, zeroLeaf) circuit, such that the constraints of this circuit are satisfied if and only if Alice submits a valid transaction. levels is the number of levels in the Tornado Pool Merkle tree, nIns is the number of inputUTXOs being spent, nOuts is the number of outputUTXOs being created, and zeroLeaf is Poseidon(0, 0) . The private inputs to the Transaction circuit are: inAmount[nIns] , the amount for each of the inputUTXOs inPrivateKey[nIns] , the private key for each of the inputUTXOs inBlinding[nIns] , the blinding for each of the inputUTXOs inPathIndices[nIns] , a binary string that indicates whether the corresponding pathElement element is on the left or right side of the Merkle tree for each inputUTXO inPathElements[nIns][levels] an array of the Merkle proof elements for each inputUTXO outAmount[nOuts] , the amount of each of the outputUTXOs outPubKey[nOuts] , the public key of each of the outputUTXOs outBlinding[nOuts] , the blinding of each of the outputUTXOs The public inputs to the Transaction circuit are: root the root of the Tornado Pool Merkle tree publicAmount , explained in detail in the section below extDataHash , hash of extData (which contains information like the recipient , relayer and fee )..not used in any computations, so we will ignore discussing it. inputNullifier[nIns] , the nullifier corresponding to each of the inputUTXOs outputCommitment[nOuts] , the commitment of each of the outputUTXOs The Transaction circuit works as follows: For each inputUTXO : The public key is calculated from the private key using a KeyPair() gadget. The commitment is calculated from the amount, public key and blinding. A MerkleProof(levels) gadget is used to check whether the commitment exists in the Tornado Pool Merkle tree The above three steps show that the inputUTXOs that Alice wants to spend exist and are owned by her. It is also checked that the nullifiers are correctly computed. This is so that Alice doesn't submit a bogus inputNullifier[nIns] array and then double spend the inputUTXOs . For each outputUTXO : It's checked that the output commitments are correctly computed. It's also checked that there are no two input nullifiers which are the same. This prevents double spending the same inputUTXO within a single transact call. The invariant sumIns = publicAmount + sumOuts is checked where sumIns is the sum of the elements in inAmount[nIns] and sumOuts is the sum of the elements in outAmount[nOuts] . The individual gadgets are explained in more detail here: merkleProof.circom keypair.circom","title":"Transaction Proof"},{"location":"shielded-pool-protocols/tornado-pool/overview/#extamount-fees-and-privacy-relayers","text":"Similar to Tornado Cash, to add more privacy, relayers are used to execute the transactions. These relayers take fees. The publicAmount is the amount actually transferred to/from the Tornado Pool during a transact . Due to relayer fees, this differs from the amount of funds a user must send during a deposit/shielded transfer or the amount the user actually receives during a withdraw transact: this amount is known as extAmount . The publicAmount is derived from extAmount via the formula: publicAmount = extAmount - fee . To see why this makes sense lets look at a concrete example where fee = 5 ETH . There are three cases for the three types of transactions (although recall that all of them are encompassed by the single function transact ): Deposit Transact: Say we want to deposit 10 into the Tornado Pool. We really have to send 15 ETH since 5 ETH is taken by the relayer. So 15 ETH = extamount = 10 ETH + 5 ETH = publicAmount + fee . Shielded Transfer: The publicAmount is 0 ETH, but we really have to send 5 ETH to pay the relayer. We have: 0 ETH = publicAmount = 5 ETH - 5 ETH = extAmount - fee . Withdraw Transact: Say you want to withdraw 10 ETH, you really have to withdraw 15 ETH since 5 ETH will go to the relayer. So publicAmount = -15 ETH = -10 ETH - 5 ETH = extAmount - fee .","title":"extamount, fees, and Privacy Relayers"},{"location":"shielded-pool-protocols/tornado-pool/overview/#references","text":"https://github.com/tornadocash/tornado-pool https://en.wikipedia.org/wiki/Unspent_transaction_output","title":"References"},{"location":"shielded-pool-protocols/tornado-pool/circuits/keypair/","text":"keypair.circom \u00b6 Inputs \u00b6 privateKey Outputs \u00b6 publicKey Sub-Gadgets \u00b6 hasher , which is a one input Poseidon hasher Functionality/How it Works \u00b6 Uses hasher to hash privateKey . The output of this is the public key. References \u00b6 https://github.com/tornadocash/tornado-pool/blob/onchain-tree/circuits/keypair.circom","title":"keypair.circom"},{"location":"shielded-pool-protocols/tornado-pool/circuits/keypair/#keypaircircom","text":"","title":"keypair.circom"},{"location":"shielded-pool-protocols/tornado-pool/circuits/keypair/#inputs","text":"privateKey","title":"Inputs"},{"location":"shielded-pool-protocols/tornado-pool/circuits/keypair/#outputs","text":"publicKey","title":"Outputs"},{"location":"shielded-pool-protocols/tornado-pool/circuits/keypair/#sub-gadgets","text":"hasher , which is a one input Poseidon hasher","title":"Sub-Gadgets"},{"location":"shielded-pool-protocols/tornado-pool/circuits/keypair/#functionalityhow-it-works","text":"Uses hasher to hash privateKey . The output of this is the public key.","title":"Functionality/How it Works"},{"location":"shielded-pool-protocols/tornado-pool/circuits/keypair/#references","text":"https://github.com/tornadocash/tornado-pool/blob/onchain-tree/circuits/keypair.circom","title":"References"},{"location":"shielded-pool-protocols/tornado-pool/circuits/merkleProof/","text":"merkleProof.circom \u00b6 template MerkleProof(levels) Inputs \u00b6 leaf pathElements[levels] pathIndices Outputs \u00b6 root Sub-Gadgets \u00b6 switcher[levels] , basically the same thing as: hasher[levels] , two input Poseidon hasher. Functionality/How it Works \u00b6 (taken from comments) Verifies that Merkle proof is correct for a given Merkle root and a leaf. Uses hasher[levels] to compute Merkle root from pathElements[levels] and the leaf . The switcher gadgets are necessary because depending on whether the Merkle proof element is on the left or right side (as indicated by pathIndices[levels] ), the inputs to the hash function have to be re-ordered. This is because Poseidon(left, right) does not equal Poseidon(right, left) . References \u00b6 https://github.com/tornadocash/tornado-pool/blob/onchain-tree/circuits/merkleProof.circom","title":"merkleProof.circom"},{"location":"shielded-pool-protocols/tornado-pool/circuits/merkleProof/#merkleproofcircom","text":"template MerkleProof(levels)","title":"merkleProof.circom"},{"location":"shielded-pool-protocols/tornado-pool/circuits/merkleProof/#inputs","text":"leaf pathElements[levels] pathIndices","title":"Inputs"},{"location":"shielded-pool-protocols/tornado-pool/circuits/merkleProof/#outputs","text":"root","title":"Outputs"},{"location":"shielded-pool-protocols/tornado-pool/circuits/merkleProof/#sub-gadgets","text":"switcher[levels] , basically the same thing as: hasher[levels] , two input Poseidon hasher.","title":"Sub-Gadgets"},{"location":"shielded-pool-protocols/tornado-pool/circuits/merkleProof/#functionalityhow-it-works","text":"(taken from comments) Verifies that Merkle proof is correct for a given Merkle root and a leaf. Uses hasher[levels] to compute Merkle root from pathElements[levels] and the leaf . The switcher gadgets are necessary because depending on whether the Merkle proof element is on the left or right side (as indicated by pathIndices[levels] ), the inputs to the hash function have to be re-ordered. This is because Poseidon(left, right) does not equal Poseidon(right, left) .","title":"Functionality/How it Works"},{"location":"shielded-pool-protocols/tornado-pool/circuits/merkleProof/#references","text":"https://github.com/tornadocash/tornado-pool/blob/onchain-tree/circuits/merkleProof.circom","title":"References"}]}